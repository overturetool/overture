\documentclass{overturerepchap}
%**********************************************************
%
% Bibliography support
%
%**********************************************************
%\def\@reportno{YY--NN}		% default report no.
%\def\reportno#1{\gdef\@reportno{#1}}
\usepackage{capt-of}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{longtable}
\newcommand{\bthisbibliography}[1]{\chapter*{References}%
   \begin {list} {}%
     {\settowidth {\labelwidth} {[#1]XX}%
      \setlength {\leftmargin} {\labelwidth}%
      \addtolength{\leftmargin} {\labelsep}%
      \setlength {\parsep} {1ex}%
      \setlength {\itemsep} {2ex}%
     }
  }
\newcommand{\ethisbibliography}{\end{list}}
\newcommand{\refitem}[2]
  {\bibitem[#1]{#2}}

\newcommand{\back}{$\setminus$}
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index

  \end{tabbing}\end{quote}
  }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Model transformation rule box
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcounter{formationRule}
\setcounter{formationRule}{0}
\newenvironment{formationRule}
%{\refstepcounter{formationRule}\vspace{10pt}\par\noindent
%Exercise \theformationRule
%\begin{itshape}\par\noindent\vspace{10pt}}%
%{\end{itshape}\vspace{10pt}\par}
{%
\refstepcounter{formationRule}
%increment
%\addtocounter{transformationRuleCounter}{1}%
%\ctf{}%
%\labelformat{formationRule}{\value{formationRule}}
\begin{center}%
\begin{tabular}{ | p{10cm} |}\hline%
\textbf{Transformation Rule \theformationRule}

}
{
\\
    \hline
    \end{tabular}
\end{center}

}
\newcommand{\kw}[1]{{\textbf\ttfamily #1}}
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{Overture VDM-10 Tool Support: User Guide}
\fancyhead[RO,LE]{\resizebox{0.05\textwidth}{!}{\includegraphics{overture}}}
\fancyfoot[C]{\thepage}

\usepackage{makeidx}

\usepackage{graphicx, color}

% definition of VDM++, JavaCC, JJTree, JTB, ANTLR and SableCC for listings
\newcommand{\NL}{\mbox{}\\ \vspace*{-5mm}}
\usepackage{listings}
\newcommand{\url}[1]{\texttt{#1}}
\usepackage{vdmsl-2e}
\usepackage{hyperref}

\usepackage{times}
\usepackage{color}
\include{customlangdef}
% define the layout for listings
\lstdefinestyle{tool}{basicstyle=\ttfamily,
                         frame=trBL,
			 showstringspaces=false,
			 frameround=ffff,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
\lstdefinestyle{mystyle}{basicstyle=\footnotesize\ttfamily,
                         frame=trBL,
%                         numbers=left,
%			 gobble=0,
%			 basewidth=0.51em,
                         showstringspaces=false,
%			 linewidth=\textwidth,
			 frameround=fttt,
			 aboveskip=2mm,
			 belowskip=2mm,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
%\lstdefinestyle{mystyle}{basicstyle=\sffamily\small,
%			 frame=tb,
%                         numbers=left,
%			 gobble=0,
%			 showstringspaces=false,
%			 linewidth=345pt,
%			 frameround=ffff,
%			 framexleftmargin=8mm,
%			 framexrightmargin=8mm,
%			 framextopmargin=1mm,
%			 framexbottommargin=1mm,
%			 aboveskip=7mm,
%			 belowskip=5mm,
%			 xleftmargin=10mm,}

\lstset{style=mystyle}
\lstset{language=VDM++}
%\lstset{alsolanguage=Java}
% The command below enables you to escape into normal LaTeX mode inside your
% VDM chunks by starting with a `!' character and ending with a `!'
\lstset{escapeinside=!!}

%This file has been converted to use LaTeX2e
%\documentstyle[overture]{article}
%
% any "\include{...}" statements go here
%
\include{ifad}
\include{graphics}
\usepackage{cite}
\usepackage{alltt}
%\usepackage{fancyhdr}
\renewcommand{\topfraction}{0.9}
\renewcommand{\textfraction}{0.05}
\renewcommand{\floatpagefraction}{0.9}
\makeindex

\begin{document}
\title{Overture VDM-10 Tool Support: User Guide}
\author{Peter Gorm Larsen, Kenneth Lausdahl, Peter J\o{}rgensen, Joey Coleman and Sune Wolff \\
Aarhus University, Department of Engineering\\
Finlandsgade 22, DK-8000 \AA{}rhus C, Denmark\\[3mm]
Nick Battle\\
Fujitsu UK\\
Lovelace Road, Bracknell, \\
Berkshire. RG12 8SN, UK}

\date{April 2013}

\reportno{TR-002}

\maketitle


\textbf{Document history}

\begin{tabular}{|l|l|l|l|}\hline
Month   & Year & Version & Version of Overture.exe \\ \hline
January & 2010 &         & 0.1.5 \\ \hline
March   & 2010 &         & 0.2   \\ \hline
May     & 2010 & 1       & 0.2   \\ \hline
February& 2011 & 2       & 1.0.0   \\ \hline
June    & 2011 & 3       & 1.0.1   \\ \hline
April   & 2013 & 4       & 2.0.0 \\ \hline
\end{tabular}

\tableofcontents

\begin{abstract}
This document is the user manual for the Overture Integrated Development
Environment (IDE) for
VDM. It serves as a reference for anybody wishing to make use of
the tool with one of the VDM dialects (VDM-SL, VDM++ or VDM-RT).
Overture tool support is built on top of the Eclipse platform. The
objective of the Overture initiative is to create and support an open source
platform that can be used for both experimentation with new VDM dialects,
as well as new features for analysing VDM
models in different ways. The tool is entirely open source, so anybody
can join the development team and influence future
developments. The long term goal is to ensure that stable
versions of the tool suite can be used for large scale industrial
applications of VDM technology.
\end{abstract}

\chapter{Introduction}

The Vienna Development Method (VDM) is one of the longest established
model-oriented formal methods for the development of computer-based
systems and software
\cite{Bjorner&78,Jones90a,Fitzgerald&08c}. It consists of a
group of mathematically well-founded languages for expressing system
models during early design stages, before expensive implementation
commitments are made. The construction and analysis of a model using
VDM helps to identify areas of incompleteness or ambiguity in
informal system specifications, and provides some level of confidence
that a valid implementation will have key properties, especially those
of safety or security. VDM has a strong record of industrial
application, in many cases has been used
by practitioners who were not specialists in
the underlying formalism or logic
\cite{Larsen&96b,Clement&99,Kurita&09}. Experience with the method
suggests that the effort expended on formal modelling and analysis can
be recovered in reduced rework costs arising from design errors.

VDM models are expressed in a specification language (VDM-SL) which
supports the description of data and functionality
\cite{ISOVDM96a,Fitzgerald&98b,Fitzgerald&09}. Data are defined by
means of types built using constructors that define structured data
and collections such as sets, sequences and mappings from basic values
such as Booleans and natural numbers. These types are very abstract,
allowing you to add any relevant constraints using data type
invariants. Functionality is defined in terms of operations over these
data types. Operations can be defined implicitly by preconditions and
postconditions that characterize their behavior, or explicitly by
means of specific algorithms. An extension of VDM-SL, called VDM++,
supports object-oriented structuring of models and permits direct
modelling of concurrency \cite{Fitzgerald&05}. A further extension
to VDM++, called VDM Real Time (VDM-RT\footnote{Formerly called VDM In a
Constrained Environment (VICE).}), includes support for discrete
time models \cite{Mukherjee&00,Verhoef&06b}. All
three VDM dialects are supported by Overture.

Since VDM modelling languages have a formal mathematical semantics,
a wide range of analyses can be performed on models, both to check
internal consistency and to confirm that models have emergent
properties. Analyses may be performed by inspection, static analysis,
testing or mathematical proof. To assist in this process, Overture
offers tool support for building models in collaboration with other
modelling tools, to execute and test models and to carry out different
forms of static analysis \cite{Larsen&13b}. It can be seen as an open
source version of the closed (but now freely available) tool called VDMTools
\cite{Elmstrom&94,Larsen01,Fitzgerald&08a} although features to
generate executable code in high-level programming languages are
not yet available in Overture.

This guide explains how to use the Overture IDE for developing models
for different VDM dialects. It starts with an explanation
of how to get hold of the software in
Chapter~\ref{sec:install}. This is followed in
Chapter~\ref{sec:vdmsupport} with an introduction to the Eclipse
workspace terminology. Chapter~\ref{sec:projects} explains how
projects are managed in the Overture IDE. Chapter~\ref{sec:editVDM}
covers the features for creating and editing VDM models. This is
followed in Chapter~\ref{sec:debug} with an explanation of the
interpretation and debugging capabilities in Overture.
Chapter~\ref{sec:testcoverage} illustrates how test coverage
information can be gathered when models are interpreted.
Chapter~\ref{sec:prettyprint} shows how models with test
coverage information can be written as
\LaTeX\ and automatically converted to PDF format.
Chapters~\ref{sec:POmanagement} to \ref{sec:showlog} cover various
VDM specific features: Chapter~\ref{sec:POmanagement}
explains the notion of proof obligations and their support in
Overture; Chapter~\ref{sec:testing} explains
combinatorial testing and the automation support for that;
Chapter~\ref{sec:vdmuml} explains the support for mapping between
object-oriented VDM models and UML models; Chapter~\ref{sec:ToVDMRT}
shows how a VDM++ project can be
converted into a new VDM-RT project; Chapter~\ref{sec:showlog} shows
how to analyse and display execution logs from VDM-RT models; 
Chapter~\ref{sec:linkToJava} demonstrates how Java can be used in 
combination with VDM models and
Chapter~\ref{sec:commandline} gives an
overview of the features of Overture which are also available from
a command-line interface. Appendix~\ref{app:templates} provides a list
of all the standard templates built into Overture.
Appendixes~\ref{app:internalerrors}
to~\ref{app:POcategories} give complete lists of possible errors,
warnings and proof obligation categories. Appendix~\ref{chap:umlrules} provides
an overview of the VDM++/VDM-RT to UML mapping rules. 
Appendix~\ref{cha:VDMvalues} provides details about how to represent VDM 
values in order to combine Java with VDM as described in Chapter~\ref{sec:linkToJava}.
Finally, Appendix~\ref{sec:index} is an index of significant terms used in the
user manual.


\chapter{Getting Hold of the Software}\label{sec:install}

\begin{description}
\item[\textbf{Overture:}] This
 is an open source tool, developed by volunteers and built on
the Eclipse platform. The project is managed on
SourceForge\footnote{\url{https://sourceforge.net/projects/overture/}}.
The best way to run Overture is to download a special version of
Eclipse with the Overture functionality already pre-installed. If you
go to:
  \begin{quote}
  \texttt{http://sourceforge.net/projects/overture/files/}
  \end{quote}
  \noindent you will find pre-installed versions of Overture for
  Windows, Linux and Mac\footnote{It is planned to develop an update
    facility, allowing updates to be applied directly from within the
    Overture tools without requiring a reinstallation. However, this
    can be a risky process because of the dependencies on non-Overture
    components and so is not yet supported.}.

\item[\textbf{Modelio:}] This is a tool that is both available in a commercial version as well as in an open source setting from a
  company called Softeam. Just like Overture this tool is built on top of the Eclipse platform. The product can be
  obtained from
\begin{quote}
\texttt{http://www.modelio.org/}.
\end{quote}
\end{description}

For Overture you can use the \textit{Download Now} button to
  automatically download pre-installed versions of Overture for your
  operating system.  Supported systems are: Windows, Linux and
  Mac.
Simply extract the zip file downloaded and run the Overture executable
file at the top level to start the tool. Note that in order to be able
to execute Overture you need to have Java Runtime Environment (minimum
version~1.7) installed on your computer.
When you start Overture for the first time, it will request a workspace
location. We recommend that you choose the default location proposed
by Overture and tick the box for ``Use this as the default and do
not ask again''. A welcome screen will introduce you to the overall
mission of the Overture open source initiative the first time that you
run the tool and provide you with a number of interesting pointers of
additional material (see
Figure~\ref{fig:userguire:welcomeWindow}).\index{welcome screen} You
can always get back to this page using \emph{Help} $ \rightarrow$
\emph{Welcome}.

\begin{figure}[!htb]
\begin{center}
  \includegraphics[width=\textwidth]{screenDumps/welcomeWindow}
  \caption{The Overture Welcome Screen}
  \label{fig:userguire:welcomeWindow}
\end{center}
\end{figure}

Large libraries of sample VDM-SL, VDM++ and VDM-RT models are available
and can be downloaded from SourceForge under the
\texttt{files/Examples} section using the URL\footnote{The library
  files are intended to be used with Eclipse, but can also be opened with
  file compression programs like \texttt{Winrar} on Windows}:
\begin{quote}
\url{https://sourceforge.net/projects/overture/files/Examples/}
\end{quote}
Such existing projects can be imported into Overture as described in
section~\ref{subsec:importproj}.

Finally, in order to make use of the
test coverage feature described in Section~\ref{sec:testcoverage} it is
necessary to have the text processing system called \LaTeX\ and its
\texttt{pdflatex} feature. This can for example be obtained from:
\begin{quote}
\url{http://miktex.org/2.9/}
\end{quote}

\chapter{Using the VDM Perspective}\label{sec:vdmsupport}

\section{Understanding Eclipse Terminology}

Eclipse is an open source platform based around a
\emph{workbench}\index{workbench} that provides a common look and feel
to a large collection of extension products. If you are
familiar with one Eclipse product, you will generally find it easy to start
using other products that use the same workbench. The Eclipse workbench
consists of several panels known as \emph{views}\index{view}, such as
those shown in Figure~\ref{fig:userguire:OverturePerspective}.
A particular arrangement of views
is called a \emph{perspective}\index{perspective}\index{perspective!VDM}, for example
Figure~\ref{fig:userguire:OverturePerspective} shows the standard
VDM perspective. This consists of a set of views for managing
Overture projects and viewing and editing files in a
project. Different perspectives are available in Overture as will be
described later, but for the moment think of a perspective as a
useful composition of views for conducting a particular task.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=\textwidth]{figures/OverturePerspective}
  \caption[labelInTOC]{The VDM Perspective}
  \label{fig:userguire:OverturePerspective}
\end{center}
\end{figure}

The \emph{VDM Explorer}\index{explorer} view lets you create, select,
and delete Overture projects and navigate between the files in these
projects, as well as adding new files to existing projects. A new VDM
project is created choosing the \emph{File} $ \rightarrow$ \emph{New}
$\rightarrow$ \emph{Project} option which results in the dialog shown in
Figure~\ref{fig:userguide:newOvertureProjectSL}. Select
the desired VDM dialect and press \emph{Next}. Finally, the project
needs to be given a name. Click \texttt{Finish} to create the project.
Depending upon the dialect of VDM used in a given project,
a corresponding Overture \emph{Editor} view will be available to edit the files of
your new project. Dialect editors are sensitive to the keywords used in
each particular dialect, and simplify the task of working on the
specification.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=2.5in]{figures/newovertureSLproject}
  \caption[labelInTOC]{Creating a New VDM Project}
  \label{fig:userguide:newOvertureProjectSL}
\end{center}
\end{figure}


The \emph{Outline}\index{outline} view, on the right hand side of
Figure~\ref{fig:userguire:OverturePerspective}, presents an outline of
the file selected
in the editor. The outline shows all VDM definitions, such as
state definitions, values, types, functions and operations. The
type of each definition is also shown in the view and the colour of
the icons in front of the names indicates the accessibility of each
definition. Red is
used for private definitions, yellow for protected definitions and
green for public definitions. Triangles are used for
type definitions, small squares are used for values, state components
and instance variables, functions and operations are represented by
larger circles and squares, permission predicates are shown with small
lock symbols and traces are shown with a
``\texttt{T}''. Functions have a small ``\texttt{F}'' superscript over the
icons and static definitions have a small ``\texttt{S}'' superscript.
Record types have a small arrow in front of the
icon, and if that is clicked the fields of the record can be seen.
Figure~\ref{fig:OutlineIcons} illustrates the different outline icons.
At the top of the view there are buttons to filter what is displayed,
for instance it is possible to hide non-public members.

\begin{figure}[!htb]
\begin{center}
  \includegraphics[width=2.5in]{figures/OutlineIcons}
  \caption[labelInTOC]{Icons in the Outline View}
  \label{fig:OutlineIcons}
\end{center}
\end{figure}

Clicking on the name of a definition in the outline will navigate to
the definition and highlight the name in the Editor view.

The \emph{Problems}\index{problems} view at the bottom of
Figure~\ref{fig:userguire:OverturePerspective} displays
information messages about the projects you are
working on, such as warnings and syntax or type checking errors.

The \emph{VDM Quick Interpreter}\index{quick interpreter}
view has a small command-line at the bottom where a plain VDM expression
(not depending upon the definitions in the VDM model you are working
with but for that you can use the ``Console'' launch mode explained in
Section~\ref{sec:launchmodes}) can be
entered. When return is pressed, the expression will be evaluated and
the result shown above the command-line.

Most of the other features of the workbench, such as the menus and
toolbars, are similar to other Eclipse applications, with the exception
of a special menu with Overture specific functionality.

\section{Additional Eclipse Features Applicable in Overture}

\subsection{Opening and Closing Projects}

To de-clutter the workspace and reduce the risk of accidental changes,
it may be helpful to close projects that are not used being worked on.
This can be done by right clicking such projects and then selecting the
\emph{Close Project} entry in the menu. Projects can similarly be re-opened
using the same menu.\index{project!open}\index{project!close}

%\begin{figure}[!htb]
%\begin{center}
%  \includegraphics[width=2in]{screenDumps/closeproject}
%  \caption[labelInTOC]{Closing a Project}
%  \label{fig:closeproject}
%\end{center}
%\end{figure}

\subsection{Adding Additional VDM File Extensions}

It is possible to associate additional or different filename extensions with a
particular VDM dialect editor, instead of the standard {\ttfamily .vdmsl},
{\ttfamily .vdmpp} and {\ttfamily .vdmrt}. This is done using the \emph{Window}
$\rightarrow$ \emph{Preferences} menu. Click the Add
button for the appropriate content type.\index{file extension}

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.6\textwidth]{screenDumps/contentstypes}
\caption{Adding Additional Contents Types\label{fig:ContentsTypes}}
\end{center}
\end{figure}

\subsection{Filtering Project Contents}

It is possible to filter out certain file types from the VDM Explorer view.
This is done by clicking the small downward pointing arrow at the top
right-most corner of the view. See
Figure~\ref{fig:filteringfiles}. The \emph{Filters...} option allows
various files or directories to be hidden, including
directories that have no source files.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.4\textwidth]{screenDumps/filteringfiles}
\caption{Filtering Directories without source files\label{fig:filteringfiles}}
\end{center}
\end{figure}

\subsection{Including line numbers in the Editor}

If line numbers\index{line number} are required in the dialect
editors, right click in the left-hand margin
of the editor and select \texttt{show line numbers} as shown in
Figure~\ref{fig:linenumbers}.\index{line numbers} Note that the current
line number and cursor position are displayed in the eclipse status
bar, at the bottom of the workspace, when an editor has focus.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.4\textwidth]{screenDumps/linenumbers}
\caption{Adding Line Numbers in Editor\label{fig:linenumbers}}
\end{center}
\end{figure}

%\subsection{Adding external plug-ins to Overture IDE}

%The Overture IDE is build as a RCP\footnote{Rich Client Platform} and
%there no update manager is included -- external plug-ins can
%still be manually installed though. To install a plug-in there are two
%things which needs to be done:
%\begin{enumerate}
%\item Copy the plug-in jar or jars into the plugin folder of the Overture IDE installation; and
%\item Add the plug-in jar file names to the \texttt{osgi.bundles} in the config.ini file which is found under the folder configuration.
%\end{enumerate}

%After the steps above have been performed, the IDE can be started and the new plug-ins will be available. (Remember to include all depended plug-ins which is not already a part of the Overture IDE).

%For example, in order to add SVN support to the Overture IDE you simply have to:
%\begin{enumerate}
%\item Fetch the update site jars from \url{http://subclipse.tigris.org/} under \emph{Download and Install} and select \emph{Zipped downloads}. The latest version demonstrated in this guide is site-1.6.10.zip.
%\item Copy the features and plugins folders into the Overture IDE folder, merging them with the ones of Overture.
%\item Then add the plugins to the \texttt{osgi.bundles} in the \texttt{confi.ini} file separated by comma.
%\begin{itemize}
%\item \url{org.tigris.subversion.clientadapter}
%\item \url{org.tigris.subversion.clientadapter\_1.6.10.jar}
%\item \url{org.tigris.subversion.clientadapter.javahl}
%\item \url{org.tigris.subversion.clientadapter.javahl\_1.6.9.3.jar}
%\item \url{org.tigris.subversion.clientadapter.javahl.win32}
%\item \url{org.tigris.subversion.clientadapter.javahl.win32\_1.6.9}
%\item \url{org.tigris.subversion.subclipse.core}
%\item \url{org.tigris.subversion.subclipse.core\_1.6.10.jar}
%\item \url{org.tigris.subversion.subclipse.doc}
%\item \url{org.tigris.subversion.subclipse.doc\_1.3.0.jar}
%\item \url{org.tigris.subversion.subclipse.graph}
%\item \url{org.tigris.subversion.subclipse.graph\_1.0.7.jar}
%\item \url{org.tigris.subversion.subclipse.ui}
%\item \url{org.tigris.subversion.subclipse.ui\_1.6.10.jar}
%\end{itemize}
%When the steps above are completed the Overture IDE can be started and SVN support will be available.
%\end{enumerate}

\chapter{Managing Overture Projects}\label{sec:projects}

\section{Importing Overture Projects}\label{subsec:importproj}

It is possible to import Overture projects by
right-clicking in the Explorer view and selecting \emph{Import}, followed
by \emph{General} $\rightarrow$ \emph{Existing Projects into
  Workspace}.  In this way the projects from \texttt{.zip} files
mentioned in Chapter~\ref{sec:install} can be imported very
easily.\index{project!import}

\section{Creating a New Overture Project}

Follow these steps to create a new Overture project:

\begin{enumerate}
	\item Create a new project by choosing \emph{File}
          $\rightarrow$ \emph{New} $\rightarrow$ \emph{Project}
          $\rightarrow$ \emph{Overture}; \index{project!create}
	\item Select the VDM dialect you wish to use (VDM-SL, VDM-PP
          or VDM-RT);\index{VDM dialect}
	\item Click \emph{Next};
         \item Type in a project name;
	\item Choose whether you would like the contents of the new
          project to be in your workspace or outside
          (browse to the appropriate directory); 
\item The next step enables references to other projects (but this is not used at the moment);
\item The next step enables inclusion of VDM libraries and
    \item Click	the \texttt{Finish} button (see Figure~\ref{fig:CreateProjectWizard}).
\end{enumerate}

\begin{figure}[!htb]
	\begin{center}
	  \includegraphics[scale=0.8]{figures/CreateProjectWizard}
	  \caption[Create Project Wizard]{Create Project Wizard}
	  \label{fig:CreateProjectWizard}
	\end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Creating a new file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creating Files}

Switching to the VDM perspective will change the layout of the user
interface to focus on VDM development. To change perspective, go to the menu
\emph{Window} $\rightarrow$ \emph{Open perspective} $\rightarrow$
\emph{Other...} and choose the VDM perspective.
From this perspective you can create files
using one of the following methods:

\begin{enumerate}
  \item Choose \emph{File} $\rightarrow$ \emph{New} $\rightarrow$
    \emph{VDM-SL Module}\index{creating!VDM-SL module} or
    \emph{VDM-PP Class}\index{creating!VDM++ class} or
    \emph{VDM-RT Class}\index{creating!VDM-RT class} or
  \item Right click on the Overture project where you would like to
    add a new file and then choose \emph{New} $\rightarrow$
    \emph{VDM-SL Module} or \emph{VDM-PP Class} or \emph{VDM-RT Class}.
\end{enumerate}

In both cases you need to choose a file name and optionally choose a
directory if you do not want to place the file in the home directory of
the chosen Overture project. Then a new file with the appropriate file
extension (according to the chosen dialect, \texttt{.vdmsl},
\texttt{.vdmpp} or \texttt{.vdmrt})\index{vdm file extension} will be
created in the directory. This file will use the appropriate
module/class template to get you started. Naturally, keywords
that are not required can be deleted from the template.

\section{Adding Standard Libraries}

In addition to adding new empty files it is possible to add existing
standard libraries. This can be done by right-clicking on the project
where the library is to be added and then selecting \emph{New} $\rightarrow$
    \emph{Add VDM Library}. That will make a new window as shown in
    Figure~\ref{fig:NewLibraries}. Here the different standard
    libraries provide different standard functionalities. In the body
    of many of these functions/operations are declared as
    ``{\textbf{\ttfamily is not yet specified}}'' but the actual
    functionality for all of these are hard-coded into Overture so the
    user can get access to this when the respective standard libraries
    are included. This can be
    summarised as:

\begin{description}
\item[IO:] This library provides functionality for input and output
  from/to files and the standard console.
\item[Math:] This library provides functionality for standard
  mathematical functions such as sine and cosine.
\item[Util:] This library provides functionality for converting
  different kind of VDM values mainly to and from files and strings.
\item[CSV:] This library is an extension of the IO library which
  provides additional functionality for saving and reading VDM values
  to/from comma seperate format used by excel spreadsheets.
\item[VDM-Unit:] This library provides functionality for unit testing
  of VDM models similar to the well-known JUnit library.
\end{description}

\begin{figure}[!htb]
	\begin{center}
	  \includegraphics[scale=0.8]{figures/NewLibraries}
	  \caption[Adding New Libraries]{Adding New Libraries}
	  \label{fig:NewLibraries}
	\end{center}
\end{figure}

These libraries are available for all VDM dialects also when a flat
VDM-SL specification is used.

\section{Setting Project Options}\label{subsec:options}

There are various VDM
specific settings for an Overture project. You can change these by
selecting a project
in the \emph{Explorer} view and then right clicking and selecting
\emph{Properties}. See Figure~\ref{fig:VDMSettings}. The options
that can be set for each VDM project are:\index{project!options}

\begin{figure}[!hbt]
\begin{center}
  \includegraphics[width=\textwidth]{screenDumps/projectsettings}
  \caption[Overture Project Settings]{Overture Project Settings}
  \label{fig:VDMSettings}
\end{center}
\end{figure}

\begin{description}
\item[Language version:] Here the default is to use the
  \emph{classic} version which is similar to that used in
  VDMTools. Alternatively you can select VDM-10 which
  is a new improved (but not necessarily backwards compatible) version of
  the VDM dialects developed by the Overture Language Board.
\item[Suppress type checking warnings:] Warnings are enabled
  by default but you can change it here.
\end{description}

Overture allows VDM specifications to be embedded in \LaTeX\ files that
form part of the documentation of a project as seen in
Figure~\ref{fig:VDMSettingsLatex}. The project settings allow you
to define a main \LaTeX\ file for the project, and define the order in which the
different VDM source files shall be included. Note that if the
``\texttt{Insert coverage tables}'' and ``\texttt{Mark coverage}''
options are selected the \LaTeX\ pretty printing will include test
coverage information as well as provide test coverage tables for each
class/module in the VDM model. It is also possible to define your own
main document instead of making use of the standard one suggested by
Overture (which is the name of the project followed by \texttt{.tex}). 
Finally, the ``\texttt{Model only}" option is used to select if you 
wish to include only the VDM model or also the text that can be written
outside \verb+\begin{vdm_al}+'' and ``\verb+\end{vdm_al}+'' environments 
(see Chapter~\ref{sec:prettyprint} for more details).

\begin{figure}[!hbt]
\begin{center}
  \includegraphics[width=\textwidth]{screenDumps/projectsettingslatex}
  \caption[Overture Project Settings]{Overture Project Settings for \LaTeX}
  \label{fig:VDMSettingsLatex}
\end{center}
\end{figure}

It is also possible to set various preferences that apply to
all projects. This is done in the general VDM preferences dialog under
\emph{Window} $\rightarrow$ \emph{Preferences} $\rightarrow$
\emph{VDM}. Here, for example, it is possible to link projects to
VDMTools if you have the appropriate SCSK executables installed on
the computer. Figure~\ref{fig:SCSKPreferences} shows how it is possible to
set up paths to the corresponding VDMTools executables. If these paths have
been set, it is possible to right click on a project in the VDM
Explorer view and select \emph{VDM Tools} $\rightarrow$
\emph{Open project in VDMTools}. Then a project file for VDMTools
will automatically be generated with all the files from the Overture project
and VDMTools will be opened. 

The \emph{Preferences} dialog also
allows you to switch off continuous syntax checking while editing and
to set the path to \emph{pdflatex} if this is not automatically
visible from the Overture application. It is also possible to set a few
other areas (debugger and dot) but these are mostly used by the developers.
Finally it is possible to
manage VDM templates, but that is described in Section~\ref{sec:templates}.

\begin{figure}[!hbt]
\begin{center}
  \includegraphics[width=\textwidth]{screenDumps/CSKPreferences}
  \caption{Overture Preferences for connections to VDMTools}
  \label{fig:SCSKPreferences}
\end{center}
\end{figure}

In the same fashion it is possible to set preferences for the way VDM++ and VDM-RT models are mapped to UML. 
This can be seen in Figure~\ref{fig:UMLpreferences}. More information about 
these preferences can be found in Chapter~\ref{sec:vdmuml}.

\begin{figure}[!hbt]
\begin{center}
  \includegraphics[width=\textwidth]{screenDumps/UMLpreferences}
  \caption{Overture Preferences for mapping to UML}
  \label{fig:UMLpreferences}
\end{center}
\end{figure}

\chapter{Editing VDM Models}\label{sec:editVDM}

\section{VDM Dialect Editors}

VDM model files are always changed in the dialect Editor view. Syntax checking
is carried out continuously as source files are
changed (even before the files are saved). Whenever files are saved, assuming
there are no syntax errors, a full type check of the \emph{entire} VDM model is
performed.
Problems and warnings will be listed in the Problems view as well as
being highlighted directly in the Editor view where the problems have been
identified.


\section{Using Templates}\label{sec:templates}

Eclipse templates can be particularly useful when writing VDM models. If you
press \textit{CTRL+space} after typing the first few characters of a template name,
Overture will offer a proposal. For example, if you type ''fun'' followed
by \textit{CTRL+space}, the IDE will propose the use of an implicit or explicit
function template as shown in Figure~\ref{fig:functionTemplate}. The IDE includes
several templates: cases, quantifications, functions (explicit/implicit),
operations (explicit/implicit) and many more. The use of templates makes it much
easier for users to create models, even if they are not deeply familiar
with the VDM syntax.

\begin{figure}
\begin{center}
\includegraphics[width=4in]{figures/FunctionTemplate}
\caption{Explicit function template}
\label{fig:functionTemplate}
\end{center}
\end{figure}

It is possible to adjust or add to the templates defined in
Overture. This can be done in the general VDM preferences under
\emph{Window} $\rightarrow$ \emph{Preferences} $\rightarrow$ \emph{VDM}
$\rightarrow$ \emph{Templates}. Figure~\ref{fig:Templatepreferences} shows
where to adjust templates in Overture. Note
that new templates can be added and the existing ones can be
edited or removed. A full list of the
standard Overture templates is available in Appendix~\ref{app:templates}.

\begin{figure}
\begin{center}
\includegraphics[width=4in]{screenDumps/templatesRT}
\caption{Adjusting templates for Overture}
\label{fig:Templatepreferences}
\end{center}
\end{figure}

\chapter{Interpretation and Debugging in Overture}\label{sec:debug}

This chapter describes how to run and debug a model using the Overture IDE.

\section{Run and Debug Launch Configurations}\label{sec:launchmodes}

To execute or debug a VDM model, you must first create a launch
configuration\index{debug configuration}. To do this, go to the main Run menu
and select \emph{Run} $\rightarrow $ \emph{Run Configurations}. Select the type of
project you want to launch, click the \texttt{New} icon to
create a new launch specification of that type and give it a name. The
launch dialog requires you to identify the VDM project name,
the class/module name and the initial operation/function to call in that
class/module. Figure~\ref{fig:userguide:launchconfig} shows a launch
dialog. The standard Eclipse strategy is the launch mode called
``Entry point'' and then you simply click
the Browse button and it will let you select a project from
those available in the workspace. Clicking the Search button will search the chosen
project for classes and modules to select a public operation or function from.
If the chosen operation or function has parameters, the types and names of those
parameters will be copied into the Operation box -- these \emph{must} be replaced with
valid argument values\footnote{You will see type checking errors at the top of the
dialog if you do not do this, such as "Error 3063: Too few arguments in ..."}.

However, there are other launch mode possibilities here as
well.\index{launch configuration mode} The
``Remote Control'' launch mode is advanced but it is explained in more
detail in Section~\ref{sec:Remote}. The ``Console'' launch mode
enables you to get a special debug console where you can enter
multiple entry points (one after another) instead of deciding upon the
single entry point at launch time\footnote{Those familiar with
  VDMTools will recognise this functionaility as initialising a
  specific VDM model and then having a prompt where different
  expressions can be evaluated making use of the definitions from the model.}.
The commands that can be used in the ``Console'' view correspond to
the commands you can give at command-line when it has been started in
interpreter mode (see Section~\ref{sec:commandlineinterpreter}).

Your new launch configuration can be started immediately by clicking the \emph{Run}
button at the bottom of the dialog. Alternatively, the configuration can simply be
saved by clicking \emph{Apply}. Once a launch configuration has been defined, it
can be re-run at any time by using the small downward arrow next to the run or
debug icons (\includegraphics[width=0.03\textwidth]{icons/debuggericon})
in the IDE toolbar.

A launch configuration can either be started normally, which will simply evaluate
the expression given and stop, or it can be started in debug mode, which will
stop the evaluation at any breakpoints you may have set. The same launch configuration
can be used for either purpose, though by default those created through the
\emph{Run Configurations} dialog will appear in the favourites list under the
\emph{Run} toolbar icon. Similarly, a launch configuration created under the
\emph{Debug Configurations} dialog will appear under the favourites of the
debug toolbar icon. You can control which icons display the launch configuration
in the \emph{Common} tab on the dialog. This is standard Eclipse behaviour.


\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{screenDumps/launchconfig}
  \caption{The launch configuration dialog}
  \label{fig:userguide:launchconfig}
\end{center}
\end{figure}

Whenever a launch configuration is started up it is also possible to
decide upon which additional run-time checks to carry out. By default
all possible run-time checks are swiched on but if desired (some of)
these can be swiched off using the ``Runtime'' pane (see
Figure~\ref{fig:userguide:launchconfigRToptions}). Note that for
VDM-RT debugging it is also possible to switch off the logging of all
events appearing during the debugging. The different run-time checks
that can be performed are:

\begin{description}
\item[Dynamic type checks:] This is an option for the interpreter (default on)
  to continuously type check  values during interpretation of a VDM model.
  It is possible to switch off the check here\footnote{However a consequence of doing that can be that you may get internal Java errors (null pointer or class cast exceptions typically) rather than nice clean VDM type errors about mismatched types.}.
\item[Invariant checks:] This is an option for the interpreter (default on)
  to continuously check both state and type invariants.
  It is possible to switch off
  this check here, but note that option requires dynamic type
  checking also to be switched off.
\item[Pre condition checks:] This is an option for the interpreter (default on)
  to continuously check pre-conditions for all functions and operations
  during interpretation of a VDM model. It is possible to switch off
  this check here.
\item[Post condition checks:] This is an option for the interpreter (default on)
  to continuously check post-conditions for all functions and operations
  during interpretation of a VDM model. It is possible to switch off
  this check here.
\item[Measure checks:] This is an option for the interpreter (default
  on) to continuously check recursive functions, for which a
  measure function has been defined. It is possible to switch off this
  check here\footnote{Note that this feature may not work correctly with the 
presence of mutually recursive function definitions.}.
\end{description}

In the launch
configuration the ``Debugger'' pane shown in
Figure~\ref{fig:userguide:launchconfigSpecialoptions} can also be
useful in rare cases where one has particularly deep recursion for
example. This is an advanced setting where one can decide the
arguments given to the Java virtual machine for allocation of maximum
amounts of space per thread in a VDM model. However, this option is
rarely needed.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{screenDumps/launchconfigRToptions}
  \caption{The launch configuration dialog}
  \label{fig:userguide:launchconfigRToptions}
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{screenDumps/launchconfigSpecialoptions}
  \caption{The launch configuration dialog}
  \label{fig:userguide:launchconfigSpecialoptions}
\end{center}
\end{figure}

\section{The Debug Perspective}

The Debug Perspective\index{debug perspective} contains all the views
commonly needed for debugging in VDM. Breakpoints can easily be set in the
model by double clicking in the left margin of the Editor view at the chosen
line. When the debugger reaches the location of a breakpoint and stops, you can
inspect the values of different identifiers and step through the VDM model
line by line.\index{perspective!debug}

The Debug Perspective is illustrated in Figure~\ref{fig:userguide:DebuggingVDM}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{figures/DebuggingVDM}
  \caption[Debugging perspective]{Debugging perspective}
  \label{fig:userguide:DebuggingVDM}
\end{center}
\end{figure}

%The \emph{Debug view} is located in the upper left corner in the Debug
%perspective. The Debug view shows all running models and the call stacks
%belonging to them. It also shows whether a given model is stopped, suspended or
%running. All threads are also shown, along with their running status. It is
%possible to switch between threads from the Debug view.

\begin{table}
\begin{center}
\caption{Overture debugging buttons\label{tab:debugButtons}}
\begin{tabular}{|l|l|}\hline \hline
\textbf{Button} & \textbf{Explanation} \\ \hline
\includegraphics[width=0.03\textwidth]{figures/resume} & Resume
debugging\index{icon!resume debugging} \\
\includegraphics[width=0.03\textwidth]{figures/suspend} & Suspend
debugging\index{icon!suspend debugging}\\
\includegraphics[width=0.03\textwidth]{figures/terminate} & Terminate
debugging\index{icon!terminate debugging}\\
\includegraphics[width=0.03\textwidth]{figures/stepinto} & Step
into\index{icon!step into}\\
\includegraphics[width=0.03\textwidth]{figures/stepover} & Step
over\index{icon!step over} \\
\includegraphics[width=0.03\textwidth]{figures/stepreturn} & Step
return\index{icon!step return}\\
\includegraphics[width=0.03\textwidth]{figures/stepbystep} & Use step
filters\index{icon!use step filters}\\
\hline \hline
\end{tabular}
\end{center}
\end{table}

\subsection{The Debug View}

The \emph{Debug} view is located in the upper left corner in the Debug perspective --
see Figure~\ref{fig:userguide:DebuggingVDM}. The view shows all running
models and whether a given model is stopped, suspended or running.
It shows the call stack of models that are suspended, and for VDM++ and VDM-RT stacks
for all threads are shown.
At the top of the view, there are buttons
for debugging such as: stop, step into, step over, resume, etc. (see
Table~\ref{tab:debugButtons}). Note that in case a multi-threaded VDM
model is debugged it is possible in this view to change to another
thread to inspect where it is currently and inspect the local
variables at that thread since they are all stopped when a breakpoint
is reached.

\subsection{The Variables View}

The \emph{Variables} view shows all the variables in a thread context, allowing them to be
examined after a breakpoint (or an error) has been reached. The variables and their values are
automatically updated when stepping through a model. The view is
located in the upper right hand corner in the Debug perspective. It is
possible to inspect compound variables, expand nested structures and
so on. Note that when you stop at a permission predicate it is also
possible to see the value of the relevant history counters (in
Figure~\ref{fig:userguide:DebuggingVDM} \texttt{\#fin(ClientSend)} and
\texttt{\#fin(ServerListen)}). By right-clicking on a variable it is
possible to select a ``watch point''. As a result a window like
Figure~\ref{fig:watchpoint} will occur. Using this it is possible to
watch the value of such a variable easily whenever a new stop is
reached in the debugging process.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=.5\textwidth]{screenDumps/watchpoint}
  \caption{Example of a watchpoint}
  \label{fig:watchpoint}
\end{center}
\end{figure}

\subsection{The Breakpoints View}

Breakpoints can be added in any perspective from the Editor view\footnote{Note that
breakpoints can only be set on lines that contain executable code.}.
The debug perspective also has a \emph{Breakpoints} view that lists all current
breakpoints, allowing you to navigate easily to the location of a given breakpoint,
disable it or delete it. The view is located in
the same panel as the Variables view in the upper right hand corner.


\subsection{Conditional Breakpoints}
\label{sec:userguide:breakpoints}

Breakpoints can be conditional. This is a powerful feature for the
developer since it allows you to specify a conditional expression
which has to be true for the debugger to stop at the given breakpoint.
As well as using an expression, a conditional breakpoint may specify a
hit count and whether the breakpoint should stop when the hit count is
equal to, greater than, or a multiple of the given value, or a general
expression using the variables in scope at the breakpoint.

A normal breakpoint can be made conditional by right clicking on the breakpoint
mark in the Editor view\footnote{Note this is not possible from the Breakpoint view}
and selecting \emph{Breakpoint Properties}. This opens a dialog like the one shown in
Figure~\ref{fig:userguide:BreakpointConditional}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=.6\textwidth]{figures/Breakpointconditional}
  \caption{Conditional breakpoint options}
  \label{fig:userguide:BreakpointConditional}
\end{center}
\end{figure}

\subsection{The Expressions View}

The \emph{Expressions} view allows you to define expressions that are evaluated
whenever the debugger stops.
Watched expressions can be added to the view directly, or created by selecting \emph{Watch}
when right-clicking a variable in the Variables view. It is also possible to edit existing
expressions. The view sits in the same panel as the Breakpoints view and
the Variables view.

\chapter{Collecting Test Coverage Information}\label{sec:testcoverage}

When a VDM model is being interpreted, it is possible to automatically collect
test coverage information. Test coverage measurements help you to see how well a
given test suite\index{Test Coverage!Test suite} exercises your VDM model.

In order to enable the collection of test coverage data, go to the debug launch
configuration and select the \emph{Generate coverage} option. After
running this configuration, a new file with a \texttt{.cov} extension will be created for
each file in the project. These files are written into a project subfolder named
\texttt{generated/coverage/<date and time>}. Double-clicking the \texttt{.cov} files
will open a special editor window that displays the source with coverage
coloured in red/green (red is executable but not covered). Alternatively, a PDF file
containing the entire model with coloured test coverage summarised for all runs
can be generated
by right-clicking on the project name and selecting \emph{Latex} $\rightarrow$
\emph{Latex Coverage}.

\chapter{Pretty Printing to \LaTeX}\label{sec:prettyprint}

%Include \texttt{overture.tex} which among other things makes use of the
%\texttt{times.cls} and \texttt{listings.cls} style classes. This enables
%the use of the standard \texttt{lstlisting} environment for type setting
%source text and display it in a fixed width font where all VDM keywords
%are typeset in bold.

It is possible to use literate programming/specification \cite{Johnson96} with
Overture just as you can with VDMTools. To take advantage of this,
you need to use the \LaTeX\ text processing system with
plain VDM models mixed with textual documentation.  The VDM model parts must be
enclosed within ``\verb+\begin{vdm_al}+'' and ``\verb+\end{vdm_al}+''. The
text-parts outside these specification blocks are ignored by the VDM parser,
though note that each source file must start with a recognizable \LaTeX\
construct: a \verb+\documentclass, \section, \subsection+ or a \LaTeX\ comment.


\chapter{Managing Proof Obligations}\label{sec:POmanagement}

In all VDM dialects, Overture can identify places where run-time errors
\emph{could} potentially occur if the model was to be executed. The analysis of
these areas can be considered
as a complement to the static type checking that is performed automatically.
Type checking accepts specifications that are \emph{possibly} correct, but
we also want to know the places where the specification could possibly fail.

Unfortunately, it is not always possible to statically check if such
potential problems will \emph{actually} occur at run-time error or not. So Overture
creates \emph{Proof Obligations}\index{proof obligation} for all the places
where run-time errors \emph{could} occur. Each proof obligation (PO)
is formulated as a predicate that must hold at a particular place in the VDM
model if it is error-free, and so it may have particular context information
associated with it. POs can be considered as
constraints that will guarantee the internal integrity of a VDM model if they
are all met. In the long term, it will be possible to prove these constraints
with a proof component in Overture, but this is not yet available.

POs can be divided into different categories\index{proof obligation!categories}
depending upon their nature. The full list of categories can be found in
Appendix~\ref{app:POcategories} along with a short description for
each of them.

The proof obligation generator is invoked either on a VDM project (and
then POs for all the VDM model files will be generated) or for one
selected VDM file. Right-click the project or file in the Explorer view and
then select \emph{Proof Obligations} $\rightarrow$ \emph{Generate Proof
  Obligations}. Overture will change into a special
\emph{Proof Obligations} perspective\index{proof
  obligation!perspective} as shown in
Figure~\ref{fig:POView}.\index{perspective!proof obligation}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{figures/POView}
\caption{The Proof Obligation perspective\label{fig:POView}}
\end{center}
\end{figure}

Note that in the \emph{Proof Obligation Explorer} view, each proof
obligation has four components:
\begin{itemize}
\item A unique number in the list shown;
\item The name of the definition in which the proof obligation is
  located;
\item The proof obligation category (type); and
\item A status field indicating whether the proof obligation is
  trivially correct or would have to be proved by a proof engine.
\end{itemize}

At the top of the \emph{Proof Obligation Explorer} the \emph{Filter proved} button
allows you to filter away all the proof obligations that are trivially
correct.\index{filter proved}

\chapter{Combinatorial Testing}\label{sec:testing}

In order to better automate the testing process, a notion of
test \emph{traces} has been introduced into VDM++ (and subsequently VDM-SL and VDM-RT)\footnote{Note that this is
only available for VDM-SL and VDM-RT models if the VDM-10 language version has been selected.}.
Traces are effectively regular expressions that can be expanded to a collection of test
cases. Each test case comprises a sequence of operation
calls. If a user defines a trace it is possible to make use of a
special \emph{Combinatorial Testing} perspective to automatically
expand the trace and execute all of the resulting test
cases. Subsequently, the results from the tests can be inspected
and erroneous test cases easily found. You can then fix
problems and re-run the trace to check they are fixed.

\section{Using the Combinatorial Testing GUI}

The syntax for trace definitions is defined in the VDM-10 Language
Manual.\index{traces}
If you have created a {\textbf\texttt{traces}} entry for a module or class it
can be executed via the \emph{Combinatorial Testing}
perspective\index{combinatorial testing}. See
Figure~\ref{fig:tracesalarm}.\index{perspective!combinatorial testing}

Different icons are used to indicate the verdict in a test
case. These are:
\begin{description}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/unknownWhiteBG.png}}:]
  This icon is used to indicate that the test case has not yet been
  executed.
\index{icon!not yet executed}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/okBigWhiteBG.png}}:]
  This icon is used to indicate that the test case has a pass
  verdict.\index{icon!pass verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/undeterminedBigWhiteBG.png}}:]
  This icon is used to indicate that the test case has an inconclusive
  verdict.\index{icon!inconclusive verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/faildBigWhiteBG.png}}:]
  This icon is used to indicate that the test case has a fail
  verdict.\index{icon!fail verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[height=10pt]{screenDumps/skippedIndication.png}}:]
If any test cases result in a run-time error, other test cases with the
same sequence of calls will be filtered and automatically skipped in the test
execution. The number of skipped test cases is indicated after the number
of test cases for the trace definition name.\index{icon!skipped test case}
\end{description}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{screenDumps/tracesalarm}
\caption{Using Combinatorial Testing\label{fig:tracesalarm}}
\end{center}
\end{figure}

In the CT Overview view, you can right-click on any individual
test case and then execute it with the interpreter (see
Figure~\ref{fig:SendToInterpreter}). This is particularly useful for
failed test cases since the interpreter allows you to step through the
evaluation to the place where it is failing. You can inspect the exact
circumstances of the failure, including the values of the different
variables in scope.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{screenDumps/SendToInterpreter}
\caption{Moving test case from Combinatorial Testing to Interpreter\label{fig:SendToInterpreter}}
\end{center}
\end{figure}

\chapter{Mapping VDM++ To and From UML}\label{sec:vdmuml}

VDM++ and VDM-RT projects can be converted automatically back and forth between VDM
and the corresponding UML model.
%\footnote{In the current version of
%Overture this feature is somewhat unstable.}.  Essentially, VDM and
UML can be considered as different views of the same model. A UML
model is typically used to give a graphical overview of the model
using class diagrams.  The VDM model is typically used to define the
implementation and constraints for each class and is therefore used
for detailed semantic analysis. Note that state charts, activity
diagrams, sequence diagrams, objects charts, package charts are not
used in the UML mapping. It is essentially only the information used
statically inside classes and their usage in class diagrams that is
used.

To convert a UML class diagram model to a VDM++ model, you first need to export the UML
model from Modelio to the Eclipse XMI\index{XMI} format, called UML using the EMF UML3.0.0 format
At the moment,
Modelio\index{Modelio} is the only UML tool
%Enterprise Architect\index{Exterprise Architect} is the only UML tool
supported. Export from Modelio is done as illustrated in Figure~\ref{fig:exportfromUML}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{screenDumps/xmiexportmodelio}
\caption{Exporting UML definitions from Modelio\label{fig:exportfromUML}}
\end{center}
\end{figure}

Importing and exporting a UML model is
an option in the Overture \emph{Explorer} view, where right-clicking
a VDM++ or VDM-RT project gives a submenu for
\emph{UML Transformation}\index{UML transformation}. From here
it is possible to 
\emph{Convert to UML}\index{Convert to UML}. If the mouse is placed over
a \texttt{.uml} file it is also possible to right-click and choose
the submenu for
\emph{UML Transformation}\index{UML transformation} and then select
\emph{Convert to VDM}\index{Convert to VDM}. 

The mapping rules between VDM++/VDM-RT and UML models are further explained 
in Appendix~\ref{chap:umlrules}. Note that the mapping depends on the settings
selected in the \emph{Preferences} menu (see Figure~\ref{fig:UMLpreferences} 
above). The general explanation of these options are:

\begin{description}
\item[Prefer associations during translation:] If this option is chosen 
(ticked) references to instances of other classes will be modelled as
associations between the classes in a class diagram. Otherwise these will be 
modelled as attributes.
\item[Disable nested artifacts in Deployment Diagrams:] If this option
is chosen (ticked) nested artifacts in a deployment diagram are disabled; 
otherwise it is enabled.
\end{description}

\chapter{Moving from VDM++ to VDM-RT}\label{sec:ToVDMRT}

The methodology for the development of distributed real-time
embedded systems in VDM defines a step where you
move from an initial VDM++ model to a VDM-RT model\cite{Larsen&09b}. This
step is supported by the Overture tool which will convert
a VDM++ project to create the starting point for a new VDM-RT
project. This is done by right-clicking on the VDM++ project to be
converted in the Explorer view, followed by
the \emph{Clone as VDM-RT} option\index{create real time
  project}. A new VDM-RT project is then automatically
created and it will initially be given the same name as the one generated from 
with postfix with ``\texttt{\_VDM\_RT}''. It will have the
same name as the original VDM++ project, but with \texttt{VDM\_RT} appended.
Inside the project, all the \texttt{.vdmpp} files will have been converted
to a \texttt{.vdmrt} extension. The original VDM++ project is not
changed at all. So this is simply a quick and easy way to get to the
starting point for a VDM-RT model. You would then manually create
a {\textbf\texttt{system}} class with appropriate declarations of
\texttt{CPU}s and \texttt{BUS}ses and proceed with the real time
model development.

\chapter{Analysing Logs from VDM-RT Executions}\label{sec:showlog}

Whenever a VDM-RT model is executed a binary logfile with \texttt{.rtbin} extension
is created in the \texttt{generated/logs} subfolder. In order to distinguish between multiple runs,
the name of the logfile indicates the time at which the model was executed. Logfiles can be
viewed with the built-in \emph{RealTime Log Viewer},\index{RealTime Log viewer}
by double-clicking the .rtbin file in the Explorer view. In addition, Overture provides
a textual version of the log file with \texttt{.rt} extension,
which can be inspected using any text editor.

The RealTime Log Viewer enables
you to explore the simulated system execution in various ways. In
Figure~\ref{fig:userguide:ArchitecturalOverview} the architectural
overview of a system is shown, describing the CPU and BUS topology of
the model.\index{architecture overview}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ArchitectureOverview}
  \caption{Architectural overview}
  \label{fig:userguide:ArchitecturalOverview}
\end{center}
\end{figure}

The RealTime Log Viewer also enables you to get an overview of
the model execution\index{model execution overview} at a system level --
see Figure~\ref{fig:userguide:ExecutionOverview}.
This view shows how the different CPUs\index{CPU} communicate via the
BUSes\index{BUS} of the system.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=6in]{figures/ExecutionOverview}
  \caption{Execution overview}
  \label{fig:userguide:ExecutionOverview}
\end{center}
\end{figure}

Since the complete execution of a model cannot generally be shown in a normal
sized window, you have the option of jumping to a certain time index
using the $
 \begin{array}{l}
\includegraphics{screenDumps/moveToIcon}
\end{array}
$ button or moving to the next time index using the $
\begin{array}{l}
\includegraphics{screenDumps/MoveNextIcon}
\end{array}
$ button .\index{Go to time} Also, Overture enables you to move to the previous
time index using the $
\begin{array}{l}
\includegraphics{screenDumps/MovePreviousIcon}
\end{array}
$ button. Finally, it is
also possible to export all the generated views to JPEG formatted files
using the $
\begin{array}{l}
\includegraphics{screenDumps/exportImagesIcon}
\end{array}
$ button.\index{export image button} All
the generated images will be placed in the logfile directory, where each image holds a name
indicating the time of execution and the specific view (Execution overview, CPU1, CPU2 etc.).

The RealTime Log Viewer also provides an overview of all executions on a single CPU.
Each CPU shows a detailed description of all operations and functions invoked
on the particular CPU as well as the scheduling of concurrent processes --- see
Figure~\ref{fig:userguide:ExecutionCPU}.\index{single CPU overview}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=5in]{figures/ExecutionCPU}
  \caption{Execution on a single CPU}
  \label{fig:userguide:ExecutionCPU}
\end{center}
\end{figure}

\subsection*{Analyzing timing properties at the system level}

The work of\cite{Fitzgerald&07b} presents an extension to VDM-RT, enabling the validation of system-level timing properties. \textit{Validation conjectures} are descriptions of temporal relations between system level events, which can be evaluated over the execution trace. Later this work has been extended in\cite{Ribeiro&11} to include run-time validation. Predefined standard forms of validation conjectures have been defined, directly supporting the validation of a deadline or separation between two events, called the \textit{trigger} and the \textit{response}. The trigger event could be the press of a button, and the corresponding response may be the update of a display. From the standard forms, more specific validation conjectures can be constructed.

In Overture it is possible to specify validation conjectures as comments in the \textbf{\texttt{system}} class. Listing~\ref{validationConjecture} provides an example of a validation conjecture requiring the separation of 500 ms between two subsequent screen updates.

\begin{lstlisting}[language=VDM++,label=validationConjecture,caption=Validation conjecture example,captionpos=b,escapechar=@]
@\textbf{system}@ Distribution

... // Class content omitted

/* timing invariants
separate(#fin(MMI`UpdateScreen), #fin(MMI`UpdateScreen), 500 ms);
*/

end Distribution
\end{lstlisting}

In Overture validation conjectures are evaluated over the execution trace at run-time and in case violations occur they will be written to a \textit{violations file} with \texttt{.txt} extension. The violations file is located in the log file directory and named by the time of execution. When this file is loaded using the $
\begin{array}{l}
\includegraphics{screenDumps/openViolationsFileIcon}
\end{array}
$ button, Overture will list the violations as shown in figure~\ref{fig:userguide:listedConjecturesViolated}. In particular, this figure shows two violations of the validation conjecture in listing~\ref{validationConjecture}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=6.5in]{screenDumps/listedConjecturesViolated}
  \caption{Violations of validation conjectures will be listed in a table}
  \label{fig:userguide:listedConjecturesViolated}
\end{center}
\end{figure}

In addition, the RealTime Log viewer will show the violations graphically by marking the trigger and corresponding response in the model execution overview. Figure~\ref{fig:userguide:markedConjecturesViolated} shows the two violations from figure~\ref{fig:userguide:listedConjecturesViolated}, where the response and trigger of the first and second violation, respectively, occur at the same point in time. This explains why only tree markers, i.e. the circles, are visible in the figure.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=5in]{screenDumps/markedConjecturesViolated}
  \caption{Violations of validation conjectures shown in the model execution overview}
  \label{fig:userguide:markedConjecturesViolated}
\end{center}
\end{figure}

\chapter{Expanding VDM Models Scope and Functionality by Linking Java and VDM} \label{sec:linkToJava}

In some cases the impact and value of VDM models can be immensely
improved by expanding them with functionality which is not delivered
directly by VDM. Examples of such functionality could be; (a) to
associate the model with existing legacy systems, for which no model
or specification exists, (b) to add a graphical representation of the
model, or (c) to enable network communication, for instance in a
client-server setup.  In order to achieve this functionality Overture
enables the possibility of linking a VDM model directly with the
underlying Java-based Overture interpreter. In addition it is possible
to link a
Java implementation with a VDM model.

Overture supplies two different techniques for linking between VDM and Java; (1) the functionality which allow VDM to interact with an ``External Java Library'' is described in Section~\ref{sec:javalibs} and (2) the method used to allow a Java implementation to ``Remote Control'' a VDM model is explained in Section~\ref{sec:remote}. An example of how these methods can be used to create a GUI for a model is supplied in Section~\ref{sec:gui}.

\section{Defining Your Own Java Libraries to be used from Overture}\label{sec:javalibs}

VDM models are not appropriate for describing everything. It is common
to have existing legacy code that you may not
wish to spend time modelling in VDM, but would like to make use of
from a VDM model. Overture has a feature to link a VDM
model with external Java libraries contained in a standard \texttt{jar} file
\footnote{In fact the \texttt{IO}, \texttt{MATH}, \texttt{Util},
  \texttt{CSV} and \texttt{VDM-Unit} libraries are implemented as such
external jar files.}.
Using this feature it is possible
to call functionality provided by jar files from a VDM model. This functionality
corresponds to DL modules/classes in VDMTools\cite{DLMan}.

External jar libraries are linked to VDM via
{\textbf\texttt{is not yet specified}} statements and expressions. Operations
or functions of modules or classes can be delegated to an external
jar, calling out to a Java class. The Java delegate, if present, has
the same name as the VDM
module/class name with underscores (``\_'') replaced with package naming
dots (``.''). For example, the VDM class \texttt{remote\_lib\_sensor} becomes
the class \texttt{remote.lib.sensor} in Java. The delegate lookup is only done once and
only when an  {\textbf\texttt{is not yet specified}} statement or expression is first
reached in a class or module. The jar with the external library must be placed in
the VDM project in a subfolder named \texttt{lib} where it will be put in the
class-path of the interpreter when it is executed.

\subsection{External Library Example}
In this example, a remote sensor will be defined in VDM which can read a
value from a real sensor. The VDM model interface of the sensor can be
seen in listing~\ref{remoteSensorVdm} and the Java class
implementing it can be seen in listing~\ref{remoteSensorJava}. The
values that are to be exchanged between the Overture IDE and the jar
file needs to be the internal \emph{Value} objects used in Overture. Documentation about
these classes can be found in Appendix~\ref{cha:VDMvalues}.

\begin{lstlisting}[language=VDM++,label=remoteSensorVdm,caption=Remote sensor VDM class,captionpos=b]
class remote_lib_sensor

operations

public getValue : int ==> int
getValue (id) == is not yet specified;

end remote_lib_sensor
\end{lstlisting}


\begin{lstlisting}[language=JAVA,label=remoteSensorJava,caption=Remote sensor Java class,captionpos=b]
package remote.lib;

import org.overture.interpreter.runtime.ValueException;
import org.overture.interpreter.values.IntegerValue;
import org.overture.interpreter.values.Value;

public class sensor
{
	public Value getValue(Value id) throws ValueException
	{
		int result = ... // Read a value for sensor number "id"
		return new IntegerValue(result);
	}
}
\end{lstlisting}
\newpage
\section{Enabling Remote Control of the Overture Interpreter}\label{sec:remote}\label{sec:Remote}

In some situations, it may be valuable to establish a
front end (for example a GUI or a test harness) for calling a VDM model.
This feature corresponds roughly to the CORBA based API from VDMTools\cite{APIMan}.

A VDM model can be remotely controlled by implementing the Java interface \texttt{RemoteControl}. Remote control should be understood as a delegation of control of the interpreter, which means that the remote controller is in charge of the execution or debug session and is responsible for taking action and executing parts of the VDM model when needed. When finished, it should return and the session will stop. When a Remote controller is used, the Overture debugger continues working normally, so for example breakpoints can be used in debug mode. A debugging session with the use of a remote controller can be started by placing the  jar with the RemoteControl implementation in a project subfolder called \texttt{lib}. The fully qualified name of the RemoteControl class must then be specified in the launch configuration in the \textit{Remote Control} box.

\subsection{Example of a Remote Control Class}
In this example, we have a VDM class \texttt{A} which defines an operation
that just returns its argument. As
seen in listing~\ref{remoteControllerJava}, it is possible to call
\texttt{execute} on the Overture interpreter via the RemoteInterpreter object
which is passed to the RemoteControl implementation via the \texttt{run} method.
The method returns a string with the result. A more
advanced \texttt{valueExecute} method is also available which returns the internal
Value type of the interpreter which is useful for more complex
results. The values exchanged between the Overture IDE and the
controller are the internal Values used in Overture. Documentation about these
can be found in the Overture Design Specification\cite{Battle10}.

\begin{lstlisting}[language=JAVA,label=remoteControllerJava,caption=Remote Controller Java class,captionpos=b]
import org.overture.interpreter.debug.RemoteControl;
import org.overture.interpreter.debug.RemoteInterpreter;

public class RemoteController implements RemoteControl
{
	public void run(RemoteInterpreter interpreter) throws Exception
	{
		System.out.println("Remote controller run");
		System.out.println("The answer is " +
			interpreter.execute("1 + 1"));
		System.out.println("The answer is " +
			interpreter.execute("new A().op(123)"));
		System.out.println("The answer is " +
			interpreter.execute("new A().op(1 + 3)"));
	}
}
\end{lstlisting}

\section{Using a GUI in a VDM model: Linking Example}\label{sec:gui}

This example describes how the linking functionality can be used to create a graphical representation of a VDM model.

\subsection{The Modelled System}
A GUI has been developed in Java Swing which will be used to both control and present the system which is described in the VDM model. In this example both the ``External Java Library'' technique as well as the ``Remote Controller'' technique is utilized. This is done to enable the VDM model to display data directly to the Java GUI, and to allow the VDM model to be controlled from the Java GUI.

The example is based on a VDM++ model of the smokers concurrency problem~\cite{Patil71}. Consider a scenario where three chain smokers and an agent, who does not smoke, are sitting at a table, infinitely going through the following lifecycle:
\begin{enumerate}
\item Each chain smoker continuously seeks to roll a cigarette and  smoke it,
\item a smoker needs three ingredients: tobacco, paper and matches,
\item each smoker has an infinite supply of only one of the ingredients.
One of the smokers has tobacco, the second has paper, and the third has
matches,
\item the agent has an infinite supply of all three materials and randomly places two different ingredients on the table at a time,
\item the smoker who has the remaining ingredient then empties the table, rolls a cigarette and smokes it. The smokers never accumulate the ingredients and never grab an ingredient from the table which they are already in possession of,
\item when the table becomes empty, the agent puts another two random ingredients on the table, and the
cycle repeats.
\end{enumerate}

In this example a GUI has been created for the model in which the user of the GUI is considered to be the agent providing the smoker with ingredients, as illustrated in Figure~\ref{fig:gui:SmokersGUI}.  By clicking one of three buttons one of the respective ingredients will be placed on the table. Once the necessary ingredients are on the table, one smoker will grab them and start smoking.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=\textwidth]{figures/smokersGUI}
  \caption[labelInTOC]{GUI of Smokers Example}
  \label{fig:gui:SmokersGUI}
\end{center}
\end{figure}

The architecture of the example is illustrated on Figure~\ref{fig:gui:SmokersExampleCD}, with a focus on the  linking functionality. The diagram shows central classes and relations, and it places the different classes into a GUI, a Java and a VDM/Overture block. In the given context the \textit{World} class represents the entire VDM model. In the diagram color highlights are used to distinguish the two linking techniques.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=\textwidth]{figures/SmokersExampleCD}
  \caption[labelInTOC]{Class diagram of the Smokers example architecture}
  \label{fig:gui:SmokersExampleCD}
\end{center}
\end{figure}

\subsection{External Java Library}
To allow the GUI to be a true graphical representation of the model, the model itself will be able to update the GUI whenever it needs to by using the ``External Java Library'' technique. If only the remote controller was used, the model would be unable to update the GUI and it would rely on the Java implementation to request data on any state changes in the model. 

A VDM model interface has been created which allows the model to interact with the Java GUI, the interface is shown in Listing~\ref{SmokersVDMInterface}. The hierarchical naming pattern of Java packages, which  normally are separated by periods (.), are denoted with underscores in the VDM model. Meaning that with this interface the External Java library must contain a  \textit{Graphics} class which is organized in the \textit{gui} package.

\begin{lstlisting}[language=VDM++,label=SmokersVDMInterface,caption=VDM interface for external Java library,captionpos=b]
class gui_Graphics
operations

    public init : () ==> ()
	init() == is not yet specified;

	public tobaccoAdded : () ==> ()
	tobaccoAdded() == is not yet specified;

	public paperAdded : () ==> ()
	paperAdded() == is not yet specified;

	public matchAdded : () ==> ()
	matchAdded() == is not yet specified;

	public tableCleared : () ==> ()
	tableCleared() == is not yet specified;

	public nowSmoking : nat ==> ()
	nowSmoking(smokerNumber) == is not yet specified;
end gui_Graphics
\end{lstlisting}

The Java class implementing the VDM interface is shown in Listing~\ref{SmokersVDMInterfaceJavaImpl}. This example will not go into detail with regards to actual GUI implementation, however it should be mentioned that the example utilizes the Model-View-Controller (MVC) design pattern and that the Java implementation of the VDM interface interacts with the graphical representation through the \textit{model} object (this is the \textit{model} in the MVC pattern and not a representation of the VDM model).

It should be noted that the names of the package and class can be directly related to VDM interface, i.e. \textit{gui} and \textit{Graphics}. Furthermore the imports should be noted; firstly the class must be marked as Serializable, secondly multiple packages from the Overture interpreter are imported as well. These are needed for the conversion between VDM values and Java values, as it can be seen in the \textit{nowSmoking} method in Listing~\ref{SmokersVDMInterfaceJavaImpl}. 

\emph{Please be aware that it is extremely important that there are no unused imports in the Java implementation, as this will result in an error when the Java library is loaded by Overture.} \\
\vspace{1in}
\begin{lstlisting}[language=Java,label=SmokersVDMInterfaceJavaImpl,caption=Java implementation of the VDM interface for the external Java library,captionpos=b]
package gui;

import java.io.Serializable;
import org.overture.interpreter.runtime.ValueException;
import org.overture.interpreter.values.Value;
import org.overture.interpreter.values.VoidValue;

public class Graphics implements Serializable {

    Controller ctrl;
    Model model;

    public Value init() {
    	ctrl = new Controller();  //init the Controller of the MVC pattern
    	model = ctrl.getModel();
        return new VoidValue();
    }

    public Value tobaccoAdded() {
        model.tobaccoAdded();
        return new VoidValue();
    }

  public Value nowSmoking(Value smokeid) throws ValueException {
	model.nowSmoking(smokeid.intValue(null)); //set smoker
	ctrl.DisableButtons(); 			  //prevent new GUI input
	model.finishedSmoking(); 		  //wait for smoker to finish
	ctrl.EnableButtons(); 			  //enable GUI input
    }
! \ldots !
}
\end{lstlisting}

In order to use the VDM Types the Java implementation must have the Overture java library in its build path. The library can be found in Overture installation directory:

 \textless  Overturedir\textgreater\textbackslash Plugins\textbackslash org.overture.ide.generated.vdmj:\_x.x\textbackslash lib,

\noindent which can then be added to the Java build path, as shown in Figure~\ref{fig:gui:VDMJBuildPath}.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=\textwidth]{figures/SmokersVDMJBuildPath}
  \caption[labelInTOC]{Adding VDMJ library to the build path in Eclipse}
  \label{fig:gui:VDMJBuildPath}
\end{center}
\end{figure}

\newpage
\subsection{Remote Control}
To enable the GUI to interact with the model the ``Remote Control'' technique is utilized, by implementing the \textit{RemoteControl} interface, as shown in Listing~\ref{SmokersRemoteControl}. The \textit{RemoteControl} interface also requires the Overture Java library to be included in the Java build path, as explained above. From listing~\ref{SmokersRemoteControl} it can be seen that the \textit{RemoteControl} interface supplies protected access to the VDM interpreter, that is passed to the \textit{SmokingControl} object which functions as the bridge between the GUI and the running VDM model. The \textit{SmokingControl} class is specific for this example, and its implementation could essentially be implemented directly in the \textit{RemoteControl} realization.

It is important the \textit{finish} method is called on the interpreter when the GUI is disposed, this will allow Overture to do a controlled shut-down of the remote interpretation, keeping the debugger alive for post execution communication such as coverage writing.

\begin{lstlisting}[language=Java,label=SmokersRemoteControl,caption=Java implementation of the RemoteControl interface, captionpos=b]
public class SmokerRemote implements RemoteControl {

  RemoteInterpreter interpreter;
  @Override
  public void run(RemoteInterpreter intrprtr) throws Exception {
	
    interpreter = intrprtr;
    SmokingControl ctrl = new SmokingControl(interpreter);
    ctrl.init();
   }
}
\end{lstlisting}

The implementation of the \textit{SmokingControl} is shown in Listing~\ref{SmokersSmokingControl}. In the \textit{init} method it can be seen how VDM statements are executed as strings commands, the \textit{World} class is created and the \textit{Run} operation is invoked.  This is the basic way of interacting with a model through the remote control functionality. The \texttt{finish} method informs the interpreter that the remote GUI is being disposed and that execution should be stopped. The \textit{AddPaper} method shows how the variables defined in the \textit{init} method can be used for invoking an operation. The \textit{AddPaper} method is called directly from the GUI Button click action, as shown in Listing~\ref{SmokersButtonClickAction}.

\begin{lstlisting}[language=Java,label=SmokersSmokingControl,caption=Java implementation of the bridge between the GUI and the interpreter executing the VDM model, captionpos=b]
public class SmokingControl {

  RemoteInterpreter interpreter;
  public SmokingControl(RemoteInterpreter intrprtr) {
    interpreter = intrprtr;
    Controller.smoke = this;
  }
  	
  public void init() {
    interpreter.create("w", "new World()");	
    interpreter.valueExecute("w.Run()");
  }

 public void AddPaper() {
    interpreter.valueExecute("w.agent.AddPaper()");
   }

public void finish(){
   interpreter.finish();
}
! \ldots !
}
\end{lstlisting}

\begin{lstlisting}[language=Java,label=SmokersButtonClickAction,caption=Java implementation of the Button click action invoking the remote intepreter, captionpos=b]
addPaperButton.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {	
    smoke.AddPaper();
  }
});	
\end{lstlisting}

The last thing to note in Listing~\ref{SmokersSmokingControl} is the constructor which adds itself to a public static field in the \textit{Controller} class. This step is necessary to brigde the objects created by the ``Remote Control'' technique with the objects created in connection with the ``External Java Library'' technique.
To understand why this construct is needed, some insight into the initialization steps is necessary. Firstly the entire VDM model, and thereby the \textit{Graphics} object, is created via the \textit{RemoteControl} interface by \textit{SmokingControl}. Now recall from Listing~\ref{SmokersVDMInterfaceJavaImpl} that the \textit{Controller} class, of the MVC pattern, is created when the \textit{init} method of the \textit{Graphics} class is invoked from the VDM model, meaning that the actual graphical Java components, are also created when \textit{init} is called. Now in order to connect a click on the GUI buttons with the commands that can be executed in the model, the \textit{Controller} needs to have access to the interpreter, i.e. the \textit{SmokingControl} object. Meanwhile the Graphics object is created deep inside the VDM model and the \textit{SmokingControl} object cannot be passed to it through the interpreters execute method. Instead the bridge between the \textit{Controller} and the \textit{SmokingControl} object is kept in Java, and the insider knowledge that the \textit{Controller} object will eventually be created from inside the model, is used  to justify the static reference. This is a special case when combining the ``Remote Control'' technique with the ``External Java Library'' method.

\subsubsection{Example of how to shut-down a JFrame when using the remote controller interface}
It is important that the execution of a remote GUI is stopped in a controlled manner e.g. not just by calling \texttt{System.exit(0)}. One way to allow the finish method to be called from a \texttt{JFrame} is shown in listing~\ref{RemoteControllerShutdown}; The in the constructor of the \texttt{JFrame} a the default close operation is changed to be \texttt{DISPOSE\_ON\_CLOSE}, this will change the closing of the window so that the \texttt{dispose} method is called where call to the interpreter finish can be placed.

\begin{lstlisting}[language=Java,label=RemoteControllerShutdown,caption=Java implementation of a \texttt{finish} method for a \texttt{JFrame}., captionpos=b]
public MyJFrame() {
// Allow Overture to do a controlled shutdown
setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
! \ldots !
}
! \ldots !
@Override
public void dispose(){
  interpreter.finish();
}
\end{lstlisting}

\subsection{Deployment of the Java Program to Overture}
Once the Java program has been implemented, it must be exported to a Jar file and placed in the lib directory in the Overture/VDM projects directory, in order for Overture to find it.
In Eclipse a Jar file can be created through the Export function, as illustrated on Figures~\ref{fig:gui:EclipseExport} and \ref{fig:gui:JarExport}.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=3in]{figures/SmokersExport}
  \caption[labelInTOC]{Exporting in Eclipse}
  \label{fig:gui:EclipseExport}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
  \includegraphics[width=3in]{figures/SmokersJarExport}
  \caption[labelInTOC]{Exporting to a Jar in Eclipse}
  \label{fig:gui:JarExport}
\end{center}
\end{figure}

Note that it can be very beneficial to check ``Save the description of this JAR '', illustrated on Figure~\ref{fig:gui:SaveExport}, as this saves the export configuration and makes it a lot faster to redeploy the JAR file to VDM project during development.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=3in]{figures/SmokersSaveExport}
  \caption[labelInTOC]{Saving the description of the export for future use}
  \label{fig:gui:SaveExport}
\end{center}
\end{figure}

Before running the model in Overture the debug configuration needs to be changed to use the Remote Control. ``The Launch Mode'' must be change to ``Remote Control'', and the fully qualified name of the class implementing the remote control interface must be supplied. The debug configuration for the current example is supplied in Figure~\ref{fig:gui:DebugConfiguration}.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=3.5in]{figures/SmokersDebugConfig}
  \caption[labelInTOC]{Changing the Overture debug configuration into using the remote controller}
  \label{fig:gui:DebugConfiguration}
\end{center}
\end{figure}



\chapter{A Command-Line Interface to Overture}\label{sec:commandline}

At the centre of the Overture tool there is a Java implementation of VDM
forming a core. This provides a command-line interface that may be valuable
as it can be used independently of the Eclipse interface of Overture.

\section{Starting Overture at the Command-Line}

The \texttt{Overture-2.0.0.jar} file contains a MANIFEST that identifies the main class to start the
tool, so the minimum command line invocation is as follows:

\lstset{style=tool,language=}
\begin{lstlisting}
$ !\textbf{java -jar Overture-2.0.0.jar}!
Overture: You must specify either -vdmsl, -vdmpp or -vdmrt
Usage: Overture <-vdmsl | -vdmpp | -vdmrt> [<options>] [<files>]
\end{lstlisting}
\lstset{style=mystyle}
\lstset{language=VDM++}

The first parameter indicates the VDM dialect to use and then
various extra options can be used. These are:

\begin{description}
\item[\texttt{-r}:] This indicates the VDM release number (classic or vdm10).
\item[\texttt{-w}:] This will suppress all warning messages.
\item[\texttt{-q}:] This will suppress all information messages, such as
 the number of source files processed etc.
\item[\texttt{-i}:] This will start the command line interpreter if the VDM
  model is successfully parsed and type checked, otherwise the errors discovered
  will be listed.
\item[\texttt{-p}:] This will generate all proof obligations for the
  VDM model (if it is syntax and type correct) and then stop.
\item[\texttt{-e <exp>}:] This will evaluate the \texttt{<exp>}, print
  the result, and stop.
\item[\texttt{-c <charset>}:] This will select a file character set, to
allow a specification written in languages other than the default for your system.
\item[\texttt{-t <charset>}:] This will select a console character set. The output
terminal can use a different character set to the specification files.
\item[\texttt{-o <filename>}:] This will save the internal
  representation of a parsed and type checked spe\-ci\-fication. Such files are
  effectively libraries, and can be can be re-loaded without the
  parsing/checking overhead. If files are sufficiently large, this may be faster.
\item[\texttt{-pre}:] This will disable all pre-condition checks.
\item[\texttt{-post}:] This will disable all post-condition checks.
\item[\texttt{-inv}:] This will disable type/state invariant checks.
\item[\texttt{-dtc}:] This will disable all dynamic type checking.
\item[\texttt{-measures}:] This will disable recursive measure checking.
\item[\texttt{-log}:] This will enable VDM-RT real-time event logging (see Chapter~\ref{sec:showlog}).
\item[\texttt{-remote}:] This enables remote control of the Overture executable.
\end{description}

Alternatively a script file is also made for the different platforms (script and bat files) wrapping this
so one does not need to set up paths and call java directly.

Normally, a VDM model will be loaded by identifying all of the VDM source files to include. At least
one source file must be specified unless the \texttt{-i} option is used, in which case the interpreter can be
started with no specification. If a directory is specified rather than a file, then Overture will load
all files in that directory with a suffix that matches the dialect (e.g.\ \texttt{*.vdmpp} files for VDM++).
Multiple files and directory arguments can be mixed.

If no \texttt{-i} option is given, the tool will only parse and type check
the VDM model files, giving any errors and warnings on
standard output, then stop.
%Warnings can be suppressed with the \texttt{-w}
%option. The \texttt{-q} option can be used to suppress the various
%information messages printed (this does not include errors and
%warnings).

The \texttt{-p} option will run the proof obligation generator and
then stop, assuming the specification has no type checking errors.

For batch execution, the \texttt{-e} option can be used to identify a
single expression to evaluate in the context of the loaded
specification, assuming the specification has no type checking errors.

%The \texttt{-c} and \texttt{-t} options allow the file and console character sets to be defined, respectively.

%The \texttt{-o} option allows a parsed and type checked specification to be saved to a file.
%The \texttt{-pre}, \texttt{-post}, \texttt{-inv} and \texttt{-dtc} options can be used to disable precondition, postcondition, invariant and
%dynamic type checking, respectively. By default, all these checks are performed.
%The \texttt{-log} option is for use with \texttt{-vdmrt}, and causes real-time events from the model to be written to the
%file name given.

%If flat.vdmsl contains a simple VDM-SL specification of the factorial
%function, called ``\texttt{fac}'', the following
%illustrate ways to test the specification, with user input shown in bold:

%\begin{lstlisting}
%functions
%fac: int -> int
%fac(a) == if a < 2 then 1 else a * fac(a-1)
%pre a > 0
%\end{lstlisting}
\lstset{style=tool,language=}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl flat.vdmsl}!
%Parsed 1 module in 0.202 secs. No syntax errors
%Warning 5012: Recursive function has no measure in (flat.vdmsl) at
%line 3:1
%Type checked 1 module in 0.016 secs. No type errors and 1 warning
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -q -w flat.vdmsl}!
%<quiet>
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -w -e "fac(10)" flat.vdmsl}!
%Parsed 1 module in 0.28 secs. No syntax errors
%Type checked 1 module in 0.031 secs. No type errors,
%suppressed 1 warning
%Initialized 1 module in 0.031 secs.
%3628800
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -e "fac(10)" -q -w flat.vdmsl}!
%3628800
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar overture-2.0.0.jar -vdmsl -i -w flat.vdmsl}!
%Parsed 1 module in 0.202 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors,
%suppressed 1 warning
%Initialized 1 module in 0.031 secs.
%Interpreter started
%> !\textbf{print fac(10)}!
%= 3628800
%Executed in 0.0 secs.
%> !\textbf{quit}!
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -p -w flat.vdmsl}!
%Parsed 1 module in 0.218 secs. No syntax errors
%Type checked 1 module in 0.015 secs. No type errors,
%suppressed 1 warning
%Generated 1 proof obligation:
%Proof Obligation 1:
%fac: function apply obligation in 'DEFAULT1' (flat.vdmsl) at
%line 4:38
%(forall a:int & (a > 0) =>
%(not (a < 2) =>
%pre_f((a - 1))))
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -w -e "fac(0)" -w flat.vdmsl}!
%Parsed 1 module in 0.203 secs. No syntax errors
%Type checked 1 module in 0.015 secs. No type errors,
%suppressed 1 warning
%Initialized 1 module in 0.016 secs.
%Execution: Error 4055: Precondition failure: pre_f in (flat.vdmsl)
%at line 5:11
%   a = 0
%   fac = (int -> int)
%   pre_fac = (int +> bool)
%In root context of fac(a) in 'DEFAULT1' (console) at line 1:1
%In root context of interpreter in 'DEFAULT1' (flat.vdmsl) at
%line 3:1
%In root context of global environment
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -w -pre -e "fac(0)"
%-w flat.vdmsl}!
%Parsed 1 module in 0.218 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors,
%suppressed 1 warning
%Initialized 1 module in 0.015 secs.
%1
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -w -o flat.lib flat.vdmsl}!
%Parsed 1 module in 0.203 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors,
%suppressed 1 warning
%Saved 1 module to flat.lib in 0.093 secs.
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl flat.lib -e "fac(10)"}!
%Loaded 1 module from flat.lib in 0.187 secs
%Initialized 1 module in 0.0 secs.
%3628800
%Bye
%\end{lstlisting}

\section{Parsing, Type Checking, and Proof Obligations Command-Line}

All specification files loaded are parsed and type checked
automatically by the command-line tool. There are no type checking options; the type checker
always uses \texttt{possible} semantics. If a specification does not parse
and type check cleanly, the interpreter cannot be started and proof
obligations cannot be generated (though warnings are allowed). All
warnings and error messages are printed on standard output, even
with the \texttt{-q} option.

A source file may contain VDM definitions embedded
in a \LaTeX\ file using \verb|vdm_al| environments (see
Chapter~\ref{sec:prettyprint}); the markup is ignored by the parser,
though reported line numbers will be correct. Note that each source file
must start with a recognizable \LaTeX\ construct:
a \verb+\documentclass, \section, \subsection+ or a \LaTeX\ comment.

The Overture Java process will return with an exit code of zero if the
specification is clean (ignoring warnings). Parser or type checking
errors result in an exit code of 1. The interpreter and PO generator
always exit with a code of zero.

\section{The Command-Line Interpreter and Debugger}\label{sec:commandlineinterpreter}

Assuming a specification does not contain any parse or type checking errors, the interpreter can be
started by using the \texttt{-i} command line option.
The interpreter is an interactive command line tool that allows expressions to be evaluated in the
context of the specification loaded. For example, to load and interpret a
VDM-SL specification from a single file called \texttt{shmem.vdmsl},
the following options would be used:

\begin{lstlisting}
$ !\textbf{java -jar Overture-2.0.0.jar -vdmsl -i shmem.vdmsl}!
Parsed 1 module in 0.14 secs. No syntax errors
Warning 5000: Definition 'i' not used in 'M' (shmem.vdmsl) 
  at line 129:7
Type checked in 0.078 secs. No type errors
Initialized 1 module in 0.046 secs.
Interpreter started
\end{lstlisting}

The interpreter prompt is ``\texttt{>}''. The
interactive interpreter commands are as follows (abbreviated forms are
permitted for some, shown in square brackets):
% (explanation below. The shmem.vdmsl source
%model is in Appendix A):

\begin{description}
\item[\texttt{modules}:] This command lists the loaded module names in
  a VDM-SL specification. For a flat VDM-SL model, the single name
  \texttt{DEFAULT} is used. The default module will be indicated in
  the list displayed.\index{modules}\index{command!modules}
\item[\texttt{classes}:] This command lists the loaded class names in
  VDM++ and VDM-RT specifications. The default class will be indicated in
  the list displayed.\index{classes}\index{command!classes}
\item[\texttt{default <module/class>}:] This command sets the default
  module/class name as the prime scope for which the lookup of
  identifiers appear (i.e.\ names in the default module
  do not need to be qualified, so you can say ``\texttt{print xyz}'' rather than
``\texttt{print M`xyz}'').\index{default}\index{command!default}
\item[\texttt{create <id> := <exp>}:] This command is only available
  for the VDM++ and VDM-RT dialects. It creates a global variable that
  can be used subsequently in the interpreter. It is mostly used for
  creating global instances of classes.\index{create}\index{command!create}
\item[\texttt{log [<file> | off]}:] This command can only be used with
  VDM-RT models. It starts to log real-time events to the file indicated. By
  default, event logging is turned off. Logging can be directed to
  the console by using log with no arguments, or to a file using \texttt{log
  <filename>}. Logging can subsequently be turned off again by using
  \texttt{log off}. The events logged include requests, activations and
  completions of all functions and operations, as well as all object creations,
  creation of CPUs and BUSses, deployment of objects
  to specific CPUs and the swapping in/out of threads.\index{log}\index{command!log}
\item[\texttt{state}:] This command can only be used for the VDM-SL
  dialect and shows the default module state.\index{state}\index{command!state}
  The value of the state can be changed by operations called.
\item[\texttt{[p]rint <expression>}:] This command evaluates the
  expression provided in the current context.\index{print}\index{command!print}
\item[\texttt{runtrace <name> [test number]}:] This command runs the trace called
  \texttt{<name>}. This will expand the combinatorial
  test and execute the resulting
  operation sequences. If a specific test number is provided, only
  that one test from the expansion will be executed. \index{combinatorial testing}
\item[\texttt{debugtrace <name> [test number]}:] This command is the same as
  \texttt{runtrace}, except that if a runtime exception is encountered during
  the execution of a test, control will enter the debugger. With \texttt{runtrace},
  runtime exceptions are recorded as the result of a (failed) test, rather than
  trapping into the debugger.\index{combinatorial testing}
\item[\texttt{filter \%age | <reduction type>}:] This command reduces
  the size of expanded CT traces to a given percentage (eg. 10\%).
  There are various options for making the actual selection of tests to remove:
  ``\texttt{RANDOM}'', ``\texttt{SHAPES\_NOVARS}'', ``\texttt{SHAPES\_VARNAMES}''
   or ``\texttt{SHAPES\_VARVALUES}'' (the names are not case sensitive).
\item[\texttt{assert <file>}:] This command runs assertions from the
  file provided. The assertions in the file must be Boolean
  expressions, one per line. The command evaluates every assertion in
  the file, raising an error for any which is false.\index{assert}\index{command!assert}
\item[\texttt{init}:] This command re-initializes the global
  environment. Thus all state components will be initialised to their
  initial value again, created variables are lost and code coverage information
  is reset.\index{init}\index{command!init}
\item[\texttt{env}:] This command lists the value of all global symbols
  in the default environment. This will show the signatures for all
  functions and operations as well as the values assigned to
  identifiers from value definitions and global state definitions (in VDM++
  terminology, public static instance variables). Note that this includes invariant,
  initialization and pre/postcondition functions. In the VDM++ and
  VDM-RT dialects, the identifiers created using the \texttt{create}
  command will also be included.\index{env}\index{command!env}
\item[\texttt{pog [<fn/op>]}:] This command generates a list of all proof
  obligations for the VDM model that is loaded. There is an optional argument
  to indicate one function or operation name.\index{pog}\index{command!pog}
\item[\texttt{break [<file>:]<line\#> [<condition>]}:] This command
  creates a breakpoint at a specific file and line and optionally makes
  it a conditional breakpoint.\index{break}\index{command!break}
\item[\texttt{break <function/operation> [<condition>]}:] This command
  creates a breakpoint at the start of the body of a named function or operation and
  optionally makes it a conditional breakpoint.
\item[\texttt{trace [<file>:]<line\#> [<exp>]}:] This command creates a
  tracepoint for a specific file and line. A tracepoint prints the value of the
  expression given whenever the tracepoint is reached, and then continues.
  \index{trace}\index{command!trace}
\item[\texttt{trace <function/operation> [<exp>]}:] This command
  create a tracepoint at the start of a function or operation body.
  See \texttt{trace} above for an explanation of tracepoints.
\item[\texttt{remove <breakpoint\#>}:] This command removes a
  trace/breakpoint by referring to its number (given by the
  \texttt{list} command).\index{remove}\index{command!remove}
\item[\texttt{list}:] This command provides a list of all current
  trace/breakpoints by number.\index{list}\index{command!list}
\item[\texttt{coverage [clear|write <dir>|merge <dir>|<filenames>]}:]
  This command manages test coverage information.
  The coverage command displays the source
  code of the loaded VDM model (by default, all source files are
  listed), with ``+'' and ``-'' signs in the left hand column
  indicating lines which have been executed or not. The percentage
  coverage of each source file
  is displayed.\index{coverage}\index{command!coverage} Typically, the
  testing of a specification will be incremental, and so it is
  convenient to be able to ``save'' the coverage achieved in each test
  session, and subsequently merge the results together. This can be
  achieved with the \texttt{write <dir>} and \texttt{merge <dir>} options to the
  coverage command. The write option saves the current coverage
  information in \texttt{<dir>} for each specification file loaded; the merge
  option reads this information back, and merges it with the current
  coverage information. For example, each day's test coverage could be
  written to a separate ``day'' directory, and then all the days merged
  together for review of the overall coverage at the end.
\item[\texttt{latex|latexdoc [<files>]}:] This command generates \LaTeX\
  coverage files. These are \LaTeX\ versions of the source files
  with parts of the
  specification highlighted where they have not been executed. The
  \LaTeX\ output also contains a table of percentage cover by
  module/class and the number of times functions and operations were
  hit during the execution. The \texttt{latexdoc} command is the same,
  except that output files are wrapped in \LaTeX\ document headers. The
  output files are written to the same directory as the source files, one
  per source file, with the extension \texttt{.tex}. Coverage
  information is reset when a specification is loaded, when an \texttt{init}
  command is given, or when the
  command \texttt{coverage clear} is executed, otherwise coverage is
  cumulative. If several files are loaded, the coverage for just one
  source file can be listed with \texttt{coverage <file>} or
  \texttt{latex <file>}. \index{latex}\index{command!latex}
  \index{latexdoc}\index{command!latexdoc}
\item[\texttt{files}:] This command lists the names of all source files loaded.
  \index{files}\index{command!files}
\item[\texttt{reload}:] This command will reload, parse and type check the
  VDM model files currently loaded. Note that if there are any errors
  in the parse or type check of the files, the interpreter will exit
  after the reload.\index{reload}\index{command!reload}
\item[\texttt{load <files>}:] This command replaces the current loaded VDM
  model files. Note that if there are any errors in the parse or type
  check of the files, the interpreter will exit after
  the load.\index{load}\index{command!load}
\item[\texttt{[q]uit}:] This command leaves the
  interpreter.\index{quit}\index{command!quit}
\end{description}

\begin{lstlisting}
> !\textbf{modules}!
M (default)
\end{lstlisting}

\begin{lstlisting}
> !\textbf{state}!
Q4 = [mk_M(<FREE>, 0, 9999)]
rseed = 87654321
Memory = mk_Memory(87654321, [mk_M(<FREE>, 0, 9999)],
                             [mk_M(<FREE>, 0, 9999)])
Q3 = [mk_M(<FREE>, 0, 9999)]
\end{lstlisting}

\begin{lstlisting}
> !\textbf{print rand(100)}!
= 71
Executed in 0.063 secs.
\end{lstlisting}

\begin{lstlisting}
> !\textbf{print rand(100)}!
= 44
Executed in 0.0 secs.
\end{lstlisting}

\begin{lstlisting}
> !\textbf{state}!
Q4 = [mk_M(<FREE>, 0, 9999)]
rseed = 566044643
Memory = mk_Memory(566044643, [mk_M(<FREE>, 0, 9999)],
                              [mk_M(<FREE>, 0, 9999)])
Q3 = [mk_M(<FREE>, 0, 9999)]
\end{lstlisting}

\begin{lstlisting}
> !\textbf{init}!
Global context initialized
\end{lstlisting}

\begin{lstlisting}
> !\textbf{state}!
Q4 = [mk_M(<FREE>, 0, 9999)]
rseed = 87654321
Memory = mk_Memory(87654321, [mk_M(<FREE>, 0, 9999)],
                             [mk_M(<FREE>, 0, 9999)])
Q3 = [mk_M(<FREE>, 0, 9999)]
\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 71
%Executed in 0.0 secs.
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 44
%Executed in 0.0 secs.
%\end{lstlisting}

\begin{lstlisting}
> !\textbf{env}!
fragments = (M`Quadrant -> nat)
combine = (M`Quadrant -> M`Quadrant)
tryBest = (nat ==> nat)
seed = (nat1 ==> ())
reset = (() ==> ())
bestfit = (nat1 * M`Quadrant -> nat1)
add = (nat1 * nat1 * M`Quadrant -> M`Quadrant)
firstFit = (nat1 ==> bool)
rand = (nat1 ==> nat1)
tryFirst = (nat ==> nat)
main = (nat1 * nat1 ==> seq of (<SAME> | <BEST> | <FIRST>))
MAXMEM = 10000
delete = (M`M * M`Quadrant -> M`Quadrant)
inv_M = (M`M +> bool)
CHUNK = 100
bestFit = (nat1 ==> bool)
least = (nat1 * nat1 -> nat1)
fits = (nat1 * M`Quadrant -> nat1)
init_Memory = (M`Memory +> bool)
pre_add = (nat1 * nat1 * M`Quadrant +> bool)
\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{pog}!
%Generated 36 proof obligations:
%Proof Obligation 1:
%M`fits: cases exhaustive obligation in 'M' (shmem.vdm) at
%line 40:5
%(forall size:nat1, Q:Quadrant &
%Q = [] or Q = [h] ^ tail)
%...
%Proof Obligation 35:
%M`tryBest: sequence apply obligation in 'M' (shmem.vdm) at
%line 176:27
%rand((len Q4)) in set inds Q4
%Proof Obligation 36:
%M`tryBest: subtype obligation in 'M' (shmem.vdm) at line 166:1
%RESULT >= 0
%\end{lstlisting}

This example shows a VDM-SL specification called \texttt{shmem.vdmsl} being
loaded. The help command lists the interpreter commands
available. Note that several of them regard the setting of
breakpoints, which is covered in the next section.

%The modules command lists the names of the modules loaded from the
%specification. In this example there is only one, called ``M''. One of
%the modules is identified as the default; names in the default module
%do not need to be qualified (so you can say print xyz rather than
%print M`xyz). The default module can be changed with the default
%command.

The {\textbf{\ttfamily state}} command lists the content of the default module's
state. This can be changed by operations, as can be seen by the two
calls to rand which change the rseed value in the state (a
pseudo-random number generator). The {\textbf\ttfamily init} command will re-initialize
the state to its original value, illustrated by the fact that two
subsequent calls to rand return the same results as the first two did.

The {\textbf\ttfamily print}\index{print} command can be used to
evaluate any expression.  The {\textbf\ttfamily env}\index{env} command
lists all the values in the global environment of the default
module. This shows the functions, operations and constant values
defined in the module. Note that it includes invariant, initialization
and pre/postcondition functions.  The {\textbf\ttfamily pog} command (proof obligation
generator) generates a list of proof obligations for the
specification.

%The assert command\index{assert} (illustrated below) can take a list of assertions
%from a file, and execute each of them in turn, raising an error for
%any assertion which is false. The assertions in the file must be
%simple boolean expressions, one per line:

When the execution of a VDM model is stopped at a
breakpoint, there are additional commands that can be used. These are:

\begin{description}
\item[\texttt{[s]tep}:] This command steps forward until the
  current expression/statement is on a new line. The command will step
  into function and operation calls.\index{step}\index{command!step}
\item[\texttt{[n]ext}:] This command is similar to \texttt{step} except
 function and operation calls are stepped over.\index{next}\index{command!next}
\item[\texttt{[o]ut}:] This command runs to the return of the current
  function or operation.\index{out}\index{command!out}
\item[\texttt{[c]ontinue}:] This command resumes execution and continues
  until the next breakpoint or completion of the thread that is being
  debugged.\index{continue}\index{command!continue}
\item[\texttt{stack}:] This command displays the current stack frame
  context (i.e.\ the call stack).\index{stack}\index{command!stack}
\item[\texttt{up}:] This command moves the stack frame context up one
  frame to allow variables to be seen.\index{up}\index{command!up}
\item[\texttt{down}:] This command moves the stack frame context down
  one frame.\index{down}\index{command!down}
\item[\texttt{source}:] This command lists VDM source around the
  current breakpoint. \index{source}\index{command!source}
\item[\texttt{stop}:] This command terminates the execution
  immediately.\index{stop}\index{command!stop}
\item[\texttt{threads}:] This command can only be used for the VDM++
  and VDM-RT dialects. It lists the active threads with status
  information for each thread.\index{threads}\index{command!threads}
\end{description}

\appendix
\newpage

\bibliographystyle{nnewalpha}

\bibliography{bib/UserGuide,dan}
\addcontentsline{toc}{section}{\protect\numberline{}{References}}

\newpage
\chapter{Templates in Overture}\label{app:templates}

Overture defines a number of standard Eclipse templates. You can add
your own as well. The keys and descriptions of the pre-defined templates
are:

\begin{longtable}{| l| p{9cm}| }\hline
Key & Description\\\hline
\endhead 
% ALL
caseExpression            & Case Expression\\
dclStatement              & Declare\\
defExpression             & def pattern = expression1 in expression2\\
exists                    & exists bindList \& predicate\\
forall                    & forall bind list \& predicate\\
forallLoop                & for identifier = expression1 to expression2 do statement\\
forallinset               & forall in set\\
functions                 & Function block\\
ifthen                    & if predicate then expression1 else expression2\\
let                       & let pattern = expression1 in expression2\\
operations                & Operation block\\
while                     & while predicate do statement\\

% VDM-SL
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
module                    & Module\\
moduleSkeleton            & Module Full skeleton of a module\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\

% VDM-PP
act                       & The number of times that operation name operation has been activated\\
active                    & The number of operation name operations that are currently active.\\
class                     & Class Definition\\
classSkeleton             & Class Definition full skeleton\\
fin                       & The number of times that the operation name operation has been completed\\
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
instancevariables         & Instance Variables block\\
isnotyetspecified         & is not yet specified\\
isofbaseclass             & Test if an object is of a specific base class\\
isofclass                 & Test if an object is of class\\
issubclassof              & Is subclass of\\
issubclassresponsibility  & Is subclass responsibility\\
mutex                     & Mutex operation\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\
per                       & Permission predicate for an operation, history counters can be used: \#fin, \#act, \#active, \#req, \#waiting\\
req                       & The number of requests that has been issued for the operation name operation\\
samebaseclass             & Test if two objects are of the same type\\
self                      & Get a reference to the current object\\
sync                      & Synchronization block\\
values                    & Values block\\
waiting                   & The number of outstanding requests for the operation name operation\\

% VDM-RT
act                       & The number of times that operation name operation has been activated\\
active                    & The number of operation name operations that are currently active.\\
bus                       & BUS (Priority $<$CSMACD$>$, capacity,set of connected CPUs)\\
class                     & Class Definition\\
classSkeleton             & Class Definition full skeleton\\
cpu                       & CPU (Priority $<$FP/FCFS$>$, capacity)\\
cycle                     & Cycles (number of cycles) statement\\
duration                  & Duration (time in nanoseconds) statement\\
fin                       & The number of times that the operation name operation has been completed\\
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
instancevariables         & Instance Variables block\\
isnotyetspecified         & is not yet specified\\
isofbaseclass             & Test if an object is of a specific base class\\
isofclass                 & Test if an object is of class\\
issubclassof              & Is subclass of\\
issubclassresponsibility  & Is subclass responsibility\\
mutex                     & Mutex operation\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\
per                       & Permission predicate for an operation, history counters can be used: \#fin, \#act, \#active, \#req, \#waiting\\
periodic                  & periodic(periode,jitter,delay,offset)(operation name)\\
req                       & The number of requests that has been issued for the operation name operation\\
samebaseclass             & Test if two objects are of the same type\\
self                      & Get a reference to the current object\\
sync                      & Synchronization block\\
system                    & System skeleton\\
time                      & Get the current time\\
values                    & Values block\\
waiting                   & The number of outstanding requests for the operation name operation\\\hline
\end{longtable}

\newpage
\chapter{Internal Errors}\label{app:internalerrors}

This appendix gives a list of the internal errors in Overture
and the circumstances under which each internal error can be expected.
Most of these errors should \emph{never} be seen, so if they appear
please report the occurrence via the Overture bug reporting utility
(\url{https://sourceforge.net/tracker/?group_id=141350&atid=749152}).

\input{MESSAGES_Internal}

\newpage
\chapter{Lexical Errors}\label{app:lexerr}

When a VDM model is parsed, the first phase is to gather the single
characters into tokens that can be used in the further
processing. This is called a lexical analysis and errors in this area
can be as follows:

\input{MESSAGES_Lexical}

\newpage
\chapter{Syntax Errors}\label{app:synerr}

If the syntax of the file you have provided does not meet the
syntax rules for the VDM dialect you wish to use, syntax errors will be
reported. These can be as follows:

\input{MESSAGES_Syntax}

\newpage
\chapter{Type Errors and Warnings}\label{app:typeerr}

If the syntax rules are satisfied, it is still possible to get
errors from the type checker. The errors can be as
follows:

\input{MESSAGES_TypeChecking}

Warnings from the type checker include:

\input{MESSAGES_Warnings}

\newpage
\chapter{Run-Time Errors}\label{app:runtimeerr}

When using the interpreter/debugger it is possible to get run-time
errors, even if there are no type checking errors. The possible errors
are as follows:

\input{MESSAGES_Runtime}

\newpage
\chapter{Categories of Proof Obligations}\label{app:POcategories}

This appendix provides a list of the different proof obligation
categories generated by Overture, and an explanantion of the
circumstances under which each category can be expected.

\begin{description}
\item[map apply:] Whenever a map application is made you need to be
  certain that the argument is in the domain of the map.
\item[function apply:] Whenever a function application is used you need to be
  certain that the list of arguments to the function satisfies the
  pre-condition of the function, assuming such a predicate is present.
\item[sequence apply:] Whenever a sequence application is used you need to be
  certain that the argument is within the indices of the sequence.
\item[post condition:]
\item[function satisfiability:] For all implicit function definitions
  this proof obligation will be generated to ensure that it is
  possible to find an implementation satisfying the post-conditions for all
  arguments satisfying the pre-conditions.
\item[function parameter patterns:]
\item[let be st existence:] Whenever a let-be-such-that
  expression/statement is used you need to be certain that at least one value
  will match the such-that expression.
\item[unique existence binding:] The \texttt{iota} expression
  requires one unique binding to be present and that is guranteed by
  proof obligations from this category.
\item[function iteration:]
\item[map iteration:]
\item[function compose:]
\item[map compose:]
\item[non-empty set:] This kind of proof obligation is used whenever
  non-empty sets are required.
\item[non-empty sequence:] This kind of proof obligation is used whenever
  non-empty sequences are required (eg. taking the head of a sequence)
\item[non-zero:] This kind of proof obligation is used whenever zero
  cannot be used (e.g.\ in division).
\item[finite map:] If a type binding to a type that potentially has
  infinitely many elements is used inside a map comprehension, this
  proof obligation will be generated because all mappings in VDM must be finite.
\item[finite set:] If a type binding to a type that potentially has
  infinitely many elements is used inside a set comprehension, this
  proof obligation will be generated because all sets in VDM must be finite.
\item[map compatible:] Mappings in VDM represent a unique relationship
  between the domain values and the corresponding range values. Proof
  obligations in this category are meant to ensure that such a unique
  relationship is guranteed.
\item[map sequence compatible:]
\item[map set compatible:]
\item[sequence modification:]
\item[tuple selection:] This proof obligation category is used
  whenever a tuple selection expression is used to
  gurantee that the length of the tuple is at least as long as the
  selector used.
\item[value binding:]
\item[subtype:] This proof obligation category is used whenever it is
  not possible to statically detect that the given value
  falls into the subtype required.
\item[cases exhaustive:] If a cases expression does not have an
  \texttt{others} clause it is necessary to ensure that the
  different case alternatives catch all values of the type of the
  expression used in the case choice.
\item[type invariant:] Proof obligations from this category are used
  to ensure that invariants for elements of a particular type are satisfied.
\item[recursive function:] This proof obligation makes use of the
  \texttt{measure} construct to ensure that a recursive function
  will terminate.
\item[state invariant:] If a state (including instance variables in
  VDM++) has an invariant, this proof obligation will be generated
  whenever an assignment is made to a part of the state.
\item[while loop termination:] This kind of proof obligation is a
  reminder to ensure that a while loop will terminate.
\item[operation post condition:] Whenever an explicit operation has a
  post-condition there is an implicit proof obligation generated to
  remind the user that you have to ensure that the explicit body
  of the operation satisfies the post-condition for all possible inputs.
\item[operation parameter patterns:]
\item[operation satifiability:] For all implicit operation definitions
  this proof obligation will be generated to ensure that it is
  possible to find an implementation satisfying the post-condition for all
  arguments satisfying the pre-conditions.
\end{description}

\newpage
\chapter{Mapping Rules between VDM++/VDM-RT and UML Models} \label{chap:umlrules}

\begin{formationRule}
\label{rule:transformationRuleClasses}
VDM classes are mapped as the UML meta-class \texttt{Class}
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleVisibility}
The visibility of VDM instance variables, values, functions and operations are mapped as a \textit{subset} of the UML enumeration \texttt{VisibilityKind} comprising \kw{public}, \kw{private} and \kw{protected}.
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleStatic}
VDM \kw{static} is mapped as the \texttt{isStatic} property of the UML meta-class \texttt{Class}, \texttt{Property} or \texttt{Operation} respectively.
\end{formationRule}

\begin{formationRule}
\label{rule:Datatypes}
Data type definitions are mapped as the UML meta-class \texttt{Class} and are referenced, and thus nested, through the meta-attribute \texttt{nestedClassifier} of the owning class.
Notice that this rule is not specified or implemented.
%, hence Figure \ref{fig:dataTypeNestedClass} is not generated by the tool made as part of this thesis.
\end{formationRule}

\begin{formationRule}
\label{rule:InstanceVarsAndValuesAsAssoc}
Instance variable and value definitions are mapped as the UML meta-class \texttt{Association}, if:
\begin{description}
\item \textbf{\ref{rule:InstanceVarsAndValuesAsAssoc} a:} The type is an \textit{object reference type}, or
\item \textbf{\ref{rule:InstanceVarsAndValuesAsAssoc} b:} The type is \textit{not} a basic \textit{data type} \cite[p64,71]{Fitzgerald&05}.
\end{description}%
\end{formationRule}

\begin{formationRule}
\label{rule:InstanceVarsAndValuesAsProp}
Instance variable and value definitions are mapped as the UML meta-class \texttt{Property} \cite[p48,p139]{UMLSuperstructure2.1.2}, if the type is a \textit{basic data type} \cite[p71]{Fitzgerald&05}. Instance variables and values are distinguished by the meta-attribute \texttt{isReadOnly}. Notice: rule 
%\ref{rule:transformationRuleConstraint} and 
\ref{rule:transformationRuleMap} is an exception to this rule.
\begin{center}
\begin{tabular}{|l|c|}
\hline
VDM concept & \texttt{Property::isReadOnly}\\
\hline
 Instance variables & \texttt{false}\\
 Values & \texttt{true}\\
\hline
\end{tabular}
\captionof{table}{The meta-attribute \texttt{isReadOnly} distinguishes instance variables and values}
\label{tab:instanceVariablesValuesTransRule}
\end{center}
\end{formationRule}

\begin{formationRule}
\label{rule:InstanceVarsAndValuesInitialValue}
The initial value of instance variables and values definitions are mapped as the property \texttt{default} of the UML meta-class \texttt{Property}.
\end{formationRule}

\begin{formationRule}
\label{rule:InstanceVarsAndValuesOptional}
The VDM optional type is mapped to the properties \texttt{lower = 0} and \texttt{upper = 1} of the UML meta-class.
\end{formationRule}
%
% \begin{formationRule}
%% \label{rule:transformationRuleConstraint}
%% A union type is mapped as the meta-class \texttt{Association} between the owning class and the types specified in the union type. The resulting associations are decorated with a textual constraint \texttt{\{xor\}}. The constraint is an instance of the meta-class \texttt{Constraint}.
%% Notice, that if a member of a union type is a \textit{basic type}, it is mapped as a separate UML class. This is an exception to rule \ref{rule:InstanceVarsAndValuesAsProp}
%% \end{formationRule}

%% \begin{formationRule}
%% \label{rule:transformationRuleProductType}
%% A VDM product type maps to:
%% \begin{description}

%% \item \textbf{\ref{rule:transformationRuleProductType} a:} The UML meta-class \texttt{Class} if it is declared as a data type. 
%See figure \ref{fig:PersonAssociationNWithTypeDeclared}.

%% \item \textbf{\ref{rule:transformationRuleProductType} b:} The UML meta-class \texttt{Association} if it is not defined as a type (i.e.\ it is anonymous). 
%See figure \ref{fig:PersonAssociationN} and \ref{fig:productType}.

%% \end{description}
%% Each association-end that represents an entry in the product type is named according to the product type. The types constituting the product type are sorted alphabetically according to the name of the types used in the product type.
%% \end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleSetSeqSeq1}
The VDM constructs \kw{set}, \kw{seq} and \kw{seq1} is mapped as the UML meta-class \texttt{Association} which may be decorated with a textual constraint defined by the meta-attribute \texttt{isOrdered\footnotemark} in addition to a multiplicity at both ends. Table \ref{tab:staticSetSeqSeq1TransRule} shows how the above-mentioned VDM constructs are mapped.\\

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
VDM construct & Ordered & Target class Multiplicity  \\
\hline
 \kw{set} & \texttt{false}  & \texttt{0..*}\\
 \kw{seq} & \texttt{true} & \texttt{0..*}\\
 \kw{seq1} & \texttt{true} & \texttt{1..*}\\
\hline
\end{tabular}

\captionof{table}{Transformation rules for VDM constructs modeling collections}

\label{tab:staticSetSeqSeq1TransRule}
\end{center}
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleMap}
The VDM constructs \kw{map} and \kw{inmap} are mapped as the UML meta-class \texttt{Association} with a qualifier. The domain is specified by the qualifier, which is located at the source class. The range is specified by the target class. 
Notice, that if the range is specified by a \textit{basic type} it is mapped as a separate class. This is an exception to rule \ref{rule:InstanceVarsAndValuesAsProp}.

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\multirow{2}{*}{VDM construct} & Qualifier end & Target class end \\
 & \texttt{isUnique} & \texttt{isUnique} \\
\hline
 \kw{map} & \texttt{false} & \texttt{true}\\
 \kw{inmap} &\texttt{true} & \texttt{true}\\
\hline
\end{tabular}
\captionof{table}{Transformation rules for VDM constructs modeling relationships between two sets.} 
%See figure \ref{fig:UniqueMapImap}}
\label{tab:qualifiedAssocTransRule}
\end{center}
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleThread}
A VDM class with a \kw{thread} compartment is mapped as the UML meta-class \texttt{Class} with the meta-attribute \texttt{isActive} set to \texttt{true}.
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleGeneralization}
A VDM class with the keyword \kw{is subclass of} followed by class-names is mapped as the UML meta-class \texttt{Generalization}, with the attributes \texttt{general} and \texttt{specific} referencing the superclass and subclass, respectively.
More than one subclass results in more than one instance of \texttt{Generalization}.
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleAbstract}
A VDM class with the keyword \kw{is subclass responsibility} as a function or operation body is mapped as the UML meta-class \texttt{Class} with the meta-attribute \texttt{isAbstract} set to \texttt{true}.
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleTemplate}
A VDM generic class maps to the UML meta-class \texttt{Class} with the attribute \texttt{templateSignature} referencing a set of \texttt{TemplateParameter} having the name property set to the name of the parameter.
\end{formationRule}

\begin{formationRule}
\label{rule:transformationRuleOperationFunction}
A VDM operation and function are mapped to the UML meta-class \texttt{Operation} where the property \texttt{isQuery} determine whether the \texttt{Operation} represents a VDM function or operation:
\begin{itemize}
    \item \kw{true} for a function.
	\item \kw{false} for a operation.
\end{itemize}
\\
The return type of a function and operation is mapped collectively as the property \texttt{type} and the multiplicity\footnotemark of the \texttt{Operation} meta-class.
The parameters of the operation or function is mapped to the UML meta-class \texttt{Parameter} represented as the property \texttt{ownedParameters} of the \texttt{Operation} meta-class.\\
The name and type of a VDM parameter are mapped to the property \texttt{name}, \texttt{type} and the multiplicity\footnotemark[\thefootnote] of the \texttt{Parameter} meta-class.
\end{formationRule}

\newpage
\chapter{Using VDM Values in Java}\label{cha:VDMvalues}

As described in Chapter~\ref{sec:linkToJava} integration between Overture and Java code can be established. Either by writing native libraries in Java that can be called from VDM, or by giving a Java program overall control of a VDM model by making calls to that model as a user interacts with a GUI.

In both cases, internal VDM values have to be handled by Java - either because they are passed as arguments to a Java library, and returned as results to VDM, or because they are returned from a VDM model evalution to a controlling Java program.

This appendix describes the internal class hierarchy used by Overture to represent internal VDM model values, and describes how a Java program can convert these to Java values (\kw{int}, \kw{long}, \kw{String} etc.) as well as creating internal values for returning to the VDM model (e.g.\ as the return value of library methods).

\section{The Value Class Hierarchy}

All internal VDM values in Overture are held by instances of the \texttt{Value} class with the fully qualified name, \url{org.overture.interpreter.values.Value}. The \texttt{Value} class itself is abstract, but subclasses can be instantiated to represent any VDM value, such as a ``\kw{seq of char}'', ``\kw{nat1}' or a value of an arbitrarily complex type. The hierarchy is shown in Figure~\ref{fig:gui:JavaVDMhierarchy}.

\begin{figure}[h]
\begin{center}
  \includegraphics[width=2.5in]{screenDumps/ValueHierarchy}
  \caption[labelInTOC]{Java Value Hierarchy}
  \label{fig:gui:JavaVDMhierarchy}
\end{center}
\end{figure}

Generally, the name of the \texttt{Value} subclass for a VDM type is on the form \texttt{<\textit{name}>Value}, for example \texttt{BooleanValue} or \texttt{SeqValue}.
 
The following sections describe how to obtain Java values from a \texttt{Value} object, and how to create \texttt{Value} objects from basic Java values (or iteratively from other values).

\section{Primitive Values}

Most primitive VDM types have subclasses with simple constructors that take a Java primitive type as an argument:

\begin{lstlisting}[language=JAVA]
public BooleanValue(boolean value)
public CharacterValue(char value)
public RealValue(double value) throws Exception
public RationalValue(double value) throws Exception
public IntegerValue(long value)
public NaturalValue(long value) throws Exception
public NaturalOneValue(long value) throws Exception
public QuoteValue(String value)
public NilValue()
\end{lstlisting}

The constructors that throw exceptions are the ones for which some Java value does not match the VDM type concerned. For example, a \texttt{RealValue} or \texttt{RationalValue} cannot take the Java values \texttt{Double.NaN} or \texttt{Double.POSITIVE\_INFINITY} as a constructor argument. Similarly, \texttt{NaturalValue} and \texttt{NaturalOneValue} cannot take a negative long as an argument.

Note that a \texttt{QuoteValue} is constructed with a string. This is simply the string value that would appear between angle brackets in VDM, for example \texttt{<FAIL>} would be constructed with the Java string \texttt{"FAIL"}.

To convert a VDM value into a Java value, the \texttt{Value} class provides a number of conversion methods, each of which returns the corresponding Java primitive value, or throws an exception if the conversion cannot be made for the VDM type concerned:

\begin{lstlisting}[language=JAVA]
public boolean boolValue(Context ctxt) throws ValueException
public char charValue(Context ctxt) throws ValueException
public double realValue(Context ctxt) throws ValueException
public double ratValue(Context ctxt) throws ValueException
public long intValue(Context ctxt) throws ValueException
public long natValue(Context ctxt) throws ValueException
public long nat1Value(Context ctxt) throws ValueException
public String quoteValue(Context ctxt) throws ValueException
\end{lstlisting}

Note that all of these conversion functions take a \texttt{Context} parameter as argument and potentially throw a \texttt{ValueException}. The \texttt{Context} parameter is used internally by Overture and represents the call stack during the evaluation of an expression. This parameter can be set to null when using these methods in Java code outside Overture. A \texttt{ValueException} is thrown if the VDM value cannot be converted into the Java type requested. For example, calling \texttt{booleanValue} on a \texttt{RealValue} object will raise a \texttt{ValueException} with the message text \texttt{"Can't get bool value of real"}.

\section{Sets, Sequences and Maps}

VDM allows primitive types to be built into more complex aggregations and collections, and these can also be converted to and from Java types, though the process is a little more involved. Three classes are provided to assist with this conversion: \texttt{ValueSet}, \texttt{ValueList} and \texttt{ValueMap} (all within the same  \url{org.overture.interpreter.values} package). These classes represent, respectively, a Java \texttt{Set}, \texttt{List} and \texttt{Map} of VDM values:

\begin{lstlisting}[language=JAVA]
public class ValueSet extends Vector<Value>
public class ValueList extends Vector<Value>
public class ValueMap extends LinkedHashMap<Value, Value>
\end{lstlisting}

Note that the \texttt{ValueSet} class is actually based on a Java \texttt{Vector}, not a Java \texttt{Set} type, though the class does have set semantics (no duplicates). This is an implementation detail and allows Overture to permute set orderings in certain circumstances.

These three classes have obvious constructors, and allow \texttt{Value}s (or collections of them) to be added to the collection subsequently, using standard Java collection methods:

\begin{lstlisting}[language=JAVA]
public ValueSet()
public ValueSet(int size)
public ValueSet(ValueSet from)
public ValueSet(Value v)

public ValueList()
public ValueList(ValueList from)
public ValueList(Value v)
public ValueList(int size)

public ValueMap()
public ValueMap(ValueMap from)
public ValueMap(Value k, Value v)
\end{lstlisting}

Using these three helper classes, it is now possible to create VDM set, sequence and map values, using constructors of the \texttt{SetValue}, \texttt{SeqValue} and \texttt{MapValue} classes:

\begin{lstlisting}[language=JAVA]
public SetValue()
public SetValue(ValueSet values)

public SeqValue()
public SeqValue(ValueList values)
public SeqValue(String s)

public MapValue()
public MapValue(ValueMap values)
\end{lstlisting}

Note that there is a special constructor for \texttt{SeqValue} that takes a Java string. This creates a VDM ``\kw{seq of char}'', but without the need to create a \texttt{ValueList} with \texttt{CharacterValue}s.

If the \texttt{ValueList} (or another) collection passed to these constructors contains a mixture of VDM types - i.e.\ a mixture of VDM \texttt{Value} subclasses, such as a \texttt{BooleanValue} and a \texttt{NaturalOneValue} - then the type of the constructed VDM value is the union of the various types passed, in this example ``\kw{seq of (bool} \texttt{$\mid$} \kw{nat1)}''. If this VDM type is not compatible with the use of a corresponding value in the VDM model a dynamic type exception occurs when the value is processed by the model.

Lastly, as before, to get the primitive Java values of a VDM collection, the following methods are provided:

\begin{lstlisting}[language=JAVA]
public ValueList seqValue(Context ctxt) throws ValueException
public String stringValue(Context ctxt) throws ValueException
public ValueSet setValue(Context ctxt) throws ValueException
public ValueMap mapValue(Context ctxt) throws ValueException
\end{lstlisting}

Note that, as with the \texttt{SeqValue} constructor, there is a special method to return a Java String from a ``\kw{seq of char}'' \texttt{SeqValue}, rather than a \texttt{ValueList} of \texttt{CharacterValue}s. As before, if the \texttt{Value} being used is not a sequence, set or map, then these methods will throw a \texttt{ValueException}.

\section{Other Types}

The sections above describe how to create or deconstruct simple VDM values in Java as well as simple collections of these. The remainder of this section describes the unusual cases, for more sophisticated types.

\section{Function values}

Overture has an internal \texttt{FunctionValue} class used for holding values of functions (e.g.\ the value of a ``{\textbf\ttfamily lambda}'' expression or the value of a function defined within a module). But as far as Java is concerned, these values are opaque - there is no equivalent Java construct, and the only way to evaluate a VDM function is to let Overture perform that evaluation. Similarly, Java cannot construct a \texttt{FunctionValue}.

The only operation that Java can reasonably perform with a \texttt{FunctionValue} is to create a composite function (eg. ``\texttt{f1 comp f2}'' in VDM) or a function iteration (e.g.\ ``\texttt{f ** 3}'' in VDM) using existing \texttt{FunctionValue}s. In order to do this, there are two subclasses of \texttt{FunctionValue}, called \texttt{CompFunctionValue} and \texttt{IterFunctionValue}, the constructors for which are as follows:

\begin{lstlisting}[language=JAVA]
public CompFunctionValue(FunctionValue f1, FunctionValue f2)
public IterFunctionValue(FunctionValue function, long count)
\end{lstlisting}

These both create new \texttt{FunctionValue}s, which when evaluated by Overture act as the composition and iteration of the arguments, respectively.

There is a method for obtaining a \texttt{FunctionValue} from a \texttt{Value}, but note that this is not an internal Java value (unlike other \texttt{Value} methods, like \texttt{realValue}). It is used as a more convenient way of casting the \texttt{Value} to a \texttt{FunctionValue}.

\begin{lstlisting}[language=JAVA]
public FunctionValue functionValue(Context ctxt)
\end{lstlisting}

\section{Object Values}

When VDM++ and VDM-RT create new objects using the ``\kw{new}'' operator, the resulting values are held as \texttt{ObjectValue}s in Overture. These are complex types that involve function and operation definitions for the object as well as any type, value, sync, thread or traces sections defined. Therefore \texttt{ObjectValue}s are really opaque to Java and cannot be used directly.

Like for \texttt{FunctionValue}, the \texttt{ObjectValue} class has a method for converting a \texttt{Value} into an \texttt{ObjectValue}:

\begin{lstlisting}[language=JAVA]
public ObjectValue objectValue(Context ctxt)
\end{lstlisting}

\section{Record Values}

A VDM record is just a collection of typed field values. A \texttt{RecordValue} can be obtained from a \texttt{Value} using the following method, which returns a \texttt{RecordValue} rather than some other Java representation:

\begin{lstlisting}[language=JAVA]
public RecordValue recordValue(Context ctxt)
\end{lstlisting}

To get individual field values from a \texttt{RecordValue}, two more Java helper types have to be introduced, called \texttt{FieldMap} and \texttt{FieldValue}. A \texttt{FieldValue} has the following constructor, and represents a record field:

\begin{lstlisting}[language=JAVA]
public FieldValue(String name, Value value, boolean comparable)
\end{lstlisting}

The \texttt{comparable} argument indicates whether this field is used in the value comparison between record values. A field declared with ``\texttt{-}'' in VDM would have a false argument, but normally this argument would be true, and the value must match the record type being used. \texttt{FieldValue}s are added to a \texttt{FieldMap}, which is just a Java \texttt{List} of \texttt{FieldValue}s.

So given a \texttt{RecordValue}, its \texttt{FieldMap} can be obtained from a public final field in the object, called \texttt{fieldMap}\footnote{Really this ought to have a get method.}, and from there, individual \texttt{FieldValue}s can be accessed - e.g.\ \texttt{fieldMap.get(0).name} and \texttt{fieldmap.get(0).value}.

To create a \texttt{RecordValue}, the record type is obtained from the \texttt{RemoteInterpreter}:

\begin{lstlisting}[language=JAVA]
type = remoteInterpreter.getInterpreter().findType(typename)
\end{lstlisting}

The type is then passed to the \texttt{RecordValue} constructor, along with a \texttt{FieldMap} or a \texttt{ValueList} (of the fields in order).

\begin{lstlisting}[language=JAVA]
public RecordValue(RecordType type,
		   ValueList values, 
		   Context ctxt)
public RecordValue(RecordType type, 
		   FieldMap mapvalues, 
		   Context ctxt)
\end{lstlisting}

The \texttt{Context} parameter is needed to allow records with invariants to check the invariant before the value is constructed. Note that currently, record types with an invariant cannot be constructed in Java. The \texttt{Context} parameter can be passed as null from Java.

The caller is responsible for passing field values that match their expected type. If they do not match, Overture throws a dynamic type exception for subsequent evaluations.

\section{Token Values}

Token values are simply wrappers for normal VDM values, reflecting the way they are created in VDM, like \texttt{mk\_token("hello")}, which would be a wrapper for a ``{\textbf\ttfamily seq of char}''. There is no special way of getting a \texttt{TokenValue} from a \texttt{Value}, other than casting it. Having casted the \texttt{Value}, the wrapped value can be obtained from the public final \texttt{Value} field called ``\texttt{value}''.

Constructing a \texttt{TokenValue} is just a matter of passing the \texttt{Value} required:

\begin{lstlisting}[language=JAVA]
public TokenValue(Value exp)
\end{lstlisting}

\section{Tuple Values}

A \texttt{TupleValue} in Overture is a wrapper for a \texttt{ValueList}. The following method and constructor can be used like one would expect:

\begin{lstlisting}[language=JAVA]
public TupleValue(ValueList argvals)
public ValueList tupleValue(Context ctxt)
\end{lstlisting}

\section{Invariant Values}

A VDM type can be given a name and an invariant, e.g.\ when wrapping a primitive type without an invariant. Overture has a separate \texttt{Value} subclass for values of such types that simply combine the primitive \texttt{Value} with a \texttt{FunctionValue} for the invariant. However, as with \texttt{RecordValue}s (which can also have invariants), it is not currently possible to create \texttt{InvariantValue}s in Java for types that have an invariant.

For types without an invariant, the constructor is as follows:

\begin{lstlisting}[language=JAVA]
public InvariantValue(NamedType type, Value value, Context ctxt)
\end{lstlisting}

The \texttt{NamedType} is obtained in a similar way to the \texttt{RecordType} above, using the \texttt{Remote\-Interpreter}. Note that the caller is responsible for passing a \texttt{Value} that matches the expected type. If they do not match, Overture will throw a dynamic type exception for subsequent evaluations.

\section{Void Values}

Operations which do not return a value in VDM (i.e.\ \texttt{==> ()}) return an instance of \texttt{VoidValue} in Java. The constructor has no arguments.

\addcontentsline{toc}{chapter}{Index}
\label{sec:index}
\printindex
\addcontentsline{toc}{section}{\protect\numberline{}{Index}}



\end{document}

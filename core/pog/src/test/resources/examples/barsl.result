["recursive function obligation:(forall s:seq of (Elem), b:Bag \u0026 ((not ([] \u003d s)) \u003d\u003e (exists [e] ^ rest:seq of (Elem) \u0026 ((([e] ^ rest) \u003d s) \u003d\u003e let [e] ^ rest \u003d s in (LenPar1(s, b) \u003e LenPar1(rest, Add(e, b)))))))","cases exhaustive obligation:(forall s:seq of (Elem), b:Bag \u0026 ((s \u003d []) or (exists [e] ^ rest:seq of (Elem) \u0026 (s \u003d ([e] ^ rest)))))","legal map application obligation:(forall e:Elem, b:Bag \u0026 ((e in set (dom b)) \u003d\u003e (e in set (dom b))))","legal map application obligation:(forall e:Elem, b:Bag \u0026 ((e in set (dom b)) \u003d\u003e (e in set (dom b))))","legal map application obligation:(forall e:Elem, b:Bag \u0026 ((e in set (dom b)) \u003d\u003e ((not (b(e) \u003d 1)) \u003d\u003e (e in set (dom b)))))","type compatibility obligation:(forall e:Elem, b:Bag \u0026 is_((if (e in set (dom b))\nthen (if (b(e) \u003d 1)\nthen ({e} \u003c-: b)\nelse (b ++ {e |-\u003e (b(e) - 1)}))\nelse b), map (Elem) to (nat1)))","legal map application obligation:(forall e:Elem, b:Bag \u0026 ((e in set (dom b)) \u003d\u003e (e in set (dom b))))","comprehension map injectivity obligation:(forall b1:Bag, b2:Bag \u0026 (forall m1, m2 in set {{e |-\u003e Max(Count(e, b1), Count(e, b2))} | e in set ((dom b1) union (dom b2))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall b1:Bag, b2:Bag \u0026 is_({e |-\u003e Max(Count(e, b1), Count(e, b2)) | e in set ((dom b1) union (dom b2))}, map (Elem) to (nat1)))","comprehension map injectivity obligation:(forall b1:Bag, b2:Bag \u0026 (forall m1, m2 in set {{e |-\u003e (Count(e, b1) + Count(e, b2))} | e in set ((dom b1) union (dom b2))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall b1:Bag, b2:Bag \u0026 is_({e |-\u003e (Count(e, b1) + Count(e, b2)) | e in set ((dom b1) union (dom b2))}, map (Elem) to (nat1)))","comprehension map injectivity obligation:(forall b1:Bag, b2:Bag \u0026 (forall m1, m2 in set {{e |-\u003e (Count(e, b1) - Count(e, b2))} | e in set (dom b1) \u0026 (Count(e, b1) \u003e Count(e, b2))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall b1:Bag, b2:Bag \u0026 is_({e |-\u003e (Count(e, b1) - Count(e, b2)) | e in set (dom b1) \u0026 (Count(e, b1) \u003e Count(e, b2))}, map (Elem) to (nat1)))","let be st existence obligation:(forall b:Bag \u0026 ((not (b \u003d {|-\u003e})) \u003d\u003e (exists e in set (dom b) \u0026 true)))","legal map application obligation:(forall b:Bag \u0026 ((not (b \u003d {|-\u003e})) \u003d\u003e (forall e in set (dom b) \u0026 (e in set (dom b)))))","recursive function obligation:(forall b:Bag \u0026 ((not (b \u003d {|-\u003e})) \u003d\u003e (forall e in set (dom b) \u0026 (CardDom(b) \u003e CardDom(({e} \u003c-: b))))))","comprehension map injectivity obligation:(forall b1:Bag, b2:Bag \u0026 (forall m1, m2 in set {{e |-\u003e Min(Count(e, b1), Count(e, b2))} | e in set ((dom b1) inter (dom b2))} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall b1:Bag, b2:Bag \u0026 is_({e |-\u003e Min(Count(e, b1), Count(e, b2)) | e in set ((dom b1) inter (dom b2))}, map (Elem) to (nat1)))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 5}, {\u003cD\u003e |-\u003e 4}, {\u003cE\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 5}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 4}, {\u003cD\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 2}, {\u003cB\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 5}, {\u003cD\u003e |-\u003e 4}, {\u003cE\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cC\u003e |-\u003e 5}, {\u003cD\u003e |-\u003e 4}, {\u003cE\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 2}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 4}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 9}, {\u003cD\u003e |-\u003e 4}, {\u003cE\u003e |-\u003e 1}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall supps:map (Supplier) to (Stock), s:Supplier, stock:Order, mk_(c, r):Pub \u0026 ((s in set (dom supps)) \u003d\u003e (s in set (dom supps))))","let be st existence obligation:(forall cl:CellarLevel, mk_(c, r):Pub, sb:map (Supplier) to (Stock) \u0026 ((not (sb \u003d {|-\u003e})) \u003d\u003e (exists s in set (dom sb) \u0026 true)))","legal map application obligation:(forall cl:CellarLevel, mk_(c, r):Pub, sb:map (Supplier) to (Stock) \u0026 ((not (sb \u003d {|-\u003e})) \u003d\u003e (forall s in set (dom sb) \u0026 let missing:Bag \u003d BAG`Difference(cl, c) in ((BAG`Size(missing) \u003e 0) \u003d\u003e (s in set (dom sb))))))","recursive function obligation:(forall cl:CellarLevel, mk_(c, r):Pub, sb:map (Supplier) to (Stock) \u0026 ((not (sb \u003d {|-\u003e})) \u003d\u003e (forall s in set (dom sb) \u0026 let missing:Bag \u003d BAG`Difference(cl, c) in ((BAG`Size(missing) \u003e 0) \u003d\u003e let can_restock:Bag \u003d BAG`Intersection(missing, sb(s)) in (CardCellar(cl, mk_(c, r), sb) \u003e CardCellar(cl, mk_(BAG`Union(c, can_restock), r), ({s} \u003c-: sb)))))))","let be st existence obligation:(forall supps:map (Supplier) to (Stock) \u0026 ((not ((dom supps) \u003d {})) \u003d\u003e (exists s in set (dom supps) \u0026 true)))","legal map application obligation:(forall supps:map (Supplier) to (Stock) \u0026 ((not ((dom supps) \u003d {})) \u003d\u003e (forall s in set (dom supps) \u0026 (s in set (dom supps)))))","recursive function obligation:(forall supps:map (Supplier) to (Stock) \u0026 ((not ((dom supps) \u003d {})) \u003d\u003e (forall s in set (dom supps) \u0026 (CardDom(supps) \u003e CardDom(({s} \u003c-: supps))))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 5}, {\u003cB\u003e |-\u003e 5}, {\u003cC\u003e |-\u003e 3}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 2}, {\u003cB\u003e |-\u003e 2}, {\u003cC\u003e |-\u003e 5}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 8}, {\u003cB\u003e |-\u003e 5}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cB\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 4}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 2}, {\u003cB\u003e |-\u003e 3}, {\u003cC\u003e |-\u003e 6}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cC\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cA\u003e |-\u003e 3}, {\u003cB\u003e |-\u003e 3}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cB\u003e |-\u003e 10}, {\u003cC\u003e |-\u003e 2}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cB\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 10}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\"Fizz\" |-\u003e {\u003cA\u003e |-\u003e 10}}, {\"Real\" |-\u003e {\u003cB\u003e |-\u003e 10, \u003cC\u003e |-\u003e 2}}, {\"Scrumpy\" |-\u003e {\u003cB\u003e |-\u003e 1, \u003cC\u003e |-\u003e 10}}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cB\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 5}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\u003cB\u003e |-\u003e 1}, {\u003cC\u003e |-\u003e 10}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation:(forall m1, m2 in set {{\"Fizz\" |-\u003e {\u003cA\u003e |-\u003e 10}}, {\"Real\" |-\u003e {\u003cB\u003e |-\u003e 1, \u003cC\u003e |-\u003e 5}}, {\"Scrumpy\" |-\u003e {\u003cB\u003e |-\u003e 1, \u003cC\u003e |-\u003e 10}}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))"]
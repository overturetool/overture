["legal map application obligation:(forall mk_System(accs, -, curCard, cardOk, -):System \u0026 (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (id1 in set (dom accs))))))","legal map application obligation:(forall mk_System(accs, -, curCard, cardOk, -):System \u0026 (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (id2 in set (dom accs))))))","state invariant satisfiable obligation:(exists accounts:map (AccountId) to (Account), illegalCards:set of (CardId), curCard:[Card], cardOk:bool, retainedCards:set of (Card) \u0026 (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {})))))","type invariant satisfiable obligation:(exists account:Account \u0026 TransactionsInvariant((account.transactions)))","legal sequence application obligation:(forall ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (((ts(i).date) \u003d date) \u003d\u003e (i in set (inds ts)))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","type compatibility obligation:(forall date:Date, ts:seq of (Transaction) \u0026 is_(Sum([(ts(i).amount) | i in set (inds ts) \u0026 ((ts(i).date) \u003d date)]), nat))","state invariant holds obligation:(forall c:Card, oldstate:System \u0026 ((curCard \u003d nil) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","type compatibility obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e is_(curCard, Card)))","state invariant holds obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","type compatibility obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e is_((retainedCards union {curCard}), set of (Card))))","state invariant holds obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","state invariant holds obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","state invariant holds obligation:(forall pin:PinCode, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (not cardOk)) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","state invariant holds obligation:((curCard \u003c\u003e nil) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {})))))","state invariant holds obligation:((curCard \u003c\u003e nil) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {})))))","type compatibility obligation:(((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e ((curCard \u003c\u003e nil) \u003d\u003e (cardOk \u003d\u003e is_(curCard, Card))))","legal map application obligation:(((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e ((curCard.accountId) in set (dom accounts)))","type compatibility obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e ((curCard \u003c\u003e nil) \u003d\u003e (cardOk \u003d\u003e is_(curCard, Card)))))","legal map application obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (accountId in set (dom accounts))))","legal map application obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e ((((accounts(accountId).balance) - amount) \u003e\u003d 0) \u003d\u003e (accountId in set (dom accounts)))))","state invariant holds obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","legal map application obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (accountId in set (dom accounts))))","type compatibility obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (((accounts(accountId).balance) - amount) \u003e\u003d 0)))","state invariant holds obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","legal map application obligation:(forall amount:nat, date:Date, oldstate:System \u0026 (((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (accountId in set (dom accounts))))","type compatibility obligation:(((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e ((curCard \u003c\u003e nil) \u003d\u003e (cardOk \u003d\u003e is_(curCard, Card))))","legal map application obligation:(((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (accountId in set (dom accounts)))","legal map application obligation:(((curCard \u003c\u003e nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts))) \u003d\u003e (cardId in set (dom cards)))","legal map application obligation:(forall mk_Card(-, cardId, accountId):Card, pillegalcards:set of (CardId), paccounts:map (AccountId) to (Account) \u0026 ((cardId not in set pillegalcards) \u003d\u003e ((accountId in set (dom paccounts)) \u003d\u003e (accountId in set (dom paccounts)))))","state invariant holds obligation:(forall cardId:CardId, oldstate:System \u0026 let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {})))))","state invariant holds obligation:(forall accountId:AccountId, account:Account, oldstate:System \u0026 ((accountId not in set (dom accounts)) \u003d\u003e let mk_System(accs, -, curCard, cardOk, -) \u003d System in (((curCard \u003d nil) \u003d\u003e (not cardOk)) and (forall id1, id2 in set (dom accs) \u0026 ((id1 \u003c\u003e id2) \u003d\u003e (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) \u003d {}))))))","map compatible obligation:(forall accountId:AccountId, account:Account, oldstate:System \u0026 ((accountId not in set (dom accounts)) \u003d\u003e (forall ldom1 in set (dom accounts), rdom2 in set (dom {accountId |-\u003e account}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (accounts(ldom1) \u003d {accountId |-\u003e account}(rdom2))))))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))","recursive function obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (Len(rs) \u003e Len((tl rs)))))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))"]
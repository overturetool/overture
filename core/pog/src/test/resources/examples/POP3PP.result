["type compatibility obligation:((is_(RESULT, ClientCommand) and ((is_(RESULT, OptionalClientCommand) and ((((is_(RESULT, APOP) or is_(RESULT, PASS)) or is_(RESULT, TOP)) or is_(RESULT, UIDL)) or is_(RESULT, USER))) or (is_(RESULT, StandardClientCommand) and ((((((is_(RESULT, DELE) or is_(RESULT, LIST)) or is_(RESULT, NOOP)) or is_(RESULT, QUIT)) or is_(RESULT, RETR)) or is_(RESULT, RSET)) or is_(RESULT, STAT))))) or (is_(RESULT, ServerResponse) and (is_(RESULT, ErrResponse) or is_(RESULT, OkResponse))))","type compatibility obligation:(is_(RESULT, ErrResponse) or is_(RESULT, OkResponse))","type compatibility obligation:((is_(RESULT, OptionalClientCommand) and ((((is_(RESULT, APOP) or is_(RESULT, PASS)) or is_(RESULT, TOP)) or is_(RESULT, UIDL)) or is_(RESULT, USER))) or (is_(RESULT, StandardClientCommand) and ((((((is_(RESULT, DELE) or is_(RESULT, LIST)) or is_(RESULT, NOOP)) or is_(RESULT, QUIT)) or is_(RESULT, RETR)) or is_(RESULT, RSET)) or is_(RESULT, STAT))))","type compatibility obligation:is_(RESULT, MessageChannel)","comprehension map injectivity obligation:(forall m1, m2 in set {{users(i) |-\u003e passwords(i)} | i in set (inds users)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal sequence application obligation:(forall i in set (inds users) \u0026 (i in set (inds users)))","legal sequence application obligation:(forall i in set (inds users) \u0026 (i in set (inds passwords)))","comprehension map injectivity obligation:(forall m1, m2 in set {{users(i) |-\u003e mk_POP3Server`MailBox(MakeMessages(users(i)), false)} | i in set (inds users)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal sequence application obligation:(forall i in set (inds users) \u0026 (i in set (inds users)))","legal sequence application obligation:(forall i in set (inds users) \u0026 (i in set (inds users)))","legal sequence application obligation:(forall user:UserName \u0026 (forall i in set (inds headers) \u0026 (i in set (inds headers))))","legal sequence application obligation:(forall user:UserName \u0026 (forall i in set (inds headers) \u0026 (i in set (inds bodies))))","legal sequence application obligation:(1 in set (inds users))","legal sequence application obligation:(1 in set (inds passwords))","legal function application obligation:(forall cmd:ClientCommand \u0026 pre_(((io.writeval))[ClientCommand]cmd))","legal function application obligation:(forall resp:ServerResponse \u0026 pre_(((io.writeval))[ServerResponse]resp))","cases exhaustive obligation:(forall c:ClientCommand \u0026 (((((((((((c \u003d mk_QUIT()) or (c \u003d mk_STAT())) or (exists mk_LIST(-):ClientCommand \u0026 (c \u003d mk_LIST(any1)))) or (exists mk_RETR(-):ClientCommand \u0026 (c \u003d mk_RETR(any2)))) or (exists mk_DELE(-):ClientCommand \u0026 (c \u003d mk_DELE(any3)))) or (c \u003d mk_NOOP())) or (c \u003d mk_RSET())) or (exists mk_TOP(-, -):ClientCommand \u0026 (c \u003d mk_TOP(any4, any5)))) or (exists mk_UIDL(-):ClientCommand \u0026 (c \u003d mk_UIDL(any6)))) or (exists mk_USER(-):ClientCommand \u0026 (c \u003d mk_USER(any7)))) or (exists mk_PASS(-):ClientCommand \u0026 (c \u003d mk_PASS(any8)))))","let be st existence obligation:(forall s:set of (@tp) \u0026 ((not (s \u003d {})) \u003d\u003e (exists v in set s \u0026 true)))","legal sequence application obligation:(forall msgs:set of (MessageInfo) \u0026 let msgSeq:seq of (MessageInfo) \u003d (set2seq)[MessageInfo](msgs) in (forall i in set (inds msgSeq) \u0026 (i in set (inds msgSeq))))","legal sequence application obligation:(forall msgs:set of (MessageInfo) \u0026 let msgSeq:seq of (MessageInfo) \u003d (set2seq)[MessageInfo](msgs) in (forall i in set (inds msgSeq) \u0026 (i in set (inds msgSeq))))","non-empty sequence obligation:(forall resps:seq of (seq of (char)) \u0026 ((not (resps \u003d [])) \u003d\u003e (((len resps) \u003d 1) \u003d\u003e (resps \u003c\u003e []))))","non-empty sequence obligation:(forall resps:seq of (seq of (char)) \u0026 ((not (resps \u003d [])) \u003d\u003e ((not ((len resps) \u003d 1)) \u003d\u003e (resps \u003c\u003e []))))","recursive function obligation:(forall resps:seq of (seq of (char)) \u0026 ((not (resps \u003d [])) \u003d\u003e ((not ((len resps) \u003d 1)) \u003d\u003e (Len(resps) \u003e Len((tl resps))))))","non-empty sequence obligation:(forall resps:seq of (seq of (char)) \u0026 ((not (resps \u003d [])) \u003d\u003e ((not ((len resps) \u003d 1)) \u003d\u003e (resps \u003c\u003e []))))","recursive function obligation:(forall text:seq of (char) \u0026 ((not (text \u003d [])) \u003d\u003e let mk_(line, rest):(seq of (char) * seq of (char)) \u003d GetLine(text) in (Len(text) \u003e Len(rest))))","non-empty sequence obligation:(forall text:seq of (char) \u0026 ((not (text \u003d [])) \u003d\u003e (((hd text) \u003d \u0027\n\u0027) \u003d\u003e (text \u003c\u003e []))))","recursive function obligation:(forall text:seq of (char) \u0026 ((not (text \u003d [])) \u003d\u003e ((not ((hd text) \u003d \u0027\n\u0027)) \u003d\u003e (Len(text) \u003e Len((tl text))))))","non-empty sequence obligation:(forall text:seq of (char) \u0026 ((not (text \u003d [])) \u003d\u003e ((not ((hd text) \u003d \u0027\n\u0027)) \u003d\u003e (text \u003c\u003e []))))","non-empty sequence obligation:(forall text:seq of (char) \u0026 ((not (text \u003d [])) \u003d\u003e ((not ((hd text) \u003d \u0027\n\u0027)) \u003d\u003e let mk_(line, rest):(seq of (char) * seq of (char)) \u003d GetLine((tl text)) in (text \u003c\u003e []))))","let be st existence obligation:(forall s:set of (nat) \u0026 ((not (s \u003d {})) \u003d\u003e (exists e in set s \u0026 true)))","recursive function obligation:(forall s:set of (nat) \u0026 ((not (s \u003d {})) \u003d\u003e (forall e in set s \u0026 (Card(s) \u003e Card((s \\ {e}))))))","recursive function obligation:(forall i:int \u0026 ((not (i \u003d 0)) \u003d\u003e ((i \u003c 0) \u003d\u003e (Abs(i) \u003e Abs(-i)))))","type compatibility obligation:(forall i:int \u0026 ((not (i \u003d 0)) \u003d\u003e ((not (i \u003c 0)) \u003d\u003e (i \u003e\u003d 0))))","type compatibility obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e let first:int \u003d (n div 10), last:int \u003d (n mod 10) in (first \u003e\u003d 0)))","recursive function obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e let first:int \u003d (n div 10), last:int \u003d (n mod 10) in (Id(n) \u003e Id(first))))","cases exhaustive obligation:(forall n:nat \u0026 ((not (n \u003d 0)) \u003d\u003e let first:int \u003d (n div 10), last:int \u003d (n mod 10) in ((((((((((last \u003d 0) or (last \u003d 1)) or (last \u003d 2)) or (last \u003d 3)) or (last \u003d 4)) or (last \u003d 5)) or (last \u003d 6)) or (last \u003d 7)) or (last \u003d 8)) or (last \u003d 9))))","state invariant holds obligation:(forall nmd:MailDrop, nch:MessageChannelBuffer, npasswords:map (UserName) to (Password) \u0026 (((dom npasswords) \u003d (dom nmd)) and ((rng {|-\u003e}) subset (dom nmd))))","legal map application obligation:(forall user:UserName, password:Password \u0026 ((user in set (dom passwords)) \u003d\u003e (user in set (dom passwords))))","state invariant holds obligation:(forall user:UserName, newMsgs:seq of (POP3Message) \u0026 ((((dom passwords) \u003d (dom maildrop)) and ((rng locks) subset (dom maildrop))) \u003d\u003e (((dom passwords) \u003d (dom maildrop)) and ((rng locks) subset (dom maildrop)))))","legal map application obligation:(forall user:UserName, newMsgs:seq of (POP3Message) \u0026 (user in set (dom maildrop)))","legal map application obligation:(forall user:UserName \u0026 (user in set (dom maildrop)))","legal sequence application obligation:(forall user:UserName \u0026 (forall i in set (inds oldMsgs) \u0026 ((not (oldMsgs(i).IsDeleted)()) \u003d\u003e (i in set (inds oldMsgs)))))","legal sequence application obligation:(forall user:UserName \u0026 (forall i in set (inds oldMsgs) \u0026 (i in set (inds oldMsgs))))","state invariant holds obligation:(forall clId:ClientHandlerId, user:UserName \u0026 (((clId not in set (dom locks)) and (user in set (dom maildrop))) \u003d\u003e ((((dom passwords) \u003d (dom maildrop)) and ((rng locks) subset (dom maildrop))) \u003d\u003e (((dom passwords) \u003d (dom maildrop)) and ((rng (locks ++ {clId |-\u003e user})) subset (dom maildrop))))))","state invariant holds obligation:(forall clId:ClientHandlerId \u0026 ((clId in set (dom locks)) \u003d\u003e ((((dom passwords) \u003d (dom maildrop)) and ((rng locks) subset (dom maildrop))) \u003d\u003e (((dom passwords) \u003d (dom maildrop)) and ((rng ({clId} \u003c-: locks)) subset (dom maildrop))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))","legal map application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e (user in set (dom maildrop)))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e (index in set (inds GetUserMessages(user)))))","sequence modification obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((dom {index |-\u003e newMsg}) subset (inds GetUserMessages(user)))))","legal map application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e (user in set (dom maildrop)))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e (index in set (inds mb))))","legal map application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e (user in set (dom maildrop)))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e (index in set (inds mb))))","legal sequence application obligation:(forall user:UserName \u0026 ((user in set (dom maildrop)) \u003d\u003e (forall i in set (inds oldMsgs) \u0026 (i in set (inds oldMsgs)))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d GetUserMessages(user) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e let mb:seq of (POP3Message) \u003d GetUserMessages(user) in ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d GetUserMessages(user) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e (index in set (inds GetUserMessages(user)))))","legal map application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e (user in set (dom maildrop)))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e ((user in set (dom maildrop)) \u003d\u003e let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) \u003d\u003e (index in set (inds mb))))))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (((user in set (dom maildrop)) and let mb:seq of (POP3Message) \u003d (maildrop(user).msgs) in ((index in set (inds mb)) and (not (mb(index).IsDeleted)()))) \u003d\u003e (index in set (inds GetUserMessages(user)))))","legal map application obligation:(forall user:UserName, index:[nat] \u0026 (((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)()))) \u003d\u003e ((index \u003c\u003e nil) \u003d\u003e (user in set (dom maildrop)))))","legal sequence application obligation:(forall user:UserName, index:[nat] \u0026 (((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)()))) \u003d\u003e ((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) \u003d\u003e (index in set (inds (maildrop(user).msgs)))))))","legal map application obligation:(forall user:UserName, index:[nat] \u0026 (((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)()))) \u003d\u003e ((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) \u003d\u003e (user in set (dom maildrop))))))","legal sequence application obligation:(forall user:UserName, index:[nat] \u0026 (((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)()))) \u003d\u003e (forall i in set (inds mb) \u0026 (i in set (inds mb)))))","type compatibility obligation:(forall user:UserName, index:[nat] \u0026 (((index \u003c\u003e nil) \u003d\u003e ((index in set (inds (maildrop(user).msgs))) and (not ((maildrop(user).msgs)(index).IsDeleted)()))) \u003d\u003e is_(index, nat)))","legal sequence application obligation:(forall user:UserName, index:nat \u0026 (index in set (inds mb)))","legal sequence application obligation:(forall user:UserName \u0026 ((user in set (dom maildrop)) \u003d\u003e (forall i in set (inds (mb.msgs)) \u0026 (i in set (inds (mb.msgs))))))","non-empty sequence obligation:(forall s:seq of (nat) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","recursive function obligation:(forall s:seq of (nat) \u0026 ((not (s \u003d [])) \u003d\u003e (Len(s) \u003e Len((tl s)))))","non-empty sequence obligation:(forall s:seq of (nat) \u0026 ((not (s \u003d [])) \u003d\u003e (s \u003c\u003e [])))","operation call obligation:(forall text:seq of (char) \u0026 ((\"\" \u003d \"\") \u003c\u003d\u003e (\"\" \u003d nil)))"]
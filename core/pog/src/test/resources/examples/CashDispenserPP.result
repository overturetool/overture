["state invariant initialized obligation:TransactionsInvariant([])","state invariant satisfiable obligation:(exists cards:map (CardId) to (Cardholder), balance:nat, transactions:seq of (Transaction) \u0026 TransactionsInvariant(transactions))","state invariant holds obligation:(forall cs:map (CardId) to (Cardholder), b:nat \u0026 (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions)))","state invariant holds obligation:(forall cs:map (CardId) to (Cardholder), b:nat \u0026 (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions)))","state invariant holds obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","type compatibility obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e ((balance - amount) \u003e\u003d 0)))","state invariant holds obligation:(forall cardId:CardId, amount:nat, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant((transactions ^ [transaction])))))","legal map application obligation:(forall cardId:CardId, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (cardId in set (dom cards))))","legal map application obligation:(forall cardId:CardId, date:Date \u0026 ((cardId in set (dom cards)) \u003d\u003e (cardId in set (dom cards))))","state invariant holds obligation:(forall cId:CardId, ch:Cardholder \u0026 ((cId not in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","map compatible obligation:(forall cId:CardId, ch:Cardholder \u0026 ((cId not in set (dom cards)) \u003d\u003e (forall ldom1 in set (dom cards), rdom2 in set (dom {cId |-\u003e ch}) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e (cards(ldom1) \u003d {cId |-\u003e ch}(rdom2))))))","state invariant holds obligation:(forall cId:CardId \u0026 ((cId in set (dom cards)) \u003d\u003e (TransactionsInvariant(transactions) \u003d\u003e TransactionsInvariant(transactions))))","legal sequence application obligation:(forall ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (((ts(i).date) \u003d date) \u003d\u003e (i in set (inds ts)))))","legal sequence application obligation:(forall date:Date, ts:seq of (Transaction) \u0026 (forall i in set (inds ts) \u0026 (i in set (inds ts))))","type compatibility obligation:(forall date:Date, ts:seq of (Transaction) \u0026 is_(Sum([(ts(i).amount) | i in set (inds ts) \u0026 ((ts(i).date) \u003d date)]), nat))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))","non-empty sequence obligation:(forall rs:seq of (real) \u0026 ((not (rs \u003d [])) \u003d\u003e (rs \u003c\u003e [])))","legal sequence application obligation:(forall events:seq of (Event) \u0026 (forall i in set (inds events) \u0026 (i in set (inds events))))","enumeration map injectivity obligation:(forall m1, m2 in set {{1 |-\u003e new Till(resource)}, {2 |-\u003e new Till(resource)}, {3 |-\u003e new Till(resource)}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","legal map application obligation:(forall tid:TillId \u0026 (tid in set (dom tills)))","enumeration map injectivity obligation:(forall m1, m2 in set {{5 |-\u003e peter}, {6 |-\u003e sten}, {7 |-\u003e CSK}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","state invariant holds obligation:(forall res:CentralResource \u0026 ((curCard \u003d nil) \u003d\u003e (not cardOk)))","state invariant holds obligation:(forall c:Card \u0026 ((not CardInside()) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((c \u003d nil) \u003d\u003e (not cardOk)))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","type compatibility obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e is_((retainedCards union {curCard}), set of (Card))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))))))","type compatibility obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e is_((retainedCards union {curCard}), set of (Card))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not (codeOk and cardLegal))) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false)))))","state invariant holds obligation:(forall pin:PinCode \u0026 ((CardInside() and (not cardOk)) \u003d\u003e (((nil \u003d nil) \u003d\u003e (not false)) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false)))))","state invariant holds obligation:(CardInside() \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not cardOk)) \u003d\u003e ((curCard \u003d nil) \u003d\u003e (not false))))","state invariant holds obligation:(CardInside() \u003d\u003e (((curCard \u003d nil) \u003d\u003e (not false)) \u003d\u003e ((nil \u003d nil) \u003d\u003e (not false))))","legal map application obligation:(1 in set (dom tills))","legal map application obligation:(1 in set (dom tills))","legal sequence application obligation:((statements \u003c\u003e []) \u003d\u003e ((len statements) in set (inds statements)))","state invariant initialized obligation:((((dom {|-\u003e}) union {}) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))","state invariant satisfiable obligation:(exists accounts:map (AccountId) to (Account), numberOfTries:map (CardId) to (nat), illegalCards:set of (CardId), letterbox:Letterbox, clock:Clock \u0026 (((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})))","state invariant initialized obligation:((((dom {|-\u003e}) union {}) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))","state invariant satisfiable obligation:(exists accounts:map (AccountId) to (Account), numberOfTries:map (CardId) to (nat), illegalCards:set of (CardId), letterbox:Letterbox, clock:Clock \u0026 (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))","state invariant holds obligation:(forall c:Clock, l:Letterbox \u0026 (((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","state invariant holds obligation:(forall c:Clock, l:Letterbox \u0026 (((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","legal map application obligation:(forall accountId:AccountId, cardId:CardId \u0026 (accountId in set (dom accounts)))","legal map application obligation:(forall accountId:AccountId, cardId:CardId \u0026 ((cardId not in set illegalCards) \u003d\u003e ((accountId in set (dom accounts)) \u003d\u003e (accountId in set (dom accounts)))))","legal map application obligation:(forall cardId:CardId \u0026 (cardId in set (dom numberOfTries)))","state invariant holds obligation:(forall cardId:CardId \u0026 (((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","state invariant holds obligation:(forall cardId:CardId \u0026 (((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))","legal map application obligation:(forall cardId:CardId \u0026 (cardId in set (dom numberOfTries)))","state invariant holds obligation:(((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom (numberOfTries ++ {cId |-\u003e 0 | cId in set (acc.GetCardIds)()})) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))))","state invariant holds obligation:(forall cId:CardId \u0026 (((((dom numberOfTries) union illegalCards) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {})))) \u003d\u003e ((((dom numberOfTries) union (illegalCards union {cId})) subset (dunion {(acc.GetCardIds)() | acc in set (rng accounts)})) and (forall acc1, acc2 in set (rng accounts) \u0026 ((acc1 \u003c\u003e acc2) \u003d\u003e (((acc1.GetCardIds)() inter (acc2.GetCardIds)()) \u003d {}))))))"]
["type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 40:1: (exists mk_PortType(label, cardinality, portlist):PortType \u0026 (cardinality \u003d (card (elems portlist))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 48:1: (exists mk_Event(label, type, porttype):Event \u0026 (((type \u003d \u003cINTERNAL\u003e) and ((porttype.label) \u003d \"NULLPORT\")) or (((type \u003d \u003cINPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\")) or ((type \u003d \u003cOUTPUT\u003e) and ((porttype.label) \u003c\u003e \"NULLPORT\")))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 58:1: (exists mk_State(label, type, isinitial, substates):State \u0026 let exists_entry_state: (set of (State) +\u003e bool)\n\texists_entry_state(substates) \u003d\u003d\n((exists1 s in set substates \u0026 ((s.isinitial) \u003d true)) and (forall s in set substates \u0026 ((((s.type) \u003d \u003cSIMPLE\u003e) and ((s.substates) \u003d {})) or (((s.type) \u003d \u003cCOMPLEX\u003e) and exists_entry_state((s.substates)))))) in (((type \u003d \u003cSIMPLE\u003e) and (substates \u003d {})) or ((type \u003d \u003cCOMPLEX\u003e) and exists_entry_state(substates))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 93:1: (exists mk_TimeConstraint(label, transition, cevent, tbounds, dstates, rwindows):TimeConstraint \u0026 ((((cevent.type) \u003d \u003cINTERNAL\u003e) or ((cevent.type) \u003d \u003cOUTPUT\u003e)) and (forall rw in set rwindows \u0026 (((rw.uppertimebound) - (rw.lowertimebound)) \u003d ((tbounds.uppertimebound) - (tbounds.lowertimebound))))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 111:1: (exists mk_ReactionWindow(lowertimebound, uppertimebound):ReactionWindow \u0026 (lowertimebound \u003c\u003d uppertimebound))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 120:1: (exists mk_PortLink(tromporttuple1, tromporttuple2):PortLink \u0026 ((tromporttuple1.tromlabel) \u003c\u003e (tromporttuple2.tromlabel)))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 200:31: (forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e (forall s in set states \u0026 ((not (currentstate \u003d s)) \u003d\u003e pre_substate_of(currentstate, s))))))))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 213:37: (forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e (forall af in set attrfunctions \u0026 (forall s in set states \u0026 ((not (s \u003d (af.stat))) \u003d\u003e pre_substate_of((af.stat), s))))))))))))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 219:37: (forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e (forall ts in set transitionspecs \u0026 (forall s in set states \u0026 ((not (s \u003d (ts.sourcestate))) \u003d\u003e pre_substate_of((ts.sourcestate), s)))))))))))))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 221:37: (forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e (forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) \u003d\u003e (forall d in set states \u0026 ((not (d \u003d (ts.destinstate))) \u003d\u003e pre_substate_of((ts.destinstate), d))))))))))))))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 230:51: (forall mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) \u003d\u003e ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) \u003d\u003e ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) \u003d\u003e ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) \u003d\u003e ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) \u003d\u003e ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) \u003d\u003e ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) \u003d\u003e ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) \u003d\u003e ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) \u003d\u003e ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) \u003d\u003e ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) \u003d\u003e ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) \u003d\u003e ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) \u003d\u003e ((forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states \u0026 ((d \u003d (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events \u0026 (e \u003d (ts.triggerevent)))))) \u003d\u003e (forall tc in set timeconstraints \u0026 ((exists1 ts in set transitionspecs \u0026 (ts \u003d (tc.transition))) \u003d\u003e ((exists1 e in set events \u0026 ((e \u003d (tc.constrainedevent)) and (((e.type) \u003d \u003cINTERNAL\u003e) or ((e.type) \u003d \u003cOUTPUT\u003e)))) \u003d\u003e (forall ds in set (tc.disablingstates) \u0026 (forall s in set states \u0026 ((not (s \u003d ds)) \u003d\u003e pre_substate_of(ds, s)))))))))))))))))))))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 152:1: (exists mk_Trom(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector):Trom \u0026 ((forall pt1, pt2 in set porttypes \u0026 (((pt1.label) \u003d (pt2.label)) \u003d\u003e (pt1 \u003d pt2))) and ((forall e1, e2 in set events \u0026 (((e1.label) \u003d (e2.label)) \u003d\u003e (e1 \u003d e2))) and ((forall s1, s2 in set states \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and ((forall a1, a2 in set attributes \u0026 (((a1.label) \u003d (a2.label)) \u003d\u003e (a1 \u003d a2))) and ((forall tr1, tr2 in set lsltraits \u0026 (((tr1.traittype) \u003d (tr2.traittype)) \u003d\u003e (tr1 \u003d tr2))) and ((forall af1, af2 in set attrfunctions \u0026 (((af1.stat) \u003d (af2.stat)) \u003d\u003e (af1 \u003d af2))) and ((forall ts1, ts2 in set transitionspecs \u0026 (((ts1.label) \u003d (ts2.label)) \u003d\u003e (ts1 \u003d ts2))) and ((forall tc1, tc2 in set timeconstraints \u0026 (((tc1.label) \u003d (tc2.label)) \u003d\u003e (tc1 \u003d tc2))) and ((forall e in set events \u0026 (exists pt in set porttypes \u0026 (pt \u003d (e.porttype)))) and ((exists1 s in set states \u0026 ((s.isinitial) \u003d true)) and ((exists1 s in set states \u0026 ((currentstate \u003d s) or substate_of(currentstate, s))) and ((forall a in set attributes \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d (a.type))) or (exists1 tr in set lsltraits \u0026 ((tr.traittype) \u003d (a.type))))) and ((forall tr in set lsltraits \u0026 (forall el in set (elems (tr.elementtypes)) \u0026 ((exists1 pt in set porttypes \u0026 ((pt.label) \u003d el)) or (exists1 tr2 in set lsltraits \u0026 ((tr2.traittype) \u003d el))))) and ((forall af in set attrfunctions \u0026 ((exists1 s in set states \u0026 ((s \u003d (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) \u0026 (exists1 a in set attributes \u0026 (a \u003d afa))))) and ((forall ts in set transitionspecs \u0026 ((exists1 s in set states \u0026 ((s \u003d (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states \u0026 ((d \u003d (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events \u0026 (e \u003d (ts.triggerevent)))))) and (forall tc in set timeconstraints \u0026 ((exists1 ts in set transitionspecs \u0026 (ts \u003d (tc.transition))) and ((exists1 e in set events \u0026 ((e \u003d (tc.constrainedevent)) and (((e.type) \u003d \u003cINTERNAL\u003e) or ((e.type) \u003d \u003cOUTPUT\u003e)))) and (forall ds in set (tc.disablingstates) \u0026 (exists1 s in set states \u0026 ((s \u003d ds) or substate_of(ds, s)))))))))))))))))))))))","finite set obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 279:31: (forall mk_Subsystem(label, includes, troms, portlinks):Subsystem \u0026 ((forall s1, s2 in set includes \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) \u003d\u003e (let included_subsystem: (String * set of (Subsystem) +\u003e bool)\n\tincluded_subsystem(subsystemlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((s.label) \u003d subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) \u003d\u003e ((forall trom1, trom2 in set troms \u0026 (((trom1.label) \u003d (trom2.label)) \u003d\u003e (trom1 \u003d trom2))) \u003d\u003e (let included_trom: (String * set of (Subsystem) +\u003e bool)\n\tincluded_trom(tromlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 ((exists1 trom in set (s.troms) \u0026 ((trom.label) \u003d tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms \u0026 (not included_trom((trom.label), includes))) \u003d\u003e (forall tptuple:TromPortTuple, subsystems:set of (Subsystem) \u0026 (forall s in set subsystems \u0026 (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) \u003d\u003e (exists finmap1:map (nat) to (Subsystem) \u0026 (forall su:Subsystem \u0026 (((su in set subsystems) and (su \u003c\u003e s)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d su)))))))))))))","type invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 232:1: (exists mk_Subsystem(label, includes, troms, portlinks):Subsystem \u0026 ((forall s1, s2 in set includes \u0026 (((s1.label) \u003d (s2.label)) \u003d\u003e (s1 \u003d s2))) and (let included_subsystem: (String * set of (Subsystem) +\u003e bool)\n\tincluded_subsystem(subsystemlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((s.label) \u003d subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) and ((forall trom1, trom2 in set troms \u0026 (((trom1.label) \u003d (trom2.label)) \u003d\u003e (trom1 \u003d trom2))) and (let included_trom: (String * set of (Subsystem) +\u003e bool)\n\tincluded_trom(tromlabel, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 ((exists1 trom in set (s.troms) \u0026 ((trom.label) \u003d tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms \u0026 (not included_trom((trom.label), includes))) and let linked_trom: (TromPortTuple * set of (Trom) +\u003e bool)\n\tlinked_trom(tptuple, troms) \u003d\u003d\n(exists1 trom in set troms \u0026 (((trom.label) \u003d (tptuple.tromlabel)) and (exists1 pt in set (trom.porttypes) \u0026 (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (tptuple.portlabel)))))), linked_subsystem: (TromPortTuple * set of (Subsystem) +\u003e bool)\n\tlinked_subsystem(tptuple, subsystems) \u003d\u003d\n(exists1 s in set subsystems \u0026 (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set subsystems) and (su \u003c\u003e s))} \u0026 ((not linked_trom(tptuple, (s2.troms))) and (not linked_subsystem(tptuple, (s2.includes))))))) in (forall pl in set portlinks \u0026 (((linked_trom((pl.tromporttuple1), troms) and (not linked_subsystem((pl.tromporttuple1), includes))) or ((not linked_trom((pl.tromporttuple1), troms)) and linked_subsystem((pl.tromporttuple1), includes))) and ((linked_trom((pl.tromporttuple2), troms) and (not linked_subsystem((pl.tromporttuple2), includes))) or ((not linked_trom((pl.tromporttuple2), troms)) and linked_subsystem((pl.tromporttuple2), includes))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 328:22: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((i \u003d j) \u003d\u003e (i in set (inds simulationeventlist)))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 328:47: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((i \u003d j) \u003d\u003e (j in set (inds simulationeventlist)))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 329:22: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((i \u003c j) \u003d\u003e (i in set (inds simulationeventlist))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 330:22: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((i \u003c j) \u003d\u003e (j in set (inds simulationeventlist))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 331:22: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((not ((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime)))) \u003d\u003e ((i \u003e j) \u003d\u003e (i in set (inds simulationeventlist)))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 332:22: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e (forall i, j in set (inds simulationeventlist) \u0026 ((not ((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j)))) \u003d\u003e ((not ((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime)))) \u003d\u003e ((i \u003e j) \u003d\u003e (j in set (inds simulationeventlist)))))))))","finite set obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 357:34: (forall mk_System(subsystem, simulationeventlist, lsllibrary, clock):System \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) \u003d\u003e (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) \u003d\u003e ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) \u003d\u003e ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) \u003d\u003e let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in (forall se:SimulationEvent, subsys:Subsystem \u0026 (forall s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) \u003d\u003e (exists finmap1:map (nat) to (Subsystem) \u0026 (forall su:Subsystem \u0026 (((su in set (subsys.includes)) and (su \u003c\u003e s)) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d su)))))))))))))","state invariant satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 299:7: (exists SUBSYSTEM:Subsystem, SIMULATIONEVENTLIST:seq of (SimulationEvent), LSLLIBRARY:set of (LSLTraitDefinition), CLOCK:nat \u0026 (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem)))))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 393:4: (forall tromlabel:String, subsystem:Subsystem \u0026 (exists trom:[Trom] \u0026 post_get_trom_object(tromlabel, subsystem, trom)))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 418:11: (forall trom:Trom, se:SimulationEvent \u0026 (((trom.label) \u003d (se.tromlabel)) \u003d\u003e (exists ts:[TransitionSpec] \u0026 ((ts in set (trom.transitionspecs)) \u003d\u003e ((not (((trom.currentstate).label) \u003d ((ts.sourcestate).label))) \u003d\u003e pre_substate_of((trom.currentstate), (ts.sourcestate)))))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 406:4: (forall trom:Trom, se:SimulationEvent \u0026 (pre_get_transition_spec(trom, se) \u003d\u003e (exists ts:[TransitionSpec] \u0026 post_get_transition_spec(trom, se, ts))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 436:35: (forall substate:State, complexstate:State \u0026 (((complexstate.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e ((not (substate in set (complexstate.substates))) \u003d\u003e (forall s in set (complexstate.substates) \u0026 (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_substate_of(substate, s))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 457:44: (forall complexstate:State \u0026 (((complexstate.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e (exists entry:State \u0026 (forall s in set (complexstate.substates) \u0026 (((s.isinitial) \u003d true) \u003d\u003e ((not (((s.type) \u003d \u003cSIMPLE\u003e) and (entry \u003d s))) \u003d\u003e (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state(s))))))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 443:4: (forall complexstate:State \u0026 (pre_get_entry_state(complexstate) \u003d\u003e (exists entry:State \u0026 post_get_entry_state(complexstate, entry))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 474:46: (forall trom:Trom \u0026 (((trom.states) \u003c\u003e {}) \u003d\u003e (exists initial:State \u0026 (forall s in set (trom.states) \u0026 (((s.isinitial) \u003d true) \u003d\u003e ((not (((s.type) \u003d \u003cSIMPLE\u003e) and (initial \u003d s))) \u003d\u003e (((s.type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state(s))))))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 460:4: (forall trom:Trom \u0026 (pre_get_initial_state(trom) \u003d\u003e (exists initial:State \u0026 post_get_initial_state(trom, initial))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 477:4: (forall tupleA:TromPortTuple, subsystem:Subsystem \u0026 (exists tupleB:[TromPortTuple] \u0026 post_get_linked_tromport_tuple(tupleA, subsystem, tupleB)))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 502:12: (forall trom:Trom, subsys:Subsystem \u0026 ((((subsys.troms) \u003c\u003e {}) or ((subsys.includes) \u003c\u003e {})) \u003d\u003e ((not (trom in set (subsys.troms))) \u003d\u003e (forall subsystem in set (subsys.includes) \u0026 pre_exists_in_subsystem(trom, subsystem)))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 519:16: (forall trom:Trom \u0026 (exists event:[Event] \u0026 (forall ts in set (trom.transitionspecs) \u0026 (((ts.sourcestate) \u003d (trom.currentstate)) \u003d\u003e ((((ts.triggerevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e pre_constrained_event(trom, (ts.triggerevent)))))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 509:4: (forall trom:Trom \u0026 (exists event:[Event] \u0026 post_get_unconstrained_internal_event(trom, event)))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 547:8: (forall se:SimulationEvent, se_list:seq of (SimulationEvent) \u0026 ((se in set (elems se_list)) \u003d\u003e (exists index:nat1 \u0026 (index in set (inds se_list)))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 538:4: (forall se:SimulationEvent, se_list:seq of (SimulationEvent) \u0026 (pre_get_simevent_index(se, se_list) \u003d\u003e (exists index:nat1 \u0026 post_get_simevent_index(se, se_list, index))))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 550:4: (forall rw:ReactionWindow \u0026 (exists time:nat \u0026 post_get_random_time_within_rw(rw, time)))","function postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 557:4: (forall portlist:seq of (Port) \u0026 (pre_get_lru_port(portlist) \u003d\u003e (exists port:Port \u0026 post_get_lru_port(portlist, port))))","finite set obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 606:28: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 607:36: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM)))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 609:36: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 pre_get_initial_state(trom)))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 577:7: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (CLOCK \u003d 0)))","while loop termination obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 579:7: ...","while loop termination obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 581:10: ...","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 581:25: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST)))))","while loop termination obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 586:10: ...","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 587:26: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((i \u003c\u003d (len SIMULATIONEVENTLIST)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST)))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 589:26: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 589:13: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((SIMULATIONEVENTLIST(i).occurtime) \u003d CLOCK)))))","state invariant holds obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 591:13: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem)))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 619:9: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e ((len SIMULATIONEVENTLIST) in set (inds SIMULATIONEVENTLIST))))))))","finite set obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 627:28: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom)))))))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 628:36: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) \u003d\u003e (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) \u003d\u003e ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM))))))))))","operation establishes postcondition obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 570:4: (((SIMULATIONEVENTLIST \u003c\u003e []) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003e\u003d CLOCK) and ((se.eventhistory) \u003d nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (((trom.currentstate) \u003d get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (((CLOCK \u003d 0) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let se:SimulationEvent be st (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i:nat1 be st (SIMULATIONEVENTLIST(i) \u003d se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 let j:nat1 be st (SIMULATIONEVENTLIST(j) \u003d se2) in (i \u003c j)))) or (event \u003d nil)))) \u003d\u003e ((CLOCK \u003d (CLOCK~ + 1)) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((SIMULATIONEVENTLIST \u003c\u003e []) and (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) \u003d CLOCK) and ((forall se in set (elems SIMULATIONEVENTLIST) \u0026 (((se.occurtime) \u003c\u003d CLOCK) and ((se.eventhistory) \u003c\u003e nil))) and (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 (forall tc in set (trom.timeconstraints) \u0026 ((tc.reactionwindows) \u003d {})))))))))))","state invariant holds obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 642:7: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem))))))))","state invariant holds obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 646:7: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e let mk_System(subsystem, simulationeventlist, lsllibrary, clock) \u003d System in (let contains_trom: (Subsystem +\u003e bool)\n\tcontains_trom(subsys) \u003d\u003d\n(((subsys.troms) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink: (Subsystem +\u003e bool)\n\tcontains_portlink(subsys) \u003d\u003d\n(((subsys.portlinks) \u003c\u003e {}) or (exists1 s in set (subsys.includes) \u0026 contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) \u0026 (((i \u003d j) and (simulationeventlist(i) \u003d simulationeventlist(j))) or (((i \u003c j) and ((simulationeventlist(i).occurtime) \u003c\u003d (simulationeventlist(j).occurtime))) or ((i \u003e j) and ((simulationeventlist(i).occurtime) \u003e\u003d (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) \u0026 ((((se1.occurtime) \u003d (se2.occurtime)) and ((se1.tromlabel) \u003c\u003e (se2.tromlabel))) or ((se1.occurtime) \u003c\u003e (se2.occurtime)))) and (let accepted_by_trom: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_trom(se, subsys) \u003d\u003d\n(exists1 trom in set (subsys.troms) \u0026 (((trom.label) \u003d (se.tromlabel)) and (exists1 e in set (trom.events) \u0026 (((e.label) \u003d (se.eventlabel)) and (exists1 pt in set (trom.porttypes) \u0026 ((pt \u003d (e.porttype)) and (exists1 p in set (elems (pt.portlist)) \u0026 ((p.label) \u003d (se.portlabel))))))))) in let accepted_by_subsystem: (SimulationEvent * Subsystem +\u003e bool)\n\taccepted_by_subsystem(se, subsys) \u003d\u003d\n(exists1 s in set (subsys.includes) \u0026 (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | su:Subsystem \u0026 ((su in set (subsys.includes)) and (su \u003c\u003e s))} \u0026 ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) \u0026 ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait: (Subsystem +\u003e bool)\n\texists_lsltrait(subsys) \u003d\u003d\n((forall trom in set (subsys.troms) \u0026 (forall tr in set (trom.lsltraits) \u0026 (exists traitdef in set lsllibrary \u0026 ((traitdef.label) \u003d (tr.traitlabel))))) and (forall s in set (subsys.includes) \u0026 exists_lsltrait(s))) in exists_lsltrait(subsystem))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 646:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e pre_get_transition_spec(get_trom_object((se.tromlabel), SUBSYSTEM), se)))","type compatibility obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 646:33: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (inv_Trom(get_trom_object((se.tromlabel), SUBSYSTEM)) and is_(trom, Trom))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 650:10: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) \u003d nil) or ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d false))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 654:10: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (get_trom_object((se.tromlabel), SUBSYSTEM) \u003c\u003e nil))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 658:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) \u003d nil) or ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d false))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 662:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d true))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 664:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).postcondition) \u003d true)))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 666:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))))) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM).occurtime) \u003d CLOCK))))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 668:13: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))))) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e ((get_trom_object((se.tromlabel), SUBSYSTEM) in set (elems SIMULATIONEVENTLIST)) and ((get_trom_object((se.tromlabel), SUBSYSTEM).tromlabel) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).label)))))))))))","operation establishes postcondition obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 635:4: (forall se:SimulationEvent, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d false) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d nil) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d nil) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e (((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).triggeredtransition) \u003d true) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).tromcurrentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).currentstate)) and ((((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).assignmentvector) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).assignmentvector)) and (((get_trom_object((se.tromlabel), SUBSYSTEM).eventhistory).reactionshistory) \u003d {})))) \u003d\u003e ((((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cSIMPLE\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d (get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))) or ((((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate).type) \u003d \u003cCOMPLEX\u003e) and ((get_trom_object((se.tromlabel), SUBSYSTEM).currentstate) \u003d get_entry_state((get_trom_object((se.tromlabel), SUBSYSTEM).destinstate))))) \u003d\u003e ((CLOCK \u003d CLOCK~) \u003d\u003e (let event:[Event] \u003d get_unconstrained_internal_event(trom) in (((event \u003c\u003e nil) and let j:nat1 be st (j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) in (SIMULATIONEVENTLIST \u003d (([SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003c\u003d j)] ^ [se2]) ^ [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (i \u003e j)]))) or (event \u003d nil)) \u003d\u003e (CLOCK \u003d CLOCK~))))))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 694:19: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((((trom.constrainedevent).label) \u003d (trom.eventlabel)) and ((trom in set (trom.reactionwindows)) and (((trom.occurtime) \u003e\u003d (trom.lowertimebound)) and ((trom.occurtime) \u003c\u003d (trom.uppertimebound)))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 696:19: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((((trom.constrainedevent).label) \u003d (trom.eventlabel)) and ((trom in set (trom.reactionwindows)) and (((trom.occurtime) \u003e\u003d (trom.lowertimebound)) and ((trom.occurtime) \u003c\u003d (trom.uppertimebound))))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 705:16: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e (((trom.currentstate) in set (trom.disablingstates)) and (trom in set (trom.reactionwindows)))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 707:16: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom.currentstate) in set (trom.disablingstates)) and (trom in set (trom.reactionwindows))))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 713:13: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e ((trom.label) \u003d ((trom.transition).label))))))))","operation call obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 715:13: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cENABLED\u003e)))) \u003d\u003e ((trom.label) \u003d ((trom.transition).label)))))))))","operation establishes postcondition obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 682:4: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (((se.occurtime) \u003d CLOCK) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cFIRED\u003e)))) \u003d\u003e ((trom not in set (trom.reactionwindows)) \u003d\u003e ((exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d trom) and (((rh.reactionwindow) \u003d trom) and ((rh.reaction) \u003d \u003cDISABLED\u003e)))) \u003d\u003e (((trom not in set (trom.reactionwindows)) and let se2:SimulationEvent be st (se2 \u003d get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)])) or ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3:SimulationEvent be st (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3))])))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists rh in set ((se.eventhistory).reactionshistory) \u0026 (((rh.timeconstraint) \u003d tc) and (((rh.reactionwindow) \u003d rw) and ((rh.reaction) \u003d \u003cENABLED\u003e)))) \u003d\u003e (let rw:ReactionWindow be st (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in let port:Port be st (port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) in let occurtime:nat be st (occurtime \u003d get_random_time_within_rw(rw)) in let se2:SimulationEvent be st (se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) in ((rw in set (tc.reactionwindows)) and ((se2 in set (elems SIMULATIONEVENTLIST)) and (((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) and let tromporttuple:[TromPortTuple] be st (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in (((tromporttuple \u003c\u003e nil) and let se3:SimulationEvent be st (se3 \u003d mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil)) in (se3 in set (elems SIMULATIONEVENTLIST))) or (tromporttuple \u003d nil))) or (((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e)))) \u003d\u003e (CLOCK \u003d CLOCK~)))))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 742:30: (((ts.postcondition) \u003d true) \u003d\u003e ((not ((((ts.destinstate).type) \u003d \u003cSIMPLE\u003e) and ((trom.currentstate) \u003d (ts.destinstate)))) \u003d\u003e ((((ts.destinstate).type) \u003d \u003cCOMPLEX\u003e) \u003d\u003e pre_get_entry_state((ts.destinstate)))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 729:4: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (pre_update_trom_current_state(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_trom_current_state(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 745:4: (forall trom:Trom, se:SimulationEvent, ts:[TransitionSpec], oldstate:System \u0026 (pre_update_history_assignment_vector(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_assignment_vector(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 757:4: (forall trom:Trom, se:SimulationEvent, ts:[TransitionSpec], oldstate:System \u0026 (pre_update_history_notransition(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_notransition(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 775:4: (forall trom:Trom, se:SimulationEvent, ts:TransitionSpec, oldstate:System \u0026 (pre_update_history_transition(trom, se, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_transition(trom, se, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 793:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_update_history_fire_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_fire_reaction(trom, se, tc, rw, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 818:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_update_history_disable_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_disable_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 851:12: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (exists rw:ReactionWindow \u0026 (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","type compatibility obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 853:15: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 inv_ReactionWindow(mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 839:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, ts:TransitionSpec, oldstate:System \u0026 (pre_update_history_enable_reaction(trom, se, tc, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_update_history_enable_reaction(trom, se, tc, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 865:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_fire_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_fire_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 900:13: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d get_enabled_simevent(trom, tc)))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 907:37: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~)))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 909:43: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (i in set (inds SIMULATIONEVENTLIST~))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 913:18: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (exists tromporttuple:[TromPortTuple] \u0026 (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 919:18: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (exists se3:SimulationEvent \u0026 (se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 924:39: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) and (SIMULATIONEVENTLIST~(i) \u003c\u003e se3)) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 926:41: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 (i in set (inds SIMULATIONEVENTLIST~)))))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 927:41: ((((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows))) \u003d\u003e ((rw not in set (tc.reactionwindows)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d get_enabled_simevent(trom, tc)) \u003d\u003e ((not ((((tc.constrainedevent).type) \u003d \u003cINTERNAL\u003e) and (SIMULATIONEVENTLIST \u003d [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) \u0026 (SIMULATIONEVENTLIST~(i) \u003c\u003e se2)]))) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e (forall se3:SimulationEvent \u0026 ((se3 \u003d get_enabled_simevent_synch(tromporttuple, tc)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((SIMULATIONEVENTLIST~(i) \u003c\u003e se2) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 883:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, rw:ReactionWindow, oldstate:System \u0026 (pre_disable_reaction(trom, se, tc, rw, oldstate) \u003d\u003e (exists newstate:System \u0026 post_disable_reaction(trom, se, tc, rw, oldstate, newstate))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 945:12: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (exists rw:ReactionWindow \u0026 (rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","type compatibility obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 947:15: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 inv_ReactionWindow(mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK)))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 950:12: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (exists port:Port \u0026 (port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist)))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 952:17: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 pre_get_lru_port((((tc.constrainedevent).porttype).portlist))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 954:12: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (exists occurtime:nat \u0026 (occurtime \u003d get_random_time_within_rw(rw))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 958:12: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil))))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 970:18: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) \u003d\u003e ((rw in set (tc.reactionwindows)) \u003d\u003e ((se2 in set (elems SIMULATIONEVENTLIST)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (exists tromporttuple:[TromPortTuple] \u0026 (tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)))))))))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 978:20: (((ts.label) \u003d ((tc.transition).label)) \u003d\u003e (forall rw:ReactionWindow \u0026 ((rw \u003d mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) \u003d\u003e (forall port:Port \u0026 ((port \u003d get_lru_port((((tc.constrainedevent).porttype).portlist))) \u003d\u003e (forall occurtime:nat \u0026 ((occurtime \u003d get_random_time_within_rw(rw)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) \u003d\u003e ((rw in set (tc.reactionwindows)) \u003d\u003e ((se2 in set (elems SIMULATIONEVENTLIST)) \u003d\u003e ((((tc.constrainedevent).type) \u003d \u003cOUTPUT\u003e) \u003d\u003e (forall tromporttuple:[TromPortTuple] \u0026 ((tromporttuple \u003d get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) \u003d\u003e ((tromporttuple \u003c\u003e nil) \u003d\u003e (exists se3:SimulationEvent \u0026 (se3 \u003d mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil))))))))))))))))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 930:4: (forall trom:Trom, se:SimulationEvent, tc:TimeConstraint, ts:TransitionSpec, oldstate:System \u0026 (pre_enable_reaction(trom, se, tc, ts, oldstate) \u003d\u003e (exists newstate:System \u0026 post_enable_reaction(trom, se, tc, ts, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 993:4: (forall trom:Trom, tc:TimeConstraint, oldstate:System \u0026 (pre_get_enabled_simevent(trom, tc, oldstate) \u003d\u003e (exists se:SimulationEvent \u0026 post_get_enabled_simevent(trom, tc, oldstate, se, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1017:4: (forall tromporttuple:TromPortTuple, tc:TimeConstraint, oldstate:System \u0026 (exists se:SimulationEvent \u0026 post_get_enabled_simevent_synch(tromporttuple, tc, oldstate, se, oldstate, newstate)))","finite set obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1053:28: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (exists finmap1:map (nat) to (Trom) \u0026 (forall trom:Trom \u0026 (exists_in_subsystem(trom, SUBSYSTEM) \u003d\u003e (exists findex2 in set (dom finmap1) \u0026 (finmap1(findex2) \u003d trom)))))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1054:36: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom:Trom \u0026 pre_exists_in_subsystem(trom, SUBSYSTEM))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1060:20: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (exists se:SimulationEvent \u0026 (se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1067:24: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (exists i:nat1 \u0026 (SIMULATIONEVENTLIST(i) \u003d se)))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1069:22: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 (i in set (inds SIMULATIONEVENTLIST))))))))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1073:28: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 ((SIMULATIONEVENTLIST(i) \u003d se) \u003d\u003e (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 (exists j:nat1 \u0026 (SIMULATIONEVENTLIST(j) \u003d se2))))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1075:26: ((CLOCK \u003d 0) \u003d\u003e ((CLOCK \u003d 0) \u003d\u003e (forall trom in set {trom | trom:Trom \u0026 exists_in_subsystem(trom, SUBSYSTEM)} \u0026 let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall se:SimulationEvent \u0026 ((se \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e ((se in set (elems SIMULATIONEVENTLIST)) \u003d\u003e (forall i:nat1 \u0026 ((SIMULATIONEVENTLIST(i) \u003d se) \u003d\u003e (forall se2 in set (elems SIMULATIONEVENTLIST~) \u0026 (forall j:nat1 \u0026 (j in set (inds SIMULATIONEVENTLIST)))))))))))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1037:4: (pre_schedule_unconstrained_internal_events_from_initial_state(oldstate) \u003d\u003e (exists newstate:System \u0026 post_schedule_unconstrained_internal_events_from_initial_state(oldstate, newstate)))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1098:17: (((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (exists j:nat1 \u0026 (j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)))))","legal function application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1100:19: (((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 pre_get_simevent_index(se, SIMULATIONEVENTLIST))))","let be st existence obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1102:17: (((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (exists se2:SimulationEvent \u0026 (se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1109:19: (((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((i \u003c\u003d j) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))","legal sequence application obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1112:22: (((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) \u003d (trom.label))) \u003d\u003e let event:[Event] \u003d get_unconstrained_internal_event(trom) in ((event \u003c\u003e nil) \u003d\u003e (forall j:nat1 \u0026 ((j \u003d get_simevent_index(se, SIMULATIONEVENTLIST)) \u003d\u003e (forall se2:SimulationEvent \u0026 ((se2 \u003d mk_SimulationEvent((event.label), (trom.label), \"NULLPORT\", CLOCK, nil)) \u003d\u003e (forall i in set (inds SIMULATIONEVENTLIST~) \u0026 ((i \u003e j) \u003d\u003e (i in set (inds SIMULATIONEVENTLIST~))))))))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1082:4: (forall trom:Trom, se:SimulationEvent, oldstate:System \u0026 (pre_schedule_unconstrained_internal_event(trom, se, oldstate) \u003d\u003e (exists newstate:System \u0026 post_schedule_unconstrained_internal_event(trom, se, oldstate, newstate))))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1118:4: (exists newstate:System \u0026 post_initialize_simulation_clock(oldstate, newstate))","operation postcondition satisfiable obligation in \u0027TROM\u0027 (simulator1.vdmsl) at line 1127:4: (exists newstate:System \u0026 post_update_simulation_clock(oldstate, newstate))"]
["legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 (forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e (i1 in set (inds decls)))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 (forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e (i2 in set (inds decls)))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (i in set (inds decls)))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e (i in set (inds decls))))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e (is_((decls(i).val), AST`BoolVal) \u003d\u003e (i in set (inds decls)))))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e ((not (is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) \u003d \u003cBoolType\u003e))) \u003d\u003e (i in set (inds decls)))))))","legal sequence application obligation:(forall decls:seq of (Declaration) \u0026 ((forall i1, i2 in set (inds decls) \u0026 ((i1 \u003c\u003e i2) \u003d\u003e ((decls(i1).id) \u003c\u003e (decls(i2).id)))) \u003d\u003e (forall i in set (inds decls) \u0026 (((decls(i).val) \u003c\u003e nil) \u003d\u003e ((not (is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) \u003d \u003cBoolType\u003e))) \u003d\u003e (is_((decls(i).val), AST`IntVal) \u003d\u003e (i in set (inds decls))))))))","comprehension map injectivity obligation:(forall decls:seq of (Declaration) \u0026 (forall m1, m2 in set {{id |-\u003e tp} | mk_Declaration(id, tp, -) in set (elems decls)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall stmt:Stmt, senv:StatEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e is_(stmt, BlockStmt)))","type compatibility obligation:(forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e is_(stmt, AssignStmt))))","type compatibility obligation:(forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e is_(stmt, CondStmt)))))","type compatibility obligation:(forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e is_(stmt, ForStmt))))))","type compatibility obligation:(forall stmt:Stmt, senv:StatEnv \u0026 ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e is_(stmt, RepeatStmt)))))))","type compatibility obligation:(forall ex:Expr, senv:StatEnv \u0026 ((not (is_(ex, AST`BoolVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`IntVal) \u003d true)) \u003d\u003e ((is_(ex, AST`Variable) \u003d true) \u003d\u003e is_(ex, Variable)))))","type compatibility obligation:(forall ex:Expr, senv:StatEnv \u0026 ((not (is_(ex, AST`BoolVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`IntVal) \u003d true)) \u003d\u003e ((not (is_(ex, AST`Variable) \u003d true)) \u003d\u003e ((is_(ex, AST`BinaryExpr) \u003d true) \u003d\u003e is_(ex, BinaryExpr))))))","legal map application obligation:(forall mk_Variable(id):Variable, senv:StatEnv \u0026 ((id in set (dom senv)) \u003d\u003e (id in set (dom senv))))","legal function application obligation:(forall mk_Program(decls, stmt):Program \u0026 ((STATSEM`wf_Program(mk_AST`Program(decls, stmt)) and pre_EvalStmt(stmt, EvalDeclarations(decls))) \u003d\u003e pre_EvalStmt(stmt, EvalDeclarations(decls))))","comprehension map injectivity obligation:(forall decls:seq of (Declaration) \u0026 (forall m1, m2 in set {{id |-\u003e (if (val \u003c\u003e nil)\nthen val\nelseif (tp \u003d \u003cBoolType\u003e)\nthen mk_AST`BoolVal(false)\nelse mk_AST`IntVal(0))} | mk_Declaration(id, tp, val) in set (elems decls)} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4))))))","type compatibility obligation:(forall decls:seq of (Declaration) \u0026 is_({id |-\u003e (if (val \u003c\u003e nil)\nthen val\nelseif (tp \u003d \u003cBoolType\u003e)\nthen mk_AST`BoolVal(false)\nelse mk_AST`IntVal(0)) | mk_Declaration(id, tp, val) in set (elems decls)}, map (Identifier) to (Value)))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (is_(stmt, AST`BlockStmt) \u003d\u003e is_(stmt, BlockStmt)))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`AssignStmt) \u003d\u003e is_(stmt, AssignStmt))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`CondStmt) \u003d\u003e is_(stmt, CondStmt)))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`ForStmt) \u003d\u003e is_(stmt, ForStmt))))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 ((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) \u003d\u003e (is_(stmt, AST`RepeatStmt) \u003d\u003e is_(stmt, RepeatStmt)))))))","legal function application obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e pre_EvalBlockStmt(stmt, denv))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((is_(stmt, AST`BlockStmt) \u003d true) \u003d\u003e is_(stmt, BlockStmt))))","legal function application obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e pre_EvalAssignStmt(stmt, denv)))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`AssignStmt) \u003d true) \u003d\u003e is_(stmt, AssignStmt)))))","legal function application obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e pre_EvalCondStmt(stmt, denv))))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`CondStmt) \u003d true) \u003d\u003e is_(stmt, CondStmt))))))","legal function application obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e pre_EvalForStmt(stmt, denv)))))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`ForStmt) \u003d true) \u003d\u003e is_(stmt, ForStmt)))))))","legal function application obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e pre_EvalRepeatStmt(stmt, denv))))))))","type compatibility obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e ((not (is_(stmt, AST`BlockStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`AssignStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`CondStmt) \u003d true)) \u003d\u003e ((not (is_(stmt, AST`ForStmt) \u003d true)) \u003d\u003e ((is_(stmt, AST`RepeatStmt) \u003d true) \u003d\u003e is_(stmt, RepeatStmt))))))))","cases exhaustive obligation:(forall stmt:Stmt, denv:DynEnv \u0026 (((is_(stmt, AST`BlockStmt) \u003d\u003e pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) \u003d\u003e pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) \u003d\u003e pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) \u003d\u003e pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) \u003d\u003e pre_EvalRepeatStmt(stmt, denv)))))) \u003d\u003e (((((true \u003d is_(stmt, AST`BlockStmt)) or (true \u003d is_(stmt, AST`AssignStmt))) or (true \u003d is_(stmt, AST`CondStmt))) or (true \u003d is_(stmt, AST`ForStmt))) or (true \u003d is_(stmt, AST`RepeatStmt)))))","legal function application obligation:(forall mk_BlockStmt(decls, stmts):BlockStmt, denv:DynEnv \u0026 (let ldenv:DynEnv \u003d EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv)) \u003d\u003e let ldenv:DynEnv \u003d EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv))))","non-empty sequence obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 ((stmts \u003c\u003e []) \u003d\u003e (stmts \u003c\u003e [])))","legal function application obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e pre_EvalStmts((tl stmts), EvalStmt((hd stmts), denv)))))","recursive function obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (LenStmt(stmts, denv) \u003e LenStmt((tl stmts), EvalStmt((hd stmts), denv))))))","non-empty sequence obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (stmts \u003c\u003e []))))","legal function application obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e pre_EvalStmt((hd stmts), denv))))","non-empty sequence obligation:(forall stmts:seq of (Stmt), denv:DynEnv \u0026 (((stmts \u003c\u003e []) \u003d\u003e pre_EvalStmt((hd stmts), denv)) \u003d\u003e ((not ([] \u003d stmts)) \u003d\u003e (stmts \u003c\u003e []))))","legal function application obligation:(forall mk_AssignStmt(lhs, rhs):AssignStmt, denv:DynEnv \u0026 (pre_EvalExpr(rhs, denv) \u003d\u003e pre_EvalExpr(rhs, denv)))","legal function application obligation:(forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 (pre_EvalExpr(guard, denv) \u003d\u003e pre_EvalExpr(guard, denv)))","legal function application obligation:(forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e pre_EvalExpr(guard, denv)))","legal function application obligation:(forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e ((EvalExpr(guard, denv).val) \u003d\u003e pre_EvalStmt(thenst, denv))))","legal function application obligation:(forall mk_CondStmt(guard, thenst, elsest):CondStmt, denv:DynEnv \u0026 ((pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)\nthen pre_EvalStmt(thenst, denv)\nelse pre_EvalStmt(elsest, denv))) \u003d\u003e ((not (EvalExpr(guard, denv).val)) \u003d\u003e pre_EvalStmt(elsest, denv))))","legal function application obligation:(forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 (pre_EvalStmt(repeat, denv) \u003d\u003e pre_EvalStmt(repeat, denv)))","legal function application obligation:(forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e pre_EvalStmt(repeat, denv)))","legal function application obligation:(forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(repeat, denv) in pre_EvalExpr(until, denv\u0027)))","legal function application obligation:(forall mk_RepeatStmt(repeat, until):RepeatStmt, denv:DynEnv \u0026 ((pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(repeat, denv) in ((not (EvalExpr(until, denv\u0027).val)) \u003d\u003e pre_EvalRepeatStmt(mk_AST`RepeatStmt(repeat, until), denv\u0027))))","legal function application obligation:(forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 (pre_EvalAssignStmt(start, denv) \u003d\u003e pre_EvalAssignStmt(start, denv)))","legal function application obligation:(forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e pre_EvalAssignStmt(start, denv)))","legal function application obligation:(forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalAssignStmt(start, denv) in pre_EvalForLoop((start.lhs), EvalExpr(stop, denv\u0027), stmt, denv\u0027)))","legal function application obligation:(forall mk_ForStmt(start, stop, stmt):ForStmt, denv:DynEnv \u0026 ((pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv))) \u003d\u003e let denv\u0027:DynEnv \u003d EvalAssignStmt(start, denv) in pre_EvalExpr(stop, denv\u0027)))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e is_((denv(id).val), real)))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e is_((val.val), real)))","legal map application obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (id in set (dom denv))))","legal function application obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e pre_EvalStmt(stmt, denv))))","legal function application obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in pre_EvalForLoop(mk_AST`Variable(id), val, stmt, (denv\u0027 ++ {id |-\u003e mk_AST`IntVal(((denv\u0027(id).val) + 1))})))))","recursive function obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in (LoopParInc(mk_Variable(id), val, stmt, denv) \u003e LoopParInc(mk_AST`Variable(id), val, stmt, (denv\u0027 ++ {id |-\u003e mk_AST`IntVal(((denv\u0027(id).val) + 1))}))))))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in is_((denv\u0027(id).val), real))))","legal map application obligation:(forall mk_Variable(id):Variable, val:Value, stmt:Stmt, denv:DynEnv \u0026 (pre_EvalStmt(stmt, denv) \u003d\u003e (((denv(id).val) \u003c\u003d (val.val)) \u003d\u003e let denv\u0027:DynEnv \u003d EvalStmt(stmt, denv) in (id in set (dom denv\u0027)))))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 is_((val.val), real))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 is_((denv(id).val), real))","legal map application obligation:(forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 (id in set (dom denv)))","type compatibility obligation:(forall mk_Variable(id):Variable, val:Value, -:Stmt, denv:DynEnv \u0026 (((val.val) - (denv(id).val)) \u003e\u003d 0))","type compatibility obligation:(forall ex:Expr, denv:DynEnv \u0026 (is_(ex, AST`BinaryExpr) \u003d\u003e is_(ex, BinaryExpr)))","legal map application obligation:(forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e (exists mk_Variable(id):Expr \u0026 ((mk_Variable(id) \u003d ex) \u003d\u003e let mk_Variable(id) \u003d ex in (id in set (dom denv))))))))","legal function application obligation:(forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_Variable(id):Expr \u0026 (mk_Variable(id) \u003d ex))) \u003d\u003e (exists mk_BinaryExpr(-, -, -):Expr \u0026 ((mk_BinaryExpr(any1, any2, any3) \u003d ex) \u003d\u003e let mk_BinaryExpr(-, -, -) \u003d ex in pre_EvalBinaryExpr(ex, denv))))))))","type compatibility obligation:(forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((not (exists mk_BoolVal(-):Expr \u0026 (mk_BoolVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_IntVal(-):Expr \u0026 (mk_IntVal(any1) \u003d ex))) \u003d\u003e ((not (exists mk_Variable(id):Expr \u0026 (mk_Variable(id) \u003d ex))) \u003d\u003e (exists mk_BinaryExpr(-, -, -):Expr \u0026 ((mk_BinaryExpr(any1, any2, any3) \u003d ex) \u003d\u003e let mk_BinaryExpr(-, -, -) \u003d ex in is_(ex, BinaryExpr))))))))","cases exhaustive obligation:(forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e ((((exists mk_BoolVal(-):Expr \u0026 (ex \u003d mk_BoolVal(any1))) or (exists mk_IntVal(-):Expr \u0026 (ex \u003d mk_IntVal(any2)))) or (exists mk_Variable(id):Expr \u0026 (ex \u003d mk_Variable(id)))) or (exists mk_BinaryExpr(-, -, -):Expr \u0026 (ex \u003d mk_BinaryExpr(any3, any4, any5))))))","type compatibility obligation:(forall ex:Expr, denv:DynEnv \u0026 ((is_(ex, AST`BinaryExpr) \u003d\u003e pre_EvalBinaryExpr(ex, denv)) \u003d\u003e (is_((cases ex :\nmk_BoolVal(-) -\u003e ex,\nmk_IntVal(-) -\u003e ex,\nmk_Variable(id) -\u003e denv(id),\nmk_BinaryExpr(-, -, -) -\u003e EvalBinaryExpr(ex, denv)\n end), BoolVal) or is_((cases ex :\nmk_BoolVal(-) -\u003e ex,\nmk_IntVal(-) -\u003e ex,\nmk_Variable(id) -\u003e denv(id),\nmk_BinaryExpr(-, -, -) -\u003e EvalBinaryExpr(ex, denv)\n end), IntVal))))","legal function application obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 ((op \u003d \u003cDiv\u003e) \u003d\u003e pre_EvalExpr(rhs, denv)))","legal function application obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e pre_EvalExpr(lhs, denv)))","legal function application obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e pre_EvalExpr(rhs, denv)))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((\u003cAdd\u003e \u003d op) \u003d\u003e is_(v1, real))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((\u003cAdd\u003e \u003d op) \u003d\u003e is_(v2, real))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((\u003cSub\u003e \u003d op) \u003d\u003e is_(v1, real)))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((\u003cSub\u003e \u003d op) \u003d\u003e is_(v2, real)))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e is_(v1, real))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e is_(v2, real))))))","non-zero obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((\u003cDiv\u003e \u003d op) \u003d\u003e (v2 \u003c\u003e 0))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((\u003cMul\u003e \u003d op) \u003d\u003e is_(v1, real)))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((\u003cMul\u003e \u003d op) \u003d\u003e is_(v2, real)))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((\u003cLt\u003e \u003d op) \u003d\u003e is_(v1, real))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((\u003cLt\u003e \u003d op) \u003d\u003e is_(v2, real))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((\u003cGt\u003e \u003d op) \u003d\u003e is_(v1, real)))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((\u003cGt\u003e \u003d op) \u003d\u003e is_(v2, real)))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((\u003cAnd\u003e \u003d op) \u003d\u003e is_(v1, bool)))))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((\u003cAnd\u003e \u003d op) \u003d\u003e (v1 \u003d\u003e is_(v2, bool))))))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((not (\u003cAnd\u003e \u003d op)) \u003d\u003e ((\u003cOr\u003e \u003d op) \u003d\u003e is_(v1, bool))))))))))))","type compatibility obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in ((not (\u003cAdd\u003e \u003d op)) \u003d\u003e ((not (\u003cSub\u003e \u003d op)) \u003d\u003e ((not (\u003cDiv\u003e \u003d op)) \u003d\u003e ((not (\u003cMul\u003e \u003d op)) \u003d\u003e ((not (\u003cLt\u003e \u003d op)) \u003d\u003e ((not (\u003cGt\u003e \u003d op)) \u003d\u003e ((not (\u003cEq\u003e \u003d op)) \u003d\u003e ((not (\u003cAnd\u003e \u003d op)) \u003d\u003e ((\u003cOr\u003e \u003d op) \u003d\u003e ((not v1) \u003d\u003e is_(v2, bool)))))))))))))","cases exhaustive obligation:(forall mk_BinaryExpr(lhs, op, rhs):BinaryExpr, denv:DynEnv \u0026 (((op \u003d \u003cDiv\u003e) \u003d\u003e ((EvalExpr(rhs, denv).val) \u003c\u003e 0)) \u003d\u003e let v1:(bool | int) \u003d (EvalExpr(lhs, denv).val), v2:(bool | int) \u003d (EvalExpr(rhs, denv).val) in (((((((((op \u003d \u003cAdd\u003e) or (op \u003d \u003cSub\u003e)) or (op \u003d \u003cDiv\u003e)) or (op \u003d \u003cMul\u003e)) or (op \u003d \u003cLt\u003e)) or (op \u003d \u003cGt\u003e)) or (op \u003d \u003cEq\u003e)) or (op \u003d \u003cAnd\u003e)) or (op \u003d \u003cOr\u003e))))","legal function application obligation:pre_EvalExpr(binexpr, {|-\u003e})"]
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<testResult type="proof_obligation">
<result>
<po column="1" line="40" message="sizeof: subtype obligation in 'M' (shmemSL) at line 40:1&#10;(forall m:M &amp;&#10;  (((m.stop) - (m.start)) + 1) &gt; 0)&#10;" number="1" object="" resource="shmemSL" toString="sizeof: subtype obligation in 'M' (shmemSL) at line 40:1&#10;(forall m:M &amp;&#10;  (((m.stop) - (m.start)) + 1) &gt; 0)&#10;"/>
<po column="24" line="56" message="spacefor: recursive function obligation in 'M' (shmemSL) at line 56:24&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;" number="2" object="" resource="shmemSL" toString="spacefor: recursive function obligation in 'M' (shmemSL) at line 56:24&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;"/>
<po column="3" line="52" message="spacefor: cases exhaustive obligation in 'M' (shmemSL) at line 52:3&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  Q = [] or (exists ([h] ^ tail):Quadrant &amp; Q = ([h] ^ tail)))&#10;" number="3" object="" resource="shmemSL" toString="spacefor: cases exhaustive obligation in 'M' (shmemSL) at line 52:3&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  Q = [] or (exists ([h] ^ tail):Quadrant &amp; Q = ([h] ^ tail)))&#10;"/>
<po column="41" line="70" message="bestfit: recursive function obligation in 'M' (shmemSL) at line 70:41&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      ((((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;" number="4" object="" resource="shmemSL" toString="bestfit: recursive function obligation in 'M' (shmemSL) at line 70:41&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      ((((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;"/>
<po column="24" line="71" message="bestfit: recursive function obligation in 'M' (shmemSL) at line 71:24&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;" number="5" object="" resource="shmemSL" toString="bestfit: recursive function obligation in 'M' (shmemSL) at line 71:24&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  (not [] = Q =&gt;&#10;    (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;    let ([h] ^ tail) = Q in&#10;      (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) &gt;= size)) =&gt;&#10;        QuadrantLen(size, Q) &gt; QuadrantLen(size, tail)))))&#10;"/>
<po column="3" line="66" message="bestfit: cases exhaustive obligation in 'M' (shmemSL) at line 66:3&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  Q = [] or (exists ([h] ^ tail):Quadrant &amp; Q = ([h] ^ tail)))&#10;" number="6" object="" resource="shmemSL" toString="bestfit: cases exhaustive obligation in 'M' (shmemSL) at line 66:3&#10;(forall size:nat1, Q:Quadrant &amp;&#10;  Q = [] or (exists ([h] ^ tail):Quadrant &amp; Q = ([h] ^ tail)))&#10;"/>
<po column="31" line="80" message="add: subtype obligation in 'M' (shmemSL) at line 80:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      ((hole = size) =&gt;&#10;        inv_M(mk_M(&lt;USED&gt;, (h.start), (h.stop)))))))&#10;" number="7" object="" resource="shmemSL" toString="add: subtype obligation in 'M' (shmemSL) at line 80:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      ((hole = size) =&gt;&#10;        inv_M(mk_M(&lt;USED&gt;, (h.start), (h.stop)))))))&#10;"/>
<po column="68" line="81" message="add: subtype obligation in 'M' (shmemSL) at line 81:68&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        (((h.start) + size) - 1) &gt;= 0))))&#10;" number="8" object="" resource="shmemSL" toString="add: subtype obligation in 'M' (shmemSL) at line 81:68&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        (((h.start) + size) - 1) &gt;= 0))))&#10;"/>
<po column="31" line="81" message="add: subtype obligation in 'M' (shmemSL) at line 81:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        inv_M(mk_M(&lt;USED&gt;, (h.start), (((h.start) + size) - 1))) and ((((h.start) + size) - 1) &gt;= 0)))))&#10;" number="9" object="" resource="shmemSL" toString="add: subtype obligation in 'M' (shmemSL) at line 81:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        inv_M(mk_M(&lt;USED&gt;, (h.start), (((h.start) + size) - 1))) and ((((h.start) + size) - 1) &gt;= 0)))))&#10;"/>
<po column="31" line="82" message="add: subtype obligation in 'M' (shmemSL) at line 82:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        inv_M(mk_M(&lt;FREE&gt;, ((h.start) + size), (h.stop)))))))&#10;" number="10" object="" resource="shmemSL" toString="add: subtype obligation in 'M' (shmemSL) at line 82:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    ((((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      (not (hole = size) =&gt;&#10;        inv_M(mk_M(&lt;FREE&gt;, ((h.start) + size), (h.stop)))))))&#10;"/>
<po column="31" line="83" message="add: function apply obligation in 'M' (shmemSL) at line 83:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      pre_add(size, hole, tail))))&#10;" number="11" object="" resource="shmemSL" toString="add: function apply obligation in 'M' (shmemSL) at line 83:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      pre_add(size, hole, tail))))&#10;"/>
<po column="31" line="83" message="add: recursive function obligation in 'M' (shmemSL) at line 83:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      QuadrantLen2(size, hole, Q) &gt; QuadrantLen2(size, hole, tail))))&#10;" number="12" object="" resource="shmemSL" toString="add: recursive function obligation in 'M' (shmemSL) at line 83:31&#10;(forall size:nat1, hole:nat1, Q:Quadrant &amp; (hole &gt;= size) =&gt;&#10;  (exists ([h] ^ tail):Quadrant &amp; ([h] ^ tail) = Q =&gt;&#10;  let ([h] ^ tail) = Q in&#10;    (not (((h.type) = &lt;FREE&gt;) and (sizeof(h) = hole)) =&gt;&#10;      QuadrantLen2(size, hole, Q) &gt; QuadrantLen2(size, hole, tail))))&#10;"/>
<po column="13" line="98" message="combine: recursive function obligation in 'M' (shmemSL) at line 98:13&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    ((((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      QuadrantLen0(Q) &gt; QuadrantLen0(([mk_M(&lt;FREE&gt;, (h1.start), (h2.stop))] ^ tail)))))&#10;" number="13" object="" resource="shmemSL" toString="combine: recursive function obligation in 'M' (shmemSL) at line 98:13&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    ((((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      QuadrantLen0(Q) &gt; QuadrantLen0(([mk_M(&lt;FREE&gt;, (h1.start), (h2.stop))] ^ tail)))))&#10;"/>
<po column="22" line="98" message="combine: subtype obligation in 'M' (shmemSL) at line 98:22&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    ((((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      inv_M(mk_M(&lt;FREE&gt;, (h1.start), (h2.stop))))))&#10;" number="14" object="" resource="shmemSL" toString="combine: subtype obligation in 'M' (shmemSL) at line 98:22&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    ((((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      inv_M(mk_M(&lt;FREE&gt;, (h1.start), (h2.stop))))))&#10;"/>
<po column="20" line="99" message="combine: recursive function obligation in 'M' (shmemSL) at line 99:20&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    (not (((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      QuadrantLen0(Q) &gt; QuadrantLen0((tl Q)))))&#10;" number="15" object="" resource="shmemSL" toString="combine: recursive function obligation in 'M' (shmemSL) at line 99:20&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    (not (((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      QuadrantLen0(Q) &gt; QuadrantLen0((tl Q)))))&#10;"/>
<po column="31" line="99" message="combine: non-empty sequence obligation in 'M' (shmemSL) at line 99:31&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    (not (((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      Q &lt;&gt; [])))&#10;" number="16" object="" resource="shmemSL" toString="combine: non-empty sequence obligation in 'M' (shmemSL) at line 99:31&#10;(forall Q:Quadrant &amp;&#10;  (exists ([h1, h2] ^ tail):Quadrant &amp; ([h1, h2] ^ tail) = Q =&gt;&#10;  let ([h1, h2] ^ tail) = Q in&#10;    (not (((h1.type) = &lt;FREE&gt;) and ((h2.type) = &lt;FREE&gt;)) =&gt;&#10;      Q &lt;&gt; [])))&#10;"/>
<po column="9" line="110" message="delete: non-empty sequence obligation in 'M' (shmemSL) at line 110:9&#10;(forall item:M, Q:Quadrant &amp;&#10;  Q &lt;&gt; [])&#10;" number="17" object="" resource="shmemSL" toString="delete: non-empty sequence obligation in 'M' (shmemSL) at line 110:9&#10;(forall item:M, Q:Quadrant &amp;&#10;  Q &lt;&gt; [])&#10;"/>
<po column="17" line="111" message="delete: subtype obligation in 'M' (shmemSL) at line 111:17&#10;(forall item:M, Q:Quadrant &amp;&#10;  (((hd Q) = item) =&gt;&#10;    inv_M(mk_M(&lt;FREE&gt;, (item.start), (item.stop)))))&#10;" number="18" object="" resource="shmemSL" toString="delete: subtype obligation in 'M' (shmemSL) at line 111:17&#10;(forall item:M, Q:Quadrant &amp;&#10;  (((hd Q) = item) =&gt;&#10;    inv_M(mk_M(&lt;FREE&gt;, (item.start), (item.stop)))))&#10;"/>
<po column="59" line="111" message="delete: non-empty sequence obligation in 'M' (shmemSL) at line 111:59&#10;(forall item:M, Q:Quadrant &amp;&#10;  (((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;" number="19" object="" resource="shmemSL" toString="delete: non-empty sequence obligation in 'M' (shmemSL) at line 111:59&#10;(forall item:M, Q:Quadrant &amp;&#10;  (((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;"/>
<po column="12" line="112" message="delete: non-empty sequence obligation in 'M' (shmemSL) at line 112:12&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;" number="20" object="" resource="shmemSL" toString="delete: non-empty sequence obligation in 'M' (shmemSL) at line 112:12&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;"/>
<po column="17" line="112" message="delete: recursive function obligation in 'M' (shmemSL) at line 112:17&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    MQuadrantLen(item, Q) &gt; MQuadrantLen(item, (tl Q))))&#10;" number="21" object="" resource="shmemSL" toString="delete: recursive function obligation in 'M' (shmemSL) at line 112:17&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    MQuadrantLen(item, Q) &gt; MQuadrantLen(item, (tl Q))))&#10;"/>
<po column="33" line="112" message="delete: non-empty sequence obligation in 'M' (shmemSL) at line 112:33&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;" number="22" object="" resource="shmemSL" toString="delete: non-empty sequence obligation in 'M' (shmemSL) at line 112:33&#10;(forall item:M, Q:Quadrant &amp;&#10;  (not ((hd Q) = item) =&gt;&#10;    Q &lt;&gt; []))&#10;"/>
<po column="1" line="119" message="fragments: subtype obligation in 'M' (shmemSL) at line 119:1&#10;(forall Q:Quadrant &amp;&#10;  ((card {x | [x in set (elems Q)] &amp; ((x.type) = &lt;FREE&gt;)}) - 1) &gt;= 0)&#10;" number="23" object="" resource="shmemSL" toString="fragments: subtype obligation in 'M' (shmemSL) at line 119:1&#10;(forall Q:Quadrant &amp;&#10;  ((card {x | [x in set (elems Q)] &amp; ((x.type) = &lt;FREE&gt;)}) - 1) &gt;= 0)&#10;"/>
<po column="3" line="127" message="seed: state invariant obligation in 'M' (shmemSL) at line 127:3&#10;-- After rseed := n&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="24" object="" resource="shmemSL" toString="seed: state invariant obligation in 'M' (shmemSL) at line 127:3&#10;-- After rseed := n&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="5" line="133" message="inc: state invariant obligation in 'M' (shmemSL) at line 133:5&#10;-- After rseed := (((rseed * 69069) + 5) mod 4294967296)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="25" object="" resource="shmemSL" toString="inc: state invariant obligation in 'M' (shmemSL) at line 133:5&#10;-- After rseed := (((rseed * 69069) + 5) mod 4294967296)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="10" line="146" message="FirstFit: state invariant obligation in 'M' (shmemSL) at line 146:10&#10;-- After Q4 := add(size, q4, Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="26" object="" resource="shmemSL" toString="FirstFit: state invariant obligation in 'M' (shmemSL) at line 146:10&#10;-- After Q4 := add(size, q4, Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="16" line="146" message="FirstFit: function apply obligation in 'M' (shmemSL) at line 146:16&#10;pre_add(size, q4, Q4)&#10;" number="27" object="" resource="shmemSL" toString="FirstFit: function apply obligation in 'M' (shmemSL) at line 146:16&#10;pre_add(size, q4, Q4)&#10;"/>
<po column="17" line="150" message="FirstFit: state invariant obligation in 'M' (shmemSL) at line 150:17&#10;-- After Q3 := add(size, q3, Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="28" object="" resource="shmemSL" toString="FirstFit: state invariant obligation in 'M' (shmemSL) at line 150:17&#10;-- After Q3 := add(size, q3, Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="23" line="150" message="FirstFit: function apply obligation in 'M' (shmemSL) at line 150:23&#10;pre_add(size, q3, Q3)&#10;" number="29" object="" resource="shmemSL" toString="FirstFit: function apply obligation in 'M' (shmemSL) at line 150:23&#10;pre_add(size, q3, Q3)&#10;"/>
<po column="10" line="160" message="BestFit: state invariant obligation in 'M' (shmemSL) at line 160:10&#10;-- After Q4 := add(size, q4, Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="30" object="" resource="shmemSL" toString="BestFit: state invariant obligation in 'M' (shmemSL) at line 160:10&#10;-- After Q4 := add(size, q4, Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="16" line="160" message="BestFit: function apply obligation in 'M' (shmemSL) at line 160:16&#10;pre_add(size, q4, Q4)&#10;" number="31" object="" resource="shmemSL" toString="BestFit: function apply obligation in 'M' (shmemSL) at line 160:16&#10;pre_add(size, q4, Q4)&#10;"/>
<po column="17" line="164" message="BestFit: state invariant obligation in 'M' (shmemSL) at line 164:17&#10;-- After Q3 := add(size, q3, Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="32" object="" resource="shmemSL" toString="BestFit: state invariant obligation in 'M' (shmemSL) at line 164:17&#10;-- After Q3 := add(size, q3, Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="23" line="164" message="BestFit: function apply obligation in 'M' (shmemSL) at line 164:23&#10;pre_add(size, q3, Q3)&#10;" number="33" object="" resource="shmemSL" toString="BestFit: function apply obligation in 'M' (shmemSL) at line 164:23&#10;pre_add(size, q3, Q3)&#10;"/>
<po column="3" line="171" message="Reset: state invariant obligation in 'M' (shmemSL) at line 171:3&#10;-- After Q3 := [mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))]&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="34" object="" resource="shmemSL" toString="Reset: state invariant obligation in 'M' (shmemSL) at line 171:3&#10;-- After Q3 := [mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))]&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="32" line="171" message="Reset: subtype obligation in 'M' (shmemSL) at line 171:32&#10;(MAXMEM - 1) &gt;= 0&#10;" number="35" object="" resource="shmemSL" toString="Reset: subtype obligation in 'M' (shmemSL) at line 171:32&#10;(MAXMEM - 1) &gt;= 0&#10;"/>
<po column="10" line="171" message="Reset: subtype obligation in 'M' (shmemSL) at line 171:10&#10;inv_M(mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))) and ((MAXMEM - 1) &gt;= 0)&#10;" number="36" object="" resource="shmemSL" toString="Reset: subtype obligation in 'M' (shmemSL) at line 171:10&#10;inv_M(mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))) and ((MAXMEM - 1) &gt;= 0)&#10;"/>
<po column="3" line="172" message="Reset: state invariant obligation in 'M' (shmemSL) at line 172:3&#10;-- After Q4 := [mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))]&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="37" object="" resource="shmemSL" toString="Reset: state invariant obligation in 'M' (shmemSL) at line 172:3&#10;-- After Q4 := [mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))]&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="32" line="172" message="Reset: subtype obligation in 'M' (shmemSL) at line 172:32&#10;(MAXMEM - 1) &gt;= 0&#10;" number="38" object="" resource="shmemSL" toString="Reset: subtype obligation in 'M' (shmemSL) at line 172:32&#10;(MAXMEM - 1) &gt;= 0&#10;"/>
<po column="10" line="172" message="Reset: subtype obligation in 'M' (shmemSL) at line 172:10&#10;inv_M(mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))) and ((MAXMEM - 1) &gt;= 0)&#10;" number="39" object="" resource="shmemSL" toString="Reset: subtype obligation in 'M' (shmemSL) at line 172:10&#10;inv_M(mk_M(&lt;FREE&gt;, 0, (MAXMEM - 1))) and ((MAXMEM - 1) &gt;= 0)&#10;"/>
<po column="13" line="180" message="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 180:13&#10;i in set inds Q3&#10;" number="40" object="" resource="shmemSL" toString="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 180:13&#10;i in set inds Q3&#10;"/>
<po column="15" line="181" message="DeleteOne: state invariant obligation in 'M' (shmemSL) at line 181:15&#10;-- After Q3 := delete(Q3(i), Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="41" object="" resource="shmemSL" toString="DeleteOne: state invariant obligation in 'M' (shmemSL) at line 181:15&#10;-- After Q3 := delete(Q3(i), Q3)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="28" line="181" message="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 181:28&#10;i in set inds Q3&#10;" number="42" object="" resource="shmemSL" toString="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 181:28&#10;i in set inds Q3&#10;"/>
<po column="13" line="185" message="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 185:13&#10;i in set inds Q4&#10;" number="43" object="" resource="shmemSL" toString="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 185:13&#10;i in set inds Q4&#10;"/>
<po column="15" line="186" message="DeleteOne: state invariant obligation in 'M' (shmemSL) at line 186:15&#10;-- After Q4 := delete(Q4(i), Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="44" object="" resource="shmemSL" toString="DeleteOne: state invariant obligation in 'M' (shmemSL) at line 186:15&#10;-- After Q4 := delete(Q4(i), Q4)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="28" line="186" message="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 186:28&#10;i in set inds Q4&#10;" number="45" object="" resource="shmemSL" toString="DeleteOne: sequence apply obligation in 'M' (shmemSL) at line 186:28&#10;i in set inds Q4&#10;"/>
<po column="3" line="196" message="TryFirst: while loop termination obligation in 'M' (shmemSL) at line 196:3&#10;while ((count &lt; loops) and FirstFit(rand(CHUNK))) do ...&#10;" number="46" object="" resource="shmemSL" toString="TryFirst: while loop termination obligation in 'M' (shmemSL) at line 196:3&#10;while ((count &lt; loops) and FirstFit(rand(CHUNK))) do ...&#10;"/>
<po column="6" line="200" message="TryFirst: state invariant obligation in 'M' (shmemSL) at line 200:6&#10;-- After count := (count + 1)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="47" object="" resource="shmemSL" toString="TryFirst: state invariant obligation in 'M' (shmemSL) at line 200:6&#10;-- After count := (count + 1)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="3" line="211" message="TryBest: while loop termination obligation in 'M' (shmemSL) at line 211:3&#10;while ((count &lt; loops) and BestFit(rand(CHUNK))) do ...&#10;" number="48" object="" resource="shmemSL" toString="TryBest: while loop termination obligation in 'M' (shmemSL) at line 211:3&#10;while ((count &lt; loops) and BestFit(rand(CHUNK))) do ...&#10;"/>
<po column="6" line="215" message="TryBest: state invariant obligation in 'M' (shmemSL) at line 215:6&#10;-- After count := (count + 1)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="49" object="" resource="shmemSL" toString="TryBest: state invariant obligation in 'M' (shmemSL) at line 215:6&#10;-- After count := (count + 1)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="6" line="232" message="main: state invariant obligation in 'M' (shmemSL) at line 232:6&#10;-- After best := TryBest(loops)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="50" object="" resource="shmemSL" toString="main: state invariant obligation in 'M' (shmemSL) at line 232:6&#10;-- After best := TryBest(loops)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="6" line="236" message="main: state invariant obligation in 'M' (shmemSL) at line 236:6&#10;-- After first := TryFirst(loops)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="51" object="" resource="shmemSL" toString="main: state invariant obligation in 'M' (shmemSL) at line 236:6&#10;-- After first := TryFirst(loops)&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="11" line="239" message="main: state invariant obligation in 'M' (shmemSL) at line 239:11&#10;-- After result := (result ^ [&lt;SAME&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="52" object="" resource="shmemSL" toString="main: state invariant obligation in 'M' (shmemSL) at line 239:11&#10;-- After result := (result ^ [&lt;SAME&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="11" line="241" message="main: state invariant obligation in 'M' (shmemSL) at line 241:11&#10;-- After result := (result ^ [&lt;BEST&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="53" object="" resource="shmemSL" toString="main: state invariant obligation in 'M' (shmemSL) at line 241:11&#10;-- After result := (result ^ [&lt;BEST&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
<po column="11" line="242" message="main: state invariant obligation in 'M' (shmemSL) at line 242:11&#10;-- After result := (result ^ [&lt;FIRST&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;" number="54" object="" resource="shmemSL" toString="main: state invariant obligation in 'M' (shmemSL) at line 242:11&#10;-- After result := (result ^ [&lt;FIRST&gt;])&#10;let mk_Memory(-, q3, q4) = Memory in (((len q3) &gt; 0) and ((len q4) &gt; 0))&#10;"/>
</result>
</testResult>

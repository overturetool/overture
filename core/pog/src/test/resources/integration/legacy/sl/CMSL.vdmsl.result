["type invariant satisfiable obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 12:3: (exists num:Angle \u0026 (num \u003c\u003d 360))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 36:5: (forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e [mk_(\u003cFlareOneA\u003e, 900), mk_(\u003cFlareTwoA\u003e, 500), mk_(\u003cDoNothingA\u003e, 100), mk_(\u003cFlareOneA\u003e, 500)]}, {\u003cMissileB\u003e |-\u003e [mk_(\u003cFlareTwoB\u003e, 500), mk_(\u003cFlareTwoB\u003e, 700)]}, {\u003cMissileC\u003e |-\u003e [mk_(\u003cFlareOneC\u003e, 400), mk_(\u003cDoNothingC\u003e, 100), mk_(\u003cFlareTwoC\u003e, 400), mk_(\u003cFlareOneC\u003e, 500)]}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","enumeration map injectivity obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 44:25: (forall m1, m2 in set {{\u003cMissileA\u003e |-\u003e 1}, {\u003cMissileB\u003e |-\u003e 2}, {\u003cMissileC\u003e |-\u003e 3}, {\u003cNone\u003e |-\u003e 0}} \u0026 (forall d3 in set (dom m1), d4 in set (dom m2) \u0026 ((d3 \u003d d4) \u003d\u003e (m1(d3) \u003d m2(d4)))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 51:30: (((inv_Angle(88) and inv_Angle(70)) and inv_Angle(222)) and inv_Angle(44))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 56:30: (((inv_Angle(188) and inv_Angle(70)) and inv_Angle(2)) and inv_Angle(44))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 61:30: (((inv_Angle(288) and inv_Angle(170)) and inv_Angle(222)) and inv_Angle(44))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 77:35: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e (missileInputs \u003c\u003e [])))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 82:14: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (curMis in set (dom missilePriority))))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:14: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (lastMissile(magid) in set (dom missilePriority))))))","type compatibility obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:30: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (((is_(lastMissile(magid), \u003cMissileA\u003e) or is_(lastMissile(magid), \u003cMissileB\u003e)) or is_(lastMissile(magid), \u003cMissileC\u003e)) or is_(lastMissile(magid), \u003cNone\u003e))))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 83:30: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not (magid not in set (dom lastMissile))) \u003d\u003e ((magid in set (dom lastMissile)) \u003d\u003e (magid in set (dom lastMissile))))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 86:36: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e (curMis in set (dom responseDB)))))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 88:18: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), newOutput, (lastMissile ++ {magid |-\u003e curMis}), (curTime + stepLength))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 88:24: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid))))) \u003d\u003e let newOutput:Output \u003d InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in (missileInputs \u003c\u003e []))))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 91:15: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (CMLen(missileInputs, outputSoFar, lastMissile, curTime) \u003e CMLen((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 91:21: (forall missileInputs:MissileInputs, outputSoFar:Output, lastMissile:map (MagId) to ([MissileType]), curTime:nat \u0026 ((not (missileInputs \u003d [])) \u003d\u003e let mk_(curMis, angle):MissileInput \u003d (hd missileInputs), magid:MagId \u003d Angle2MagId(angle) in ((not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) \u003e missilePriority(lastMissile(magid)))))) \u003d\u003e (missileInputs \u003c\u003e []))))","legal map application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 101:41: (forall curTime:nat, expOutput:Output, plan:Plan, magid:MagId \u0026 ((magid in set (dom expOutput)) \u003d\u003e (magid in set (dom expOutput))))","map compatible obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 100:3: (forall curTime:nat, expOutput:Output, plan:Plan, magid:MagId \u0026 (forall ldom1 in set (dom {magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}), rdom2 in set (dom ({magid} \u003c-: expOutput)) \u0026 ((ldom1 \u003d rdom2) \u003d\u003e ({magid |-\u003e ((if (magid in set (dom expOutput))\nthen LeavePrefixUnchanged(expOutput(magid), curTime)\nelse []) ^ MakeOutputFromPlan(curTime, plan))}(ldom1) \u003d ({magid} \u003c-: expOutput)(rdom2)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 111:4: (forall output_l:seq of (OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (let mk_(-, t):OutputStep \u003d output_l(i) in (t \u003c\u003d curTime) \u003d\u003e (i in set (inds output_l)))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 112:33: (forall output_l:seq of (OutputStep), curTime:nat \u0026 (forall i in set (inds output_l) \u0026 (i in set (inds output_l))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 117:25: (forall curTime:nat, response:seq of (Response) \u0026 let output:seq of (OutputStep) \u003d OutputAtTimeZero(response) in (forall i in set (inds output) \u0026 (i in set (inds output))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 125:32: (forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in (absTimes \u003c\u003e []))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 127:24: (forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 ((i - 1) in set (inds absTimes))))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 128:24: (forall response:seq of (Response) \u0026 let absTimes:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -):(FlareType * nat) \u003d (hd absTimes) in (forall i in set {2, ... ,(len absTimes)} \u0026 (i in set (inds absTimes))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 136:26: (forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","recursive function obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 137:17: (forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (RespLen(ts) \u003e RespLen((tl ts)))))","non-empty sequence obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 137:44: (forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e (ts \u003c\u003e [])))","legal sequence application obligation in \u0027DEFAULT\u0027 (CMSL.vdmsl) at line 138:43: (forall ts:seq of (Response) \u0026 ((not (ts \u003d [])) \u003d\u003e let mk_(f, t):Response \u003d (hd ts), ns:seq of ((FlareType * nat)) \u003d RelativeToAbsoluteTimes((tl ts)) in (forall i in set (inds ns) \u0026 (i in set (inds ns)))))"]
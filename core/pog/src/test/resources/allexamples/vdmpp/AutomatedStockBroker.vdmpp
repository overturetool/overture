
class IO

--  Overture STANDARD LIBRARY: INPUT/OUTPUT
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customizable. 
-- Don't care's may NOT be used in the parameter lists.
--
-- The in/out functions  will return false if an error occurs. In this
-- case an internal error string will be set (see 'ferror').
--
-- File path:
--  * An absolute path is accepted and used as specified.
--  * A relative path is relative to the debugger or if running in the 
--      Overture IDE relative to the project root.
--

types
 
/**
 * The file directive used in in/out functions.
 */
public filedirective = <start>|<append> 

functions

/**
 * Write VDM value in ASCII format to the console.
 *
 * @param val the VDM value to be written
 * @return true if successful else false
 */
public static writeval[@p]: @p -> bool
writeval(val)==
  is not yet specified;

/**
 * Write VDM value in ASCII format to file. The type of the val must be
 * specified as fwriteval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @param val the VDM value to be written.
 * @param fdir if <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file
 * @return true if successful else false
 */
public static fwriteval[@p]:seq1 of char * @p * filedirective -> bool
fwriteval(filename,val,fdir) ==
  is not yet specified;

/**
 * Read VDM value in ASCII format from file. The type which should be read must be
 * specified as freadval[seq of char](...) when calling the function.
 *
 * @param filename the name of the file
 * @return mk_(success,@p) if successful success will be 
 * set to true else false. @p will hold nil if unsuccessful or the value read.
 */
public static freadval[@p]:seq1 of char -> bool * [@p]
freadval(filename) ==
  is not yet specified
  post let mk_(b,t) = RESULT in not b => t = nil;

operations

/**
 * Write text to std out. Surrounding double quotes will be stripped,
 * backslashed characters should be interpreted.
 *
 * @param text the text to write to the console
 * @return if successful true else false.
 */
public echo: seq of char ==> bool
echo(text) ==
  fecho ("",text,nil);

/**
 * Write text to file like <code>echo</code>.
 *
 * @param filename the name of the file
 * @param text the text to write to be written.
 * @param fdir if nil or <start> then it will overwrite an existing file, 
 *  else <append> will append output to the existing file.
 * @return true if successful else false
 */
public fecho: seq of char * seq of char * [filedirective] ==> bool
fecho (filename,text,fdir) ==
  is not yet specified
  pre filename = "" <=> fdir = nil;

/**
 * Returns the last error which may have occurred by any of the io/out functions
 *
 * @return the last error message
 */
public ferror:()  ==> seq of char
ferror () ==
  is not yet specified;
  
-- New simplified format printing operations


/**
 * Prints any VDM value to the console
 *
 * @param arg a VDM value of any type
 */
public static print: ? ==> ()
print(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console as a new line
 *
 * @param arg a VDM value of any type
 */
public static println: ? ==> ()
println(arg) ==
    is not yet specified;

/**
 * Prints any VDM value to the console
 *
 * @param format standard format string used in 
  *  Java by <code>String.format(format,value)</code>
 * @param arg a sequence of VDM values of any type
 */
public static printf: seq of char * seq of ? ==> ()
printf(format, args) ==
    is not yet specified;

end IO


class MATH

-- 	Overture STANDARD LIBRARY: MATH
--      --------------------------------------------
-- 
-- Standard library for the Overture Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

  functions
public static
    sin:real +> real
    sin(v) ==
    is not yet specified    
    post abs RESULT <= 1;

public static
    cos:real +> real
    cos(v) ==
    is not yet specified
    post abs RESULT <= 1;

public static
    tan:real -> real
    tan(a) ==
    is not yet specified
    pre cos(a) <> 0;

public static
    cot:real -> real	
    cot(a) ==
    is not yet specified -- Could also be: 1/tan(r)
    pre sin(a) <> 0;

public static
    asin:real -> real
    asin(a) ==
    is not yet specified
    pre abs a <= 1;

public static
    acos:real -> real
    acos(a) ==
    is not yet specified
    pre abs a <= 1;

public static
    atan:real +> real
    atan(v) ==
    is not yet specified;

public static
    acot:real +> real
    acot(a) ==
    atan(1/a)
    pre a <> 0;

public static
    sqrt:real -> real
    sqrt(a) ==
    is not yet specified
    pre a >= 0;

public static
    pi_f:() +> real
    pi_f () ==
    is not yet specified

  operations

public static
    srand:int ==> ()
    srand(a) ==
    let - = MATH`srand2(a) in skip
    pre a >= -1;

public static
    rand:int ==> int 
    rand(a) ==
    is not yet specified;

public static
    srand2:int ==> int 
    srand2(a) ==
    is not yet specified
    pre a >= -1

  functions

public static
    exp:real +> real
    exp(a) ==
    is not yet specified;

public static
    ln:real -> real
    ln(a) ==
    is not yet specified
    pre a > 0;

public static
    log:real -> real
    log(a) ==
    is not yet specified
    pre a > 0;

public static 
    fac:nat -> nat1 
    fac(a) == 
    is not yet specified 
    pre a < 21;         -- The limit for 64-bit calculations

  values
public
    pi = 3.14159265358979323846

 
end MATH

class AutomatedStockBroker is subclass of GLOBAL
  
instance variables
  stocks : seq of StockRecord;
  stockWatchers : map StockIdentifier to StockWatcher;
  actionLog : seq of ActionEvent := [];
  balance : int;
  inv balance >= 0;
  -- no stock can have the same name  
  inv forall x,y in set inds stocks & x <> y => stocks(x).Name <> stocks(y).Name;

  --says that foreach ActionEvent in the log if there exist a next action with the same 
  --Stock name, it should have a different ActionType. this insures that you dont sell or buy the same
  --two times in a row
  inv let stockIdentifiers = {si.Name | si in set elems stocks}
      in 
        forall stockIdentifier in set stockIdentifiers & 
          let allEventsStock = [ actionLog(i) | i in set inds actionLog 
                                              & actionLog(i).StockName = stockIdentifier]
          in 
            (forall e in set inds allEventsStock & 
               (e <> len allEventsStock) => 
               (allEventsStock(e).Type <> allEventsStock(e+1).Type)); 
       
  inv MaxOneOfEachActionTypePerTime(actionLog);    
  

operations

public AutomatedStockBroker: nat ==> AutomatedStockBroker
AutomatedStockBroker(startCash) == (
  balance := startCash;
  stocks := [];
  stockWatchers := {|->};
);

public AddStock: StockRecord * nat1 ==> ()
AddStock(sRecord,priority) == (
  stocks := stocks(1,...,priority-1) ^ [sRecord] 
            ^ stocks(priority+1,...,len stocks);
  if (World`simulate)
  then stockWatchers(sRecord.Name) := new StockWatcher(sRecord)
  else stockWatchers(sRecord.Name) := new StockWatcher(sRecord,testValues(sRecord.Name));
)
pre sRecord.Name not in set { x.Name | x in set elems stocks}
post (sRecord.Name in set dom stockWatchers) 
     and (sRecord = stocks(priority)); 
  
public GetActionLog:() ==> seq of ActionEvent
GetActionLog() == 
  return actionLog;
  
public GetStocksWithActiveActionTrigger: StockState ==> seq of StockRecord
GetStocksWithActiveActionTrigger(ss) == 
  return [stocks(s) | s in set inds stocks  
                    & (stockWatchers(stocks(s).Name).GetTriggeredAction() <> nil)
                      and (stocks(s).State = ss)]
post let res = RESULT in forall i in set inds res & res(i).State = ss;
  
FindValidBuy: seq of StockRecord * nat ==> [StockRecord]
FindValidBuy(potBuys,time) ==  
  return let affordableStocks = 
    [potBuys(x) | x in set inds potBuys & CanAfford(potBuys(x),balance)]
     in 
     (
      if(len affordableStocks > 0)
      then let x in set inds affordableStocks be st  
       (forall y in set inds affordableStocks & (stockWatchers(affordableStocks(x).Name).GetStockValue(time)) >= 
       (stockWatchers(affordableStocks(y).Name).GetStockValue(time)))
       in affordableStocks(x)
      else nil 
     );
    
FindValidSell: seq of StockRecord * nat ==> StockRecord
FindValidSell(potSells,time) == 
  return let x in set inds potSells be st  
    (forall y in set inds potSells & 
      (stockWatchers(potSells(x).Name).GetStockValue(time) - potSells(x).Cost) >= 
      (stockWatchers(potSells(y).Name).GetStockValue(time) - potSells(y).Cost))
    in potSells(x)  
pre len potSells > 0
post IsGTAll(stockWatchers(RESULT.Name).GetStockValue(time) - RESULT.Cost,
  {stockWatchers(x.Name).GetStockValue(time) - x.Cost | x in set elems potSells});

  PerformBuy: StockRecord * nat ==> ()
  PerformBuy(potAction,time) == 
   let sw = stockWatchers(potAction.Name),value = sw.GetStockValue(time)  
   in
   (
    actionLog := [mk_ActionEvent(<Buy>,time,potAction.Name,value)] ^ actionLog;
    balance := balance - value;

    let i in set inds stocks be st stocks(i).Name = potAction.Name
     in
    (
     stocks(i) := mu(potAction, State |-> <Bought>, Cost |-> value );
     sw.updateStockRecord(stocks(i))
    ) 
   )
  pre potAction.State = <PotentialBuy> and 
   stockWatchers(potAction.Name).GetTriggeredAction() = <Buy>
  post balance >= 0;

  PerformSell: StockRecord * nat ==> ()
  PerformSell(potAction,time) == 
   let sw = stockWatchers(potAction.Name),value = sw.GetStockValue(time) 
   in
   (
    actionLog := [mk_ActionEvent(<Sell>,time,potAction.Name,value)] ^ actionLog;
    balance := balance + value;
    
    let i in set inds stocks be st stocks(i).Name = potAction.Name
     in
    (
     stocks(i) := mu(potAction, State |-> <PotentialBuy>, Cost |-> 0);
     sw.updateStockRecord(stocks(i))
    ) 
   )
  pre potAction.State = <Bought> and 
   stockWatchers(potAction.Name).GetTriggeredAction() = <Sell>  
  post balance >= 0;
  
  ObserveAllStocks: nat ==> ()
  ObserveAllStocks(time) == 
   for all i in set inds stocks do
    let stock = stocks(i), csw = stockWatchers(stock.Name)
     in csw.ObserveStock(time);

  public Step: nat ==> ()
  Step(time) == (

   ObserveAllStocks(time);
      
   let potBuys = GetStocksWithActiveActionTrigger(<PotentialBuy>) , 
    potSells = GetStocksWithActiveActionTrigger(<Bought>),
    validBuy = FindValidBuy(potBuys,time)
    in
    (
     if(len potSells > 0)
     then (PerformSell(FindValidSell(potSells,time), time);)
     else skip;
     IO`print("\npot sels : ");
     IO`print(potSells);

     if(validBuy <> nil)
     then (PerformBuy(validBuy, time);)
     else skip;
     IO`print("\npot buys : ");
     IO`print(potBuys);
    );  
   
   IO`print("\n");
   IO`print("Finished step : ");
   IO`print(time);
   IO`print(" with actionLog : ");
   IO`print(actionLog);
   IO`print(" and Balance : ");
   IO`print(balance);
   IO`print("\n");
  )
  post MaxOneOfEachActionTypePerTime(actionLog);

functions

IsGTAll: int * set of int -> bool
IsGTAll(sv,ssv) == 
  forall i in set ssv & sv >= i;

CanAfford: StockRecord * nat -> bool
CanAfford(sr,balance) == 
  sr.Cost <= balance;
    
MaxOneOfEachActionTypePerTime: seq of ActionEvent -> bool
MaxOneOfEachActionTypePerTime(actionLog) == 
  forall x,y in set inds actionLog & 
     (x <> y and actionLog(x).Time = actionLog(y).Time) => 
     (actionLog(x).Type <> actionLog(y).Type)

end AutomatedStockBroker

class GLOBAL
types
public String = seq of char;

public EventType = <UpperLimit> | <LowerLimit> | <Peak> | <Valley> | 
<EntersNoActionRegion> | <LeavesNoActionRegion>;

public StockState = <PotentialBuy> | <Bought>;

public Event :: Type : EventType
TimeStamp : nat
Value : nat; 

public Region :: UpperValue : StockValue
  LowerValue : StockValue
inv mk_Region(p1,p2) == p1 >= p2;

public StockValue = nat;
public StockIdentifier = token;

public ActionType = <Buy> | <Sell> ;

public ActionTrigger :: Trigger : seq of EventType
Action : ActionType;

public StockRecord :: Name : StockIdentifier 
Triggers : map StockState to ActionTrigger 
NoActionReg : Region
Cost : StockValue
State : StockState

inv mk_StockRecord(p1,p2,p3,p4,p5) == p2(<PotentialBuy>).Action = <Buy> 
and p2(<Bought>).Action = <Sell>;

public ActionEvent :: Type : ActionType
  Time : nat
  StockName : StockIdentifier
  Value : StockValue;
 
values
public static testValues : map StockIdentifier to seq of Event = 
{mk_token("test") |-> [
mk_Event(<LeavesNoActionRegion>,6,5),
mk_Event(<LowerLimit>,5,8),
mk_Event(<UpperLimit>,4,12),
mk_Event(<EntersNoActionRegion>,3,11),
mk_Event(<LeavesNoActionRegion>,2,13),
mk_Event(<UpperLimit>,1,12),  
mk_Event(<EntersNoActionRegion>,0,10)
],
mk_token("test12") |-> [
mk_Event(<LeavesNoActionRegion>,6,5),
mk_Event(<LowerLimit>,5,8),
mk_Event(<UpperLimit>,4,12),
mk_Event(<EntersNoActionRegion>,3,11),
mk_Event(<LeavesNoActionRegion>,2,16),
mk_Event(<UpperLimit>,1,12),  
mk_Event(<EntersNoActionRegion>,0,10)
],
mk_token("test2") |-> [
mk_Event(<LeavesNoActionRegion>,6,5),
mk_Event(<UpperLimit>,5,8),
mk_Event(<LowerLimit>,4,8),
mk_Event(<EntersNoActionRegion>,3,11),
mk_Event(<LeavesNoActionRegion>,2,6),
mk_Event(<LowerLimit>,1,8),  
mk_Event(<EntersNoActionRegion>,0,10)
]};

end GLOBAL

class StockMarket is subclass of GLOBAL

 instance variables
  stocks : map StockIdentifier to Stock := {|->};

 operations
  public UpdateStocks:() ==> ()
  UpdateStocks() == 
   for all stock in set rng stocks do
    stock.UpdateStock();

  public AddStock:(Stock )==> ()
  AddStock(stock) == 
   stocks := {stock.GetName() |-> stock} munion stocks
  pre stock.GetName() not in set dom stocks
  post stock.GetName() in set dom stocks; 

  public RemoveStock:(Stock )==> ()
  RemoveStock(stock) == 
   stocks := {stock.GetName()} <-: stocks
  pre stock.GetName() in set dom stocks
  post stock.GetName() not in set dom stocks;

  public GetStock:(StockIdentifier)==> Stock 
  GetStock(name) == 
   return stocks(name)
  pre name in set dom stocks;

  public GetStockNames: () ==> set of StockIdentifier 
  GetStockNames() ==
   return dom stocks;
  
end StockMarket

class Stock is subclass of GLOBAL
 types
  
  public RateOfChange = <positive> | <negative> | <constant>;  
  
 instance variables
  name : StockIdentifier;
  valueHistory : seq of StockValue;
  currentRateOfChange : [RateOfChange]; 
 operations
  
  public Stock: StockIdentifier * StockValue ==> Stock
  Stock(n,startValue) == (
   valueHistory := [];
   valueHistory := [startValue] ^ valueHistory; 
   name := n;
   currentRateOfChange := nil;  
  ); 

  public UpdateStock:() ==> ()
  UpdateStock() == (
   
   currentRateOfChange :=
   cases currentRateOfChange:
    nil -> InitialRateOfChange(hd valueHistory),
    others -> NextRateOfChange(currentRateOfChange, hd valueHistory)
   end;   

   cases currentRateOfChange:
    <positive> -> valueHistory := [hd valueHistory + 1] ^ valueHistory,  
    <negative> -> valueHistory := [hd valueHistory - 1] ^ valueHistory,
    <constant> -> valueHistory := [hd valueHistory] ^ valueHistory
   end;
  )
  pre len valueHistory >= 1
  post (currentRateOfChange = <positive> => valueHistory(1) > valueHistory(2))
   and (currentRateOfChange = <negative> => valueHistory(1) < valueHistory(2))
   and (currentRateOfChange = <constant> => valueHistory(1) = valueHistory(2))
   and hd valueHistory >= 0;

  public GetName: () ==> StockIdentifier 
  GetName() == 
   return name; 

  public GetCurrentValue : () ==> StockValue 
  GetCurrentValue() == 
   return hd valueHistory; 

  public GetValueHistory : () ==> seq of StockValue 
  GetValueHistory() == (
   return valueHistory; 
  );
  
 functions
  
  InitialRateOfChange : (StockValue) -> RateOfChange
  InitialRateOfChange(sv) == 
   let r = MATH`rand(21) mod 3 
   in
    if(sv > 0)
    then
     cases r:
      0 -> <positive>,
      1 -> <negative>,
      2 -> <constant>
     end
    else 
     cases r:
      0 -> <positive>,
      1 -> <positive>,
      2 -> <constant>
     end;

  NextRateOfChange : RateOfChange * StockValue -> RateOfChange
  NextRateOfChange(roc,sv) == 
   let r = MATH`rand(10), 
    other = MakelistFromSet({x | x : RateOfChange & x <> roc and (x=<negative> => sv > 0) })   
   in
    if r >= 0 and r <= 7 and (roc = <negative> => sv > 0)  
    then roc
    else  
     other((MATH`rand(20) mod len other) + 1);

  MakelistFromSet : set of RateOfChange -> seq of RateOfChange
  MakelistFromSet(roc) ==
   if( card roc > 0) then 
    let r in set roc 
     in 
     [r] ^ MakelistFromSet(roc \ {r})
   else []

end Stock


class StockWatcher is subclass of GLOBAL
 
 instance variables
  eventHistory : seq of Event;
  stockRecord : StockRecord;
  sm : [StockMarket];
  currentlyTriggeredAction : [ActionType];
  
  inv  eventHistory(len eventHistory).Type = <EntersNoActionRegion> 
    and 
   forall e in set inds eventHistory & e <> len eventHistory => 
      (eventHistory(e).Type = <LeavesNoActionRegion> => eventHistory(e + 1).Type = <LowerLimit>
                or eventHistory(e + 1).Type = <UpperLimit>)
      and
      (eventHistory(e).Type = <EntersNoActionRegion> => eventHistory(e + 1).Type = <LeavesNoActionRegion>
                  or eventHistory(e + 1).Type = <Valley>
                  or eventHistory(e + 1).Type = <Peak>);

 operations
  public StockWatcher: StockRecord * seq of Event ==> StockWatcher
  StockWatcher(sr, predefinedEvents) == (
   eventHistory := predefinedEvents;
   sm := nil;
   stockRecord := sr;
   currentlyTriggeredAction := nil;   
  )
  pre let val = predefinedEvents(len predefinedEvents).Value 
      in 
        IsInRegion(val,sr.NoActionReg);

  public StockWatcher: StockRecord ==> StockWatcher
  StockWatcher(sr) == (
   sm := World`stockMarket;
   stockRecord := sr;
   eventHistory := [mk_Event(<EntersNoActionRegion>,0,
     sm.GetStock(stockRecord.Name).GetCurrentValue())];
   currentlyTriggeredAction := nil;   
  )
  pre (sr.Name in set World`stockMarket.GetStockNames()) 
   and
    let val = World`stockMarket.GetStock(sr.Name).GetCurrentValue() 
    in 
     IsInRegion(val,sr.NoActionReg);

  UpdateEvents : nat ==> ()
  UpdateEvents(time) == 
   let stock = sm.GetStock(stockRecord.Name)
    in
     let stockHistory = stock.GetValueHistory(), reg = stockRecord.NoActionReg, 
         l = reg.LowerValue, u = reg.UpperValue, cv = stock.GetCurrentValue() 
      in
      (if IsInRegion(hd stockHistory, reg) and
          not IsInRegion(stockHistory(2), reg)
       then eventHistory := [mk_Event(<EntersNoActionRegion>,time,cv)] ^ eventHistory
       elseif not IsInRegion(hd stockHistory, reg) and
              IsInRegion(stockHistory(2), reg)
       then eventHistory := [mk_Event(<LeavesNoActionRegion>,time,cv)] ^ eventHistory;
       
       if hd stockHistory = u and stockHistory(2)  <> u
       then eventHistory := [mk_Event(<UpperLimit>,time,cv)] ^ eventHistory
       elseif hd stockHistory = l
              and stockHistory(2) <> l
       then eventHistory := [mk_Event(<LowerLimit>,time,cv)] ^ eventHistory
       elseif not IsInRegion(hd stockHistory, reg) and IsPeak(stockHistory)
       then eventHistory := [mk_Event(<Peak>,time,cv)] ^ eventHistory
       elseif (not IsInRegion(hd stockHistory, reg)
              and IsValley(stockHistory) )
       then eventHistory := [mk_Event(<Valley>,time,cv)] ^ eventHistory;
            
       IO`print(eventHistory)
      ) 
  pre let stockHistory = sm.GetStock(stockRecord.Name).GetValueHistory() 
      in len stockHistory >= 2
  post eventHistory(len eventHistory).Type = <EntersNoActionRegion> 
    and 
   forall e in set inds eventHistory & e <> len eventHistory => 
      (eventHistory(e).Type = <LeavesNoActionRegion> => eventHistory(e + 1).Type = <LowerLimit>
                or eventHistory(e + 1).Type = <UpperLimit>)
      and
      (eventHistory(e).Type = <EntersNoActionRegion> => eventHistory(e + 1).Type = <LeavesNoActionRegion>
                  or eventHistory(e + 1).Type = <Valley>
                  or eventHistory(e + 1).Type = <Peak>);

  UpdateAction : nat ==> ()
  UpdateAction(tim) == 
   let actionTrigger = stockRecord.Triggers(stockRecord.State)
    in 
     currentlyTriggeredAction :=
        if IsActionTriggeredAtTime(tim,actionTrigger,eventHistory) and 
           not IsInRegion(GetStockValue(tim), stockRecord.NoActionReg) 
        then actionTrigger.Action
        else nil;

  public ObserveStock : nat ==> ()
  ObserveStock(time) == (
   if (World`simulate)
   then( UpdateEvents(time);)
   else skip;
 
   UpdateAction(time);
  )
  post NoActiveTriggerInNoActionRegion(GetStockValue(time),stockRecord.NoActionReg,currentlyTriggeredAction);

  public updateStockRecord : StockRecord ==> ()
  updateStockRecord(sr) == 
   stockRecord := sr;

  public GetStockValue : nat ==> StockValue
  GetStockValue(time) == 
   if World`simulate
   then return eventHistory(1).Value
   else return eventHistory(len eventHistory - time).Value
  pre len eventHistory > 0;
       
  public GetTriggeredAction : () ==> [ActionType]
  GetTriggeredAction() ==
   return currentlyTriggeredAction; 

 functions
  
  NoActiveTriggerInNoActionRegion: StockValue * Region * [ActionType]  -> bool
  NoActiveTriggerInNoActionRegion(sv,reg,at) == 
   IsInRegion(sv,reg) => at = nil;

  IsInRegion: StockValue * Region -> bool
  IsInRegion(sv,reg) == 
   let u = reg.UpperValue , l = reg.LowerValue
    in 
     sv >= l and sv <= u;
    
  IsPeak: seq of StockValue -> bool
  IsPeak(svs) == 
   let current = hd svs 
    in 
     let indicesOneAbove = {i | i in set inds svs & current+1 = svs(i) and i <> len svs} 
      in
       exists i in set indicesOneAbove & 
        forall v in set {2,...,i} & current+1 = svs(v)
        and 
        svs(i+1) = current;

  IsValley: seq of StockValue -> bool
  IsValley(svs) == 
   let current = hd svs 
    in 
     let indicesOneBelow = {i | i in set inds svs & current-1 = svs(i) and i <> len svs} 
      in
       exists i in set indicesOneBelow & 
        forall v in set {2,...,i} & current-1 = svs(v)
        and 
        svs(i+1) = current;

  FindLowestIndexFromTime: nat * seq of Event  -> nat1
  FindLowestIndexFromTime(time,events) == 
   let pastEvents = { x | x in set inds events & events(x).TimeStamp <= time  }
    in
     let i,j in set pastEvents be st (i <> j) => (events(i).TimeStamp <= events(j).TimeStamp)  
     in 
       i;

  public IsActionTriggeredAtTime: nat * ActionTrigger * seq of Event  -> bool
  IsActionTriggeredAtTime(time,action,eventHistory) == 
   let tgr = action.Trigger
    in
     let index = FindLowestIndexFromTime(time,eventHistory),
         s = eventHistory(index,...,index + len tgr - 1)
      in
      ((forall i in set inds s & s(i).Type = tgr(i))
      and (s(1).TimeStamp = time)
      and len s = len tgr)
   
end StockWatcher

class Timer 

instance variables

  currentTime : nat := 1;

values 

  stepLength : nat = 1;

operations

public 
  StepTime: () ==> ()
  StepTime() == 
    currentTime := currentTime + stepLength;

public
  GetTime: () ==> nat 
  GetTime() == return currentTime;

end Timer

class World is subclass of GLOBAL
 
values
 simTime : nat = 100; 
 actionsLimit : nat = 4;
 startCash : nat = 100;
 public static simulate : bool = false;
 
instance variables  

 public static timerRef : Timer := new Timer();

 public static stockMarket : StockMarket := new StockMarket();
 asb : AutomatedStockBroker := new AutomatedStockBroker(startCash);  
   
operations

public isFinished : () ==> bool
 isFinished() == 
    return (not len asb.GetActionLog() < actionsLimit) or 
           (not timerRef.GetTime() <= simTime);

 public Run : () ==> ()
 Run() ==
 ( 
  stockMarket.AddStock(new Stock(mk_token("test"),10));
  stockMarket.AddStock(new Stock(mk_token("test12"),10));
  stockMarket.AddStock(new Stock(mk_token("test2"),10));

  (dcl r1 : StockRecord := mk_StockRecord(mk_token("test"),
     { <PotentialBuy> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<LowerLimit>],<Buy>),
       <Bought> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<UpperLimit>],<Sell>)},
        mk_Region(12,8),10,<Bought>),
    r2 : StockRecord := mk_StockRecord(mk_token("test12"),
     { <PotentialBuy> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<LowerLimit>],<Buy>),
       <Bought> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<UpperLimit>],<Sell>)},
        mk_Region(12,8),10,<Bought>),

   r3 : StockRecord := mk_StockRecord(mk_token("test2"),
     { <PotentialBuy> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<LowerLimit>],<Buy>),
       <Bought> |-> mk_ActionTrigger([<LeavesNoActionRegion>,<UpperLimit>],<Sell>)},
        mk_Region(12,8),0,<PotentialBuy>);

   asb.AddStock(r1,1);
   asb.AddStock(r2,2);
   asb.AddStock(r3,3);
   
   while not isFinished()
   do 
   (
    IO`print("step : ");
    IO`print(timerRef.GetTime());
    IO`print("\n");
 
    stockMarket.UpdateStocks();
 
    asb.Step(timerRef.GetTime());
       timerRef.StepTime();
   );
  )
 );
functions
 public FindSmallestSeqLen: map String to seq of Event -> nat
 FindSmallestSeqLen(m) == 
 let x,y in set {len m(x) | x in set dom m} be st x <> y => x <= y in x; 

end World



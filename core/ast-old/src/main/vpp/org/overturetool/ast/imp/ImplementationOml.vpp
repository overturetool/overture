


\begin{vdm_al}
class OmlAccessDefinition is subclass of IOmlAccessDefinition
operations
  public identity: () ==> seq of char
  identity () == return "AccessDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAccessDefinition(self);

  public OmlAccessDefinition:
    (bool) *
    (bool) *
    (IOmlScope) ==> OmlAccessDefinition
  OmlAccessDefinition (p1,p2,p3) == 
    ( setAsyncAccess(p1);
      setStaticAccess(p2);
      setScope(p3) );

  public OmlAccessDefinition:
    (bool) *
    (bool) *
    (IOmlScope) *
    nat *
    nat ==> OmlAccessDefinition
  OmlAccessDefinition (p1,p2,p3,line,column) == 
    ( setAsyncAccess(p1);
      setStaticAccess(p2);
      setScope(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "async_access" in
        if fname in set dom data
        then setAsyncAccess(data(fname));
      let fname = "static_access" in
        if fname in set dom data
        then setStaticAccess(data(fname));
      let fname = "scope" in
        if fname in set dom data
        then setScope(data(fname)) );

instance variables
  private ivAsyncAccess : [bool] := nil

operations
  public getAsyncAccess: () ==> bool
  getAsyncAccess() == return ivAsyncAccess;

  public setAsyncAccess: bool ==> ()
  setAsyncAccess(parg) == ivAsyncAccess := parg;

instance variables
  private ivStaticAccess : [bool] := nil

operations
  public getStaticAccess: () ==> bool
  getStaticAccess() == return ivStaticAccess;

  public setStaticAccess: bool ==> ()
  setStaticAccess(parg) == ivStaticAccess := parg;

instance variables
  private ivScope : [IOmlScope] := nil

operations
  public getScope: () ==> IOmlScope
  getScope() == return ivScope;

  public setScope: IOmlScope ==> ()
  setScope(parg) == ivScope := parg;

end OmlAccessDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlActExpression is subclass of IOmlActExpression
operations
  public identity: () ==> seq of char
  identity () == return "ActExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitActExpression(self);

  public OmlActExpression:
    (seq of IOmlName) ==> OmlActExpression
  OmlActExpression (p1) == 
    ( setNameList(p1) );

  public OmlActExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlActExpression
  OmlActExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlActExpression
\end{vdm_al}

\begin{vdm_al}
class OmlActiveExpression is subclass of IOmlActiveExpression
operations
  public identity: () ==> seq of char
  identity () == return "ActiveExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitActiveExpression(self);

  public OmlActiveExpression:
    (seq of IOmlName) ==> OmlActiveExpression
  OmlActiveExpression (p1) == 
    ( setNameList(p1) );

  public OmlActiveExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlActiveExpression
  OmlActiveExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlActiveExpression
\end{vdm_al}

\begin{vdm_al}
class OmlAlwaysStatement is subclass of IOmlAlwaysStatement
operations
  public identity: () ==> seq of char
  identity () == return "AlwaysStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAlwaysStatement(self);

  public OmlAlwaysStatement:
    (IOmlStatement) *
    (IOmlStatement) ==> OmlAlwaysStatement
  OmlAlwaysStatement (p1,p2) == 
    ( setAlwaysPart(p1);
      setInPart(p2) );

  public OmlAlwaysStatement:
    (IOmlStatement) *
    (IOmlStatement) *
    nat *
    nat ==> OmlAlwaysStatement
  OmlAlwaysStatement (p1,p2,line,column) == 
    ( setAlwaysPart(p1);
      setInPart(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "always_part" in
        if fname in set dom data
        then setAlwaysPart(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivAlwaysPart : [IOmlStatement] := nil

operations
  public getAlwaysPart: () ==> IOmlStatement
  getAlwaysPart() == return ivAlwaysPart;

  public setAlwaysPart: IOmlStatement ==> ()
  setAlwaysPart(parg) == ivAlwaysPart := parg;

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlAlwaysStatement
\end{vdm_al}

\begin{vdm_al}
class OmlApplyExpression is subclass of IOmlApplyExpression
operations
  public identity: () ==> seq of char
  identity () == return "ApplyExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitApplyExpression(self);

  public OmlApplyExpression:
    (IOmlExpression) *
    (seq of IOmlExpression) ==> OmlApplyExpression
  OmlApplyExpression (p1,p2) == 
    ( setExpression(p1);
      setExpressionList(p2) );

  public OmlApplyExpression:
    (IOmlExpression) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlApplyExpression
  OmlApplyExpression (p1,p2,line,column) == 
    ( setExpression(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlApplyExpression
\end{vdm_al}

\begin{vdm_al}
class OmlAssignStatement is subclass of IOmlAssignStatement
operations
  public identity: () ==> seq of char
  identity () == return "AssignStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAssignStatement(self);

  public OmlAssignStatement:
    (IOmlStateDesignator) *
    (IOmlExpression) ==> OmlAssignStatement
  OmlAssignStatement (p1,p2) == 
    ( setStateDesignator(p1);
      setExpression(p2) );

  public OmlAssignStatement:
    (IOmlStateDesignator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlAssignStatement
  OmlAssignStatement (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlAssignStatement
\end{vdm_al}

\begin{vdm_al}
class OmlAssignmentDefinition is subclass of IOmlAssignmentDefinition
operations
  public identity: () ==> seq of char
  identity () == return "AssignmentDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAssignmentDefinition(self);

  public OmlAssignmentDefinition:
    (seq of char) *
    (IOmlType) *
    [IOmlExpression] ==> OmlAssignmentDefinition
  OmlAssignmentDefinition (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setExpression(p3) );

  public OmlAssignmentDefinition:
    (seq of char) *
    (IOmlType) *
    [IOmlExpression] *
    nat *
    nat ==> OmlAssignmentDefinition
  OmlAssignmentDefinition (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlAssignmentDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlAtomicStatement is subclass of IOmlAtomicStatement
operations
  public identity: () ==> seq of char
  identity () == return "AtomicStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAtomicStatement(self);

  public OmlAtomicStatement:
    (seq of IOmlAssignStatement) ==> OmlAtomicStatement
  OmlAtomicStatement (p1) == 
    ( setAssignmentList(p1) );

  public OmlAtomicStatement:
    (seq of IOmlAssignStatement) *
    nat *
    nat ==> OmlAtomicStatement
  OmlAtomicStatement (p1,line,column) == 
    ( setAssignmentList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "assignment_list" in
        if fname in set dom data
        then setAssignmentList(data(fname)) );

instance variables
  private ivAssignmentList : seq of IOmlAssignStatement := []

operations
  public getAssignmentList: () ==> seq of IOmlAssignStatement
  getAssignmentList() == return ivAssignmentList;

  public setAssignmentList: seq of IOmlAssignStatement ==> ()
  setAssignmentList(parg) == ivAssignmentList := parg;

  public addAssignmentList: IOmlNode ==> ()
  addAssignmentList (parg) == ivAssignmentList := ivAssignmentList ^ [parg];

end OmlAtomicStatement
\end{vdm_al}

\begin{vdm_al}
class OmlBinaryExpression is subclass of IOmlBinaryExpression
operations
  public identity: () ==> seq of char
  identity () == return "BinaryExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBinaryExpression(self);

  public OmlBinaryExpression:
    (IOmlExpression) *
    (IOmlBinaryOperator) *
    (IOmlExpression) ==> OmlBinaryExpression
  OmlBinaryExpression (p1,p2,p3) == 
    ( setLhsExpression(p1);
      setOperator(p2);
      setRhsExpression(p3) );

  public OmlBinaryExpression:
    (IOmlExpression) *
    (IOmlBinaryOperator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlBinaryExpression
  OmlBinaryExpression (p1,p2,p3,line,column) == 
    ( setLhsExpression(p1);
      setOperator(p2);
      setRhsExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "operator" in
        if fname in set dom data
        then setOperator(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivOperator : [IOmlBinaryOperator] := nil

operations
  public getOperator: () ==> IOmlBinaryOperator
  getOperator() == return ivOperator;

  public setOperator: IOmlBinaryOperator ==> ()
  setOperator(parg) == ivOperator := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlBinaryExpression
\end{vdm_al}

\begin{vdm_al}
class OmlBinaryOperator is subclass of IOmlBinaryOperator
operations
  public identity: () ==> seq of char
  identity () == return "BinaryOperator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBinaryOperator(self);

  public OmlBinaryOperator: nat ==> OmlBinaryOperator
  OmlBinaryOperator (pv) == setValue(pv);

  public OmlBinaryOperator: nat * nat * nat ==> OmlBinaryOperator
  OmlBinaryOperator (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlBinaryOperatorQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlBinaryOperatorQuotes`getQuoteName(val)
    pre val <> nil;

end OmlBinaryOperator
\end{vdm_al}
\begin{vdm_al}
class OmlBinaryOperatorQuotes
instance variables
  static public IQMODIFY : nat := 0;
  static public IQGE : nat := 1;
  static public IQLT : nat := 2;
  static public IQPSUBSET : nat := 3;
  static public IQMOD : nat := 4;
  static public IQMAPDOMRESBY : nat := 5;
  static public IQINTER : nat := 6;
  static public IQCOMP : nat := 7;
  static public IQMINUS : nat := 8;
  static public IQREM : nat := 9;
  static public IQAND : nat := 10;
  static public IQUNION : nat := 11;
  static public IQINSET : nat := 12;
  static public IQEQUIV : nat := 13;
  static public IQMAPRNGRESTO : nat := 14;
  static public IQITERATE : nat := 15;
  static public IQSUBSET : nat := 16;
  static public IQMAPRNGRESBY : nat := 17;
  static public IQTUPSEL : nat := 18;
  static public IQNOTINSET : nat := 19;
  static public IQMULTIPLY : nat := 20;
  static public IQIMPLY : nat := 21;
  static public IQOR : nat := 22;
  static public IQGT : nat := 23;
  static public IQPLUS : nat := 24;
  static public IQMUNION : nat := 25;
  static public IQMAPDOMRESTO : nat := 26;
  static public IQEQ : nat := 27;
  static public IQDIV : nat := 28;
  static public IQDIFFERENCE : nat := 29;
  static public IQCONC : nat := 30;
  static public IQLE : nat := 31;
  static public IQDIVIDE : nat := 32;
  static public IQNE : nat := 33;

  static private qmap : map nat to seq of char :=
    { IQMODIFY |-> "<MODIFY>",
      IQGE |-> "<GE>",
      IQLT |-> "<LT>",
      IQPSUBSET |-> "<PSUBSET>",
      IQMOD |-> "<MOD>",
      IQMAPDOMRESBY |-> "<MAPDOMRESBY>",
      IQINTER |-> "<INTER>",
      IQCOMP |-> "<COMP>",
      IQMINUS |-> "<MINUS>",
      IQREM |-> "<REM>",
      IQAND |-> "<AND>",
      IQUNION |-> "<UNION>",
      IQINSET |-> "<INSET>",
      IQEQUIV |-> "<EQUIV>",
      IQMAPRNGRESTO |-> "<MAPRNGRESTO>",
      IQITERATE |-> "<ITERATE>",
      IQSUBSET |-> "<SUBSET>",
      IQMAPRNGRESBY |-> "<MAPRNGRESBY>",
      IQTUPSEL |-> "<TUPSEL>",
      IQNOTINSET |-> "<NOTINSET>",
      IQMULTIPLY |-> "<MULTIPLY>",
      IQIMPLY |-> "<IMPLY>",
      IQOR |-> "<OR>",
      IQGT |-> "<GT>",
      IQPLUS |-> "<PLUS>",
      IQMUNION |-> "<MUNION>",
      IQMAPDOMRESTO |-> "<MAPDOMRESTO>",
      IQEQ |-> "<EQ>",
      IQDIV |-> "<DIV>",
      IQDIFFERENCE |-> "<DIFFERENCE>",
      IQCONC |-> "<CONC>",
      IQLE |-> "<LE>",
      IQDIVIDE |-> "<DIVIDE>",
      IQNE |-> "<NE>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlBinaryOperatorQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlBind is subclass of IOmlBind
operations
  public identity: () ==> seq of char
  identity () == return "Bind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBind(self);

end OmlBind
\end{vdm_al}
\begin{vdm_al}
class OmlBlockStatement is subclass of IOmlBlockStatement
operations
  public identity: () ==> seq of char
  identity () == return "BlockStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBlockStatement(self);

  public OmlBlockStatement:
    (seq of IOmlDclStatement) *
    (seq of IOmlStatement) ==> OmlBlockStatement
  OmlBlockStatement (p1,p2) == 
    ( setDclStatementList(p1);
      setStatementList(p2) );

  public OmlBlockStatement:
    (seq of IOmlDclStatement) *
    (seq of IOmlStatement) *
    nat *
    nat ==> OmlBlockStatement
  OmlBlockStatement (p1,p2,line,column) == 
    ( setDclStatementList(p1);
      setStatementList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dcl_statement_list" in
        if fname in set dom data
        then setDclStatementList(data(fname));
      let fname = "statement_list" in
        if fname in set dom data
        then setStatementList(data(fname)) );

instance variables
  private ivDclStatementList : seq of IOmlDclStatement := []

operations
  public getDclStatementList: () ==> seq of IOmlDclStatement
  getDclStatementList() == return ivDclStatementList;

  public setDclStatementList: seq of IOmlDclStatement ==> ()
  setDclStatementList(parg) == ivDclStatementList := parg;

  public addDclStatementList: IOmlNode ==> ()
  addDclStatementList (parg) == ivDclStatementList := ivDclStatementList ^ [parg];

instance variables
  private ivStatementList : seq of IOmlStatement := []

operations
  public getStatementList: () ==> seq of IOmlStatement
  getStatementList() == return ivStatementList;

  public setStatementList: seq of IOmlStatement ==> ()
  setStatementList(parg) == ivStatementList := parg;

  public addStatementList: IOmlNode ==> ()
  addStatementList (parg) == ivStatementList := ivStatementList ^ [parg];

end OmlBlockStatement
\end{vdm_al}

\begin{vdm_al}
class OmlBoolType is subclass of IOmlBoolType
operations
  public identity: () ==> seq of char
  identity () == return "BoolType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBoolType(self);

  public OmlBoolType:
    () ==> OmlBoolType
  OmlBoolType () == 
    skip;

  public OmlBoolType:
    nat *
    nat ==> OmlBoolType
  OmlBoolType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlBoolType
\end{vdm_al}

\begin{vdm_al}
class OmlBooleanLiteral is subclass of IOmlBooleanLiteral
operations
  public identity: () ==> seq of char
  identity () == return "BooleanLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBooleanLiteral(self);

  public OmlBooleanLiteral:
    (bool) ==> OmlBooleanLiteral
  OmlBooleanLiteral (p1) == 
    ( setVal(p1) );

  public OmlBooleanLiteral:
    (bool) *
    nat *
    nat ==> OmlBooleanLiteral
  OmlBooleanLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [bool] := nil

operations
  public getVal: () ==> bool
  getVal() == return ivVal;

  public setVal: bool ==> ()
  setVal(parg) == ivVal := parg;

end OmlBooleanLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlBracketedExpression is subclass of IOmlBracketedExpression
operations
  public identity: () ==> seq of char
  identity () == return "BracketedExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBracketedExpression(self);

  public OmlBracketedExpression:
    (IOmlExpression) ==> OmlBracketedExpression
  OmlBracketedExpression (p1) == 
    ( setExpression(p1) );

  public OmlBracketedExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlBracketedExpression
  OmlBracketedExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlBracketedExpression
\end{vdm_al}

\begin{vdm_al}
class OmlBracketedType is subclass of IOmlBracketedType
operations
  public identity: () ==> seq of char
  identity () == return "BracketedType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBracketedType(self);

  public OmlBracketedType:
    (IOmlType) ==> OmlBracketedType
  OmlBracketedType (p1) == 
    ( setType(p1) );

  public OmlBracketedType:
    (IOmlType) *
    nat *
    nat ==> OmlBracketedType
  OmlBracketedType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlBracketedType
\end{vdm_al}

\begin{vdm_al}
class OmlCallStatement is subclass of IOmlCallStatement
operations
  public identity: () ==> seq of char
  identity () == return "CallStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCallStatement(self);

  public OmlCallStatement:
    [IOmlObjectDesignator] *
    (IOmlName) *
    (seq of IOmlExpression) ==> OmlCallStatement
  OmlCallStatement (p1,p2,p3) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setExpressionList(p3) );

  public OmlCallStatement:
    [IOmlObjectDesignator] *
    (IOmlName) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlCallStatement
  OmlCallStatement (p1,p2,p3,line,column) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setExpressionList(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator
    pre hasObjectDesignator();

  public hasObjectDesignator: () ==> bool
  hasObjectDesignator () == return ivObjectDesignator <> nil;

  public setObjectDesignator: [ IOmlObjectDesignator ] ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlCallStatement
\end{vdm_al}

\begin{vdm_al}
class OmlCasesExpression is subclass of IOmlCasesExpression
operations
  public identity: () ==> seq of char
  identity () == return "CasesExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesExpression(self);

  public OmlCasesExpression:
    (IOmlExpression) *
    (seq of IOmlCasesExpressionAlternative) *
    [IOmlExpression] ==> OmlCasesExpression
  OmlCasesExpression (p1,p2,p3) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersExpression(p3) );

  public OmlCasesExpression:
    (IOmlExpression) *
    (seq of IOmlCasesExpressionAlternative) *
    [IOmlExpression] *
    nat *
    nat ==> OmlCasesExpression
  OmlCasesExpression (p1,p2,p3,line,column) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "match_expression" in
        if fname in set dom data
        then setMatchExpression(data(fname));
      let fname = "alternative_list" in
        if fname in set dom data
        then setAlternativeList(data(fname));
      let fname = "others_expression" in
        if fname in set dom data
        then setOthersExpression(data(fname)) );

instance variables
  private ivMatchExpression : [IOmlExpression] := nil

operations
  public getMatchExpression: () ==> IOmlExpression
  getMatchExpression() == return ivMatchExpression;

  public setMatchExpression: IOmlExpression ==> ()
  setMatchExpression(parg) == ivMatchExpression := parg;

instance variables
  private ivAlternativeList : seq of IOmlCasesExpressionAlternative := []

operations
  public getAlternativeList: () ==> seq of IOmlCasesExpressionAlternative
  getAlternativeList() == return ivAlternativeList;

  public setAlternativeList: seq of IOmlCasesExpressionAlternative ==> ()
  setAlternativeList(parg) == ivAlternativeList := parg;

  public addAlternativeList: IOmlNode ==> ()
  addAlternativeList (parg) == ivAlternativeList := ivAlternativeList ^ [parg];

instance variables
  private ivOthersExpression : [IOmlExpression] := nil

operations
  public getOthersExpression: () ==> IOmlExpression
  getOthersExpression() == return ivOthersExpression
    pre hasOthersExpression();

  public hasOthersExpression: () ==> bool
  hasOthersExpression () == return ivOthersExpression <> nil;

  public setOthersExpression: [ IOmlExpression ] ==> ()
  setOthersExpression(parg) == ivOthersExpression := parg;

end OmlCasesExpression
\end{vdm_al}

\begin{vdm_al}
class OmlCasesExpressionAlternative is subclass of IOmlCasesExpressionAlternative
operations
  public identity: () ==> seq of char
  identity () == return "CasesExpressionAlternative";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesExpressionAlternative(self);

  public OmlCasesExpressionAlternative:
    (seq of IOmlPattern) *
    (IOmlExpression) ==> OmlCasesExpressionAlternative
  OmlCasesExpressionAlternative (p1,p2) == 
    ( setPatternList(p1);
      setExpression(p2) );

  public OmlCasesExpressionAlternative:
    (seq of IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlCasesExpressionAlternative
  OmlCasesExpressionAlternative (p1,p2,line,column) == 
    ( setPatternList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlCasesExpressionAlternative
\end{vdm_al}

\begin{vdm_al}
class OmlCasesStatement is subclass of IOmlCasesStatement
operations
  public identity: () ==> seq of char
  identity () == return "CasesStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesStatement(self);

  public OmlCasesStatement:
    (IOmlExpression) *
    (seq of IOmlCasesStatementAlternative) *
    [IOmlStatement] ==> OmlCasesStatement
  OmlCasesStatement (p1,p2,p3) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersStatement(p3) );

  public OmlCasesStatement:
    (IOmlExpression) *
    (seq of IOmlCasesStatementAlternative) *
    [IOmlStatement] *
    nat *
    nat ==> OmlCasesStatement
  OmlCasesStatement (p1,p2,p3,line,column) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "match_expression" in
        if fname in set dom data
        then setMatchExpression(data(fname));
      let fname = "alternative_list" in
        if fname in set dom data
        then setAlternativeList(data(fname));
      let fname = "others_statement" in
        if fname in set dom data
        then setOthersStatement(data(fname)) );

instance variables
  private ivMatchExpression : [IOmlExpression] := nil

operations
  public getMatchExpression: () ==> IOmlExpression
  getMatchExpression() == return ivMatchExpression;

  public setMatchExpression: IOmlExpression ==> ()
  setMatchExpression(parg) == ivMatchExpression := parg;

instance variables
  private ivAlternativeList : seq of IOmlCasesStatementAlternative := []

operations
  public getAlternativeList: () ==> seq of IOmlCasesStatementAlternative
  getAlternativeList() == return ivAlternativeList;

  public setAlternativeList: seq of IOmlCasesStatementAlternative ==> ()
  setAlternativeList(parg) == ivAlternativeList := parg;

  public addAlternativeList: IOmlNode ==> ()
  addAlternativeList (parg) == ivAlternativeList := ivAlternativeList ^ [parg];

instance variables
  private ivOthersStatement : [IOmlStatement] := nil

operations
  public getOthersStatement: () ==> IOmlStatement
  getOthersStatement() == return ivOthersStatement
    pre hasOthersStatement();

  public hasOthersStatement: () ==> bool
  hasOthersStatement () == return ivOthersStatement <> nil;

  public setOthersStatement: [ IOmlStatement ] ==> ()
  setOthersStatement(parg) == ivOthersStatement := parg;

end OmlCasesStatement
\end{vdm_al}

\begin{vdm_al}
class OmlCasesStatementAlternative is subclass of IOmlCasesStatementAlternative
operations
  public identity: () ==> seq of char
  identity () == return "CasesStatementAlternative";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesStatementAlternative(self);

  public OmlCasesStatementAlternative:
    (seq of IOmlPattern) *
    (IOmlStatement) ==> OmlCasesStatementAlternative
  OmlCasesStatementAlternative (p1,p2) == 
    ( setPatternList(p1);
      setStatement(p2) );

  public OmlCasesStatementAlternative:
    (seq of IOmlPattern) *
    (IOmlStatement) *
    nat *
    nat ==> OmlCasesStatementAlternative
  OmlCasesStatementAlternative (p1,p2,line,column) == 
    ( setPatternList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlCasesStatementAlternative
\end{vdm_al}

\begin{vdm_al}
class OmlCharType is subclass of IOmlCharType
operations
  public identity: () ==> seq of char
  identity () == return "CharType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCharType(self);

  public OmlCharType:
    () ==> OmlCharType
  OmlCharType () == 
    skip;

  public OmlCharType:
    nat *
    nat ==> OmlCharType
  OmlCharType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlCharType
\end{vdm_al}

\begin{vdm_al}
class OmlCharacterLiteral is subclass of IOmlCharacterLiteral
operations
  public identity: () ==> seq of char
  identity () == return "CharacterLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCharacterLiteral(self);

  public OmlCharacterLiteral:
    (char) ==> OmlCharacterLiteral
  OmlCharacterLiteral (p1) == 
    ( setVal(p1) );

  public OmlCharacterLiteral:
    (char) *
    nat *
    nat ==> OmlCharacterLiteral
  OmlCharacterLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [char] := nil

operations
  public getVal: () ==> char
  getVal() == return ivVal;

  public setVal: char ==> ()
  setVal(parg) == ivVal := parg;

end OmlCharacterLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlClass is subclass of IOmlClass
operations
  public identity: () ==> seq of char
  identity () == return "Class";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClass(self);

  public OmlClass:
    (seq of char) *
    (seq of IOmlType) *
    [IOmlInheritanceClause] *
    (seq of IOmlDefinitionBlock) *
    (bool) ==> OmlClass
  OmlClass (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setGenericTypes(p2);
      setInheritanceClause(p3);
      setClassBody(p4);
      setSystemSpec(p5) );

  public OmlClass:
    (seq of char) *
    (seq of IOmlType) *
    [IOmlInheritanceClause] *
    (seq of IOmlDefinitionBlock) *
    (bool) *
    nat *
    nat ==> OmlClass
  OmlClass (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setGenericTypes(p2);
      setInheritanceClause(p3);
      setClassBody(p4);
      setSystemSpec(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname));
      let fname = "inheritance_clause" in
        if fname in set dom data
        then setInheritanceClause(data(fname));
      let fname = "class_body" in
        if fname in set dom data
        then setClassBody(data(fname));
      let fname = "system_spec" in
        if fname in set dom data
        then setSystemSpec(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

instance variables
  private ivInheritanceClause : [IOmlInheritanceClause] := nil

operations
  public getInheritanceClause: () ==> IOmlInheritanceClause
  getInheritanceClause() == return ivInheritanceClause
    pre hasInheritanceClause();

  public hasInheritanceClause: () ==> bool
  hasInheritanceClause () == return ivInheritanceClause <> nil;

  public setInheritanceClause: [ IOmlInheritanceClause ] ==> ()
  setInheritanceClause(parg) == ivInheritanceClause := parg;

instance variables
  private ivClassBody : seq of IOmlDefinitionBlock := []

operations
  public getClassBody: () ==> seq of IOmlDefinitionBlock
  getClassBody() == return ivClassBody;

  public setClassBody: seq of IOmlDefinitionBlock ==> ()
  setClassBody(parg) == ivClassBody := parg;

  public addClassBody: IOmlNode ==> ()
  addClassBody (parg) == ivClassBody := ivClassBody ^ [parg];

instance variables
  private ivSystemSpec : [bool] := nil

operations
  public getSystemSpec: () ==> bool
  getSystemSpec() == return ivSystemSpec;

  public setSystemSpec: bool ==> ()
  setSystemSpec(parg) == ivSystemSpec := parg;

end OmlClass
\end{vdm_al}

\begin{vdm_al}
class OmlClassTypeInstantiation is subclass of IOmlClassTypeInstantiation
operations
  public identity: () ==> seq of char
  identity () == return "ClassTypeInstantiation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClassTypeInstantiation(self);

  public OmlClassTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) ==> OmlClassTypeInstantiation
  OmlClassTypeInstantiation (p1,p2) == 
    ( setName(p1);
      setGenericTypes(p2) );

  public OmlClassTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) *
    nat *
    nat ==> OmlClassTypeInstantiation
  OmlClassTypeInstantiation (p1,p2,line,column) == 
    ( setName(p1);
      setGenericTypes(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

end OmlClassTypeInstantiation
\end{vdm_al}

\begin{vdm_al}
class OmlComplexType is subclass of IOmlComplexType
operations
  public identity: () ==> seq of char
  identity () == return "ComplexType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitComplexType(self);

  public OmlComplexType:
    (seq of char) *
    (seq of IOmlField) *
    [IOmlInvariant] ==> OmlComplexType
  OmlComplexType (p1,p2,p3) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setInvariant(p3) );

  public OmlComplexType:
    (seq of char) *
    (seq of IOmlField) *
    [IOmlInvariant] *
    nat *
    nat ==> OmlComplexType
  OmlComplexType (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setInvariant(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "field_list" in
        if fname in set dom data
        then setFieldList(data(fname));
      let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivFieldList : seq of IOmlField := []

operations
  public getFieldList: () ==> seq of IOmlField
  getFieldList() == return ivFieldList;

  public setFieldList: seq of IOmlField ==> ()
  setFieldList(parg) == ivFieldList := parg;

  public addFieldList: IOmlNode ==> ()
  addFieldList (parg) == ivFieldList := ivFieldList ^ [parg];

instance variables
  private ivInvariant : [IOmlInvariant] := nil

operations
  public getInvariant: () ==> IOmlInvariant
  getInvariant() == return ivInvariant
    pre hasInvariant();

  public hasInvariant: () ==> bool
  hasInvariant () == return ivInvariant <> nil;

  public setInvariant: [ IOmlInvariant ] ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlComplexType
\end{vdm_al}

\begin{vdm_al}
class OmlCompositeType is subclass of IOmlCompositeType
operations
  public identity: () ==> seq of char
  identity () == return "CompositeType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCompositeType(self);

  public OmlCompositeType:
    (seq of char) *
    (seq of IOmlField) ==> OmlCompositeType
  OmlCompositeType (p1,p2) == 
    ( setIdentifier(p1);
      setFieldList(p2) );

  public OmlCompositeType:
    (seq of char) *
    (seq of IOmlField) *
    nat *
    nat ==> OmlCompositeType
  OmlCompositeType (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "field_list" in
        if fname in set dom data
        then setFieldList(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivFieldList : seq of IOmlField := []

operations
  public getFieldList: () ==> seq of IOmlField
  getFieldList() == return ivFieldList;

  public setFieldList: seq of IOmlField ==> ()
  setFieldList(parg) == ivFieldList := parg;

  public addFieldList: IOmlNode ==> ()
  addFieldList (parg) == ivFieldList := ivFieldList ^ [parg];

end OmlCompositeType
\end{vdm_al}

\begin{vdm_al}
class OmlCyclesStatement is subclass of IOmlCyclesStatement
operations
  public identity: () ==> seq of char
  identity () == return "CyclesStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCyclesStatement(self);

  public OmlCyclesStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) ==> OmlCyclesStatement
  OmlCyclesStatement (p1,p2) == 
    ( setCyclesExpression(p1);
      setStatement(p2) );

  public OmlCyclesStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlCyclesStatement
  OmlCyclesStatement (p1,p2,line,column) == 
    ( setCyclesExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "cycles_expression" in
        if fname in set dom data
        then setCyclesExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivCyclesExpression : seq of IOmlExpression := []

operations
  public getCyclesExpression: () ==> seq of IOmlExpression
  getCyclesExpression() == return ivCyclesExpression;

  public setCyclesExpression: seq of IOmlExpression ==> ()
  setCyclesExpression(parg) == ivCyclesExpression := parg;

  public addCyclesExpression: IOmlNode ==> ()
  addCyclesExpression (parg) == ivCyclesExpression := ivCyclesExpression ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlCyclesStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDclStatement is subclass of IOmlDclStatement
operations
  public identity: () ==> seq of char
  identity () == return "DclStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDclStatement(self);

  public OmlDclStatement:
    (seq of IOmlAssignmentDefinition) ==> OmlDclStatement
  OmlDclStatement (p1) == 
    ( setDefinitionList(p1) );

  public OmlDclStatement:
    (seq of IOmlAssignmentDefinition) *
    nat *
    nat ==> OmlDclStatement
  OmlDclStatement (p1,line,column) == 
    ( setDefinitionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlAssignmentDefinition := []

operations
  public getDefinitionList: () ==> seq of IOmlAssignmentDefinition
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlAssignmentDefinition ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

end OmlDclStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDefExpression is subclass of IOmlDefExpression
operations
  public identity: () ==> seq of char
  identity () == return "DefExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefExpression(self);

  public OmlDefExpression:
    (seq of IOmlPatternBindExpression) *
    (IOmlExpression) ==> OmlDefExpression
  OmlDefExpression (p1,p2) == 
    ( setPatternBindList(p1);
      setExpression(p2) );

  public OmlDefExpression:
    (seq of IOmlPatternBindExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlDefExpression
  OmlDefExpression (p1,p2,line,column) == 
    ( setPatternBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind_list" in
        if fname in set dom data
        then setPatternBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBindList : seq of IOmlPatternBindExpression := []

operations
  public getPatternBindList: () ==> seq of IOmlPatternBindExpression
  getPatternBindList() == return ivPatternBindList;

  public setPatternBindList: seq of IOmlPatternBindExpression ==> ()
  setPatternBindList(parg) == ivPatternBindList := parg;

  public addPatternBindList: IOmlNode ==> ()
  addPatternBindList (parg) == ivPatternBindList := ivPatternBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlDefExpression
\end{vdm_al}

\begin{vdm_al}
class OmlDefStatement is subclass of IOmlDefStatement
operations
  public identity: () ==> seq of char
  identity () == return "DefStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefStatement(self);

  public OmlDefStatement:
    (seq of IOmlEqualsDefinition) *
    (IOmlStatement) ==> OmlDefStatement
  OmlDefStatement (p1,p2) == 
    ( setDefinitionList(p1);
      setStatement(p2) );

  public OmlDefStatement:
    (seq of IOmlEqualsDefinition) *
    (IOmlStatement) *
    nat *
    nat ==> OmlDefStatement
  OmlDefStatement (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlEqualsDefinition := []

operations
  public getDefinitionList: () ==> seq of IOmlEqualsDefinition
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlEqualsDefinition ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlDefStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDefinitionBlock is subclass of IOmlDefinitionBlock
operations
  public identity: () ==> seq of char
  identity () == return "DefinitionBlock";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefinitionBlock(self);

end OmlDefinitionBlock
\end{vdm_al}
\begin{vdm_al}
class OmlDocument is subclass of IOmlDocument

instance variables
  private ivFilename : seq of char := []

operations
  public getFilename: () ==> seq of char
  getFilename () == return ivFilename;

  public setFilename: seq of char ==> ()
  setFilename (pfilename) == ivFilename := pfilename;

instance variables
  private ivTopNode : [ IOmlNode ] := nil

operations
  public hasSpecifications: () ==> bool
  hasSpecifications () == return isofclass(IOmlSpecifications,ivTopNode);

  public getSpecifications: () ==> IOmlSpecifications
  getSpecifications () == return ivTopNode
    pre hasSpecifications();

  public setSpecifications: IOmlSpecifications ==> ()
  setSpecifications (pNode) == ivTopNode := pNode
    pre ivTopNode = nil;

  public hasExpression: () ==> bool
  hasExpression () == return isofclass(IOmlExpression,ivTopNode);

  public getExpression: () ==> IOmlExpression
  getExpression () == return ivTopNode
    pre hasExpression();

  public setExpression: IOmlExpression ==> ()
  setExpression (pNode) == ivTopNode := pNode
    pre ivTopNode = nil;

instance variables
  private ivLexems : seq of IOmlLexem := []

operations
  public getLexems : () ==> seq of IOmlLexem
  getLexems () == return ivLexems;

  public setLexems : seq of IOmlLexem ==> ()
  setLexems (plexems) == ivLexems := plexems;

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDocument(self);

  public toVdmSlValue: () ==> seq of char
  toVdmSlValue () ==
    ( dcl visitor : VdmSlVisitor := new VdmSlVisitor();
      accept(visitor);
      return visitor.result );

  public toVdmPpValue: () ==> seq of char
  toVdmPpValue () ==
    ( dcl visitor : VdmPpVisitor := new VdmPpVisitor();
      accept(visitor);
      return visitor.result );

  public OmlDocument: seq of char * IOmlNode * seq of IOmlLexem ==> OmlDocument
  OmlDocument (pfilename, pnode, plexems) ==
    ( setFilename(pfilename);
      ivTopNode := pnode;
      setLexems(plexems) )
    pre isofclass(IOmlSpecifications,pnode) or isofclass(IOmlExpression,pnode)

end OmlDocument
\end{vdm_al}
\begin{vdm_al}
class OmlDontCarePattern is subclass of IOmlDontCarePattern
operations
  public identity: () ==> seq of char
  identity () == return "DontCarePattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDontCarePattern(self);

  public OmlDontCarePattern:
    () ==> OmlDontCarePattern
  OmlDontCarePattern () == 
    skip;

  public OmlDontCarePattern:
    nat *
    nat ==> OmlDontCarePattern
  OmlDontCarePattern (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlDontCarePattern
\end{vdm_al}

\begin{vdm_al}
class OmlDurationStatement is subclass of IOmlDurationStatement
operations
  public identity: () ==> seq of char
  identity () == return "DurationStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDurationStatement(self);

  public OmlDurationStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) ==> OmlDurationStatement
  OmlDurationStatement (p1,p2) == 
    ( setDurationExpression(p1);
      setStatement(p2) );

  public OmlDurationStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlDurationStatement
  OmlDurationStatement (p1,p2,line,column) == 
    ( setDurationExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "duration_expression" in
        if fname in set dom data
        then setDurationExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDurationExpression : seq of IOmlExpression := []

operations
  public getDurationExpression: () ==> seq of IOmlExpression
  getDurationExpression() == return ivDurationExpression;

  public setDurationExpression: seq of IOmlExpression ==> ()
  setDurationExpression(parg) == ivDurationExpression := parg;

  public addDurationExpression: IOmlNode ==> ()
  addDurationExpression (parg) == ivDurationExpression := ivDurationExpression ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlDurationStatement
\end{vdm_al}

\begin{vdm_al}
class OmlElseIfExpression is subclass of IOmlElseIfExpression
operations
  public identity: () ==> seq of char
  identity () == return "ElseIfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitElseIfExpression(self);

  public OmlElseIfExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlElseIfExpression
  OmlElseIfExpression (p1,p2) == 
    ( setElseifExpression(p1);
      setThenExpression(p2) );

  public OmlElseIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlElseIfExpression
  OmlElseIfExpression (p1,p2,line,column) == 
    ( setElseifExpression(p1);
      setThenExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "elseif_expression" in
        if fname in set dom data
        then setElseifExpression(data(fname));
      let fname = "then_expression" in
        if fname in set dom data
        then setThenExpression(data(fname)) );

instance variables
  private ivElseifExpression : [IOmlExpression] := nil

operations
  public getElseifExpression: () ==> IOmlExpression
  getElseifExpression() == return ivElseifExpression;

  public setElseifExpression: IOmlExpression ==> ()
  setElseifExpression(parg) == ivElseifExpression := parg;

instance variables
  private ivThenExpression : [IOmlExpression] := nil

operations
  public getThenExpression: () ==> IOmlExpression
  getThenExpression() == return ivThenExpression;

  public setThenExpression: IOmlExpression ==> ()
  setThenExpression(parg) == ivThenExpression := parg;

end OmlElseIfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlElseIfStatement is subclass of IOmlElseIfStatement
operations
  public identity: () ==> seq of char
  identity () == return "ElseIfStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitElseIfStatement(self);

  public OmlElseIfStatement:
    (IOmlExpression) *
    (IOmlStatement) ==> OmlElseIfStatement
  OmlElseIfStatement (p1,p2) == 
    ( setExpression(p1);
      setStatement(p2) );

  public OmlElseIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlElseIfStatement
  OmlElseIfStatement (p1,p2,line,column) == 
    ( setExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlElseIfStatement
\end{vdm_al}

\begin{vdm_al}
class OmlEmptyType is subclass of IOmlEmptyType
operations
  public identity: () ==> seq of char
  identity () == return "EmptyType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitEmptyType(self);

  public OmlEmptyType:
    () ==> OmlEmptyType
  OmlEmptyType () == 
    skip;

  public OmlEmptyType:
    nat *
    nat ==> OmlEmptyType
  OmlEmptyType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlEmptyType
\end{vdm_al}

\begin{vdm_al}
class OmlEqualsDefinition is subclass of IOmlEqualsDefinition
operations
  public identity: () ==> seq of char
  identity () == return "EqualsDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitEqualsDefinition(self);

  public OmlEqualsDefinition:
    (IOmlPatternBind) *
    (IOmlExpression) ==> OmlEqualsDefinition
  OmlEqualsDefinition (p1,p2) == 
    ( setPatternBind(p1);
      setExpression(p2) );

  public OmlEqualsDefinition:
    (IOmlPatternBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlEqualsDefinition
  OmlEqualsDefinition (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlEqualsDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlError is subclass of IOmlError
operations
  public identity: () ==> seq of char
  identity () == return "Error";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitError(self);

  public OmlError:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) ==> OmlError
  OmlError (p1,p2,p3) == 
    ( setIdentifier(p1);
      setLhs(p2);
      setRhs(p3) );

  public OmlError:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlError
  OmlError (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setLhs(p2);
      setRhs(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "lhs" in
        if fname in set dom data
        then setLhs(data(fname));
      let fname = "rhs" in
        if fname in set dom data
        then setRhs(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivLhs : [IOmlExpression] := nil

operations
  public getLhs: () ==> IOmlExpression
  getLhs() == return ivLhs;

  public setLhs: IOmlExpression ==> ()
  setLhs(parg) == ivLhs := parg;

instance variables
  private ivRhs : [IOmlExpression] := nil

operations
  public getRhs: () ==> IOmlExpression
  getRhs() == return ivRhs;

  public setRhs: IOmlExpression ==> ()
  setRhs(parg) == ivRhs := parg;

end OmlError
\end{vdm_al}

\begin{vdm_al}
class OmlErrorStatement is subclass of IOmlErrorStatement
operations
  public identity: () ==> seq of char
  identity () == return "ErrorStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitErrorStatement(self);

  public OmlErrorStatement:
    () ==> OmlErrorStatement
  OmlErrorStatement () == 
    skip;

  public OmlErrorStatement:
    nat *
    nat ==> OmlErrorStatement
  OmlErrorStatement (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlErrorStatement
\end{vdm_al}

\begin{vdm_al}
class OmlExceptions is subclass of IOmlExceptions
operations
  public identity: () ==> seq of char
  identity () == return "Exceptions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExceptions(self);

  public OmlExceptions:
    (seq of IOmlError) ==> OmlExceptions
  OmlExceptions (p1) == 
    ( setErrorList(p1) );

  public OmlExceptions:
    (seq of IOmlError) *
    nat *
    nat ==> OmlExceptions
  OmlExceptions (p1,line,column) == 
    ( setErrorList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "error_list" in
        if fname in set dom data
        then setErrorList(data(fname)) );

instance variables
  private ivErrorList : seq of IOmlError := []

operations
  public getErrorList: () ==> seq of IOmlError
  getErrorList() == return ivErrorList;

  public setErrorList: seq of IOmlError ==> ()
  setErrorList(parg) == ivErrorList := parg;

  public addErrorList: IOmlNode ==> ()
  addErrorList (parg) == ivErrorList := ivErrorList ^ [parg];

end OmlExceptions
\end{vdm_al}

\begin{vdm_al}
class OmlExistsExpression is subclass of IOmlExistsExpression
operations
  public identity: () ==> seq of char
  identity () == return "ExistsExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExistsExpression(self);

  public OmlExistsExpression:
    (seq of IOmlBind) *
    (IOmlExpression) ==> OmlExistsExpression
  OmlExistsExpression (p1,p2) == 
    ( setBindList(p1);
      setExpression(p2) );

  public OmlExistsExpression:
    (seq of IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlExistsExpression
  OmlExistsExpression (p1,p2,line,column) == 
    ( setBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExistsExpression
\end{vdm_al}

\begin{vdm_al}
class OmlExistsUniqueExpression is subclass of IOmlExistsUniqueExpression
operations
  public identity: () ==> seq of char
  identity () == return "ExistsUniqueExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExistsUniqueExpression(self);

  public OmlExistsUniqueExpression:
    (IOmlBind) *
    (IOmlExpression) ==> OmlExistsUniqueExpression
  OmlExistsUniqueExpression (p1,p2) == 
    ( setBind(p1);
      setExpression(p2) );

  public OmlExistsUniqueExpression:
    (IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlExistsUniqueExpression
  OmlExistsUniqueExpression (p1,p2,line,column) == 
    ( setBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExistsUniqueExpression
\end{vdm_al}

\begin{vdm_al}
class OmlExitStatement is subclass of IOmlExitStatement
operations
  public identity: () ==> seq of char
  identity () == return "ExitStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExitStatement(self);

  public OmlExitStatement:
    [IOmlExpression] ==> OmlExitStatement
  OmlExitStatement (p1) == 
    ( setExpression(p1) );

  public OmlExitStatement:
    [IOmlExpression] *
    nat *
    nat ==> OmlExitStatement
  OmlExitStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExitStatement
\end{vdm_al}

\begin{vdm_al}
class OmlExplicitFunction is subclass of IOmlExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExplicitFunction(self);

  public OmlExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (IOmlType) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlExplicitFunction
  OmlExplicitFunction (p1,p2,p3,p4,p5,p6) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setType(p3);
      setParameterList(p4);
      setBody(p5);
      setTrailer(p6) );

  public OmlExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (IOmlType) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlExplicitFunction
  OmlExplicitFunction (p1,p2,p3,p4,p5,p6,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setType(p3);
      setParameterList(p4);
      setBody(p5);
      setTrailer(p6);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivParameterList : seq of IOmlParameter := []

operations
  public getParameterList: () ==> seq of IOmlParameter
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlParameter ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlExplicitOperation is subclass of IOmlExplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ExplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExplicitOperation(self);

  public OmlExplicitOperation:
    (seq of char) *
    (IOmlType) *
    (seq of IOmlPattern) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) ==> OmlExplicitOperation
  OmlExplicitOperation (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setType(p2);
      setParameterList(p3);
      setBody(p4);
      setTrailer(p5) );

  public OmlExplicitOperation:
    (seq of char) *
    (IOmlType) *
    (seq of IOmlPattern) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlExplicitOperation
  OmlExplicitOperation (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setParameterList(p3);
      setBody(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivParameterList : seq of IOmlPattern := []

operations
  public getParameterList: () ==> seq of IOmlPattern
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlPattern ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlOperationBody] := nil

operations
  public getBody: () ==> IOmlOperationBody
  getBody() == return ivBody;

  public setBody: IOmlOperationBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlExpression is subclass of IOmlExpression
operations
  public identity: () ==> seq of char
  identity () == return "Expression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExpression(self);

end OmlExpression
\end{vdm_al}
\begin{vdm_al}
class OmlExtendedExplicitFunction is subclass of IOmlExtendedExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ExtendedExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExtendedExplicitFunction(self);

  public OmlExtendedExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlExtendedExplicitFunction
  OmlExtendedExplicitFunction (p1,p2,p3,p4,p5,p6) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setBody(p5);
      setTrailer(p6) );

  public OmlExtendedExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlExtendedExplicitFunction
  OmlExtendedExplicitFunction (p1,p2,p3,p4,p5,p6,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setBody(p5);
      setTrailer(p6);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExtendedExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlExtendedExplicitOperation is subclass of IOmlExtendedExplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ExtendedExplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExtendedExplicitOperation(self);

  public OmlExtendedExplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) ==> OmlExtendedExplicitOperation
  OmlExtendedExplicitOperation (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setBody(p4);
      setTrailer(p5) );

  public OmlExtendedExplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlExtendedExplicitOperation
  OmlExtendedExplicitOperation (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setBody(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivBody : [IOmlOperationBody] := nil

operations
  public getBody: () ==> IOmlOperationBody
  getBody() == return ivBody;

  public setBody: IOmlOperationBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExtendedExplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlExternals is subclass of IOmlExternals
operations
  public identity: () ==> seq of char
  identity () == return "Externals";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExternals(self);

  public OmlExternals:
    (seq of IOmlVarInformation) ==> OmlExternals
  OmlExternals (p1) == 
    ( setExtList(p1) );

  public OmlExternals:
    (seq of IOmlVarInformation) *
    nat *
    nat ==> OmlExternals
  OmlExternals (p1,line,column) == 
    ( setExtList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "ext_list" in
        if fname in set dom data
        then setExtList(data(fname)) );

instance variables
  private ivExtList : seq of IOmlVarInformation := []

operations
  public getExtList: () ==> seq of IOmlVarInformation
  getExtList() == return ivExtList;

  public setExtList: seq of IOmlVarInformation ==> ()
  setExtList(parg) == ivExtList := parg;

  public addExtList: IOmlNode ==> ()
  addExtList (parg) == ivExtList := ivExtList ^ [parg];

end OmlExternals
\end{vdm_al}

\begin{vdm_al}
class OmlField is subclass of IOmlField
operations
  public identity: () ==> seq of char
  identity () == return "Field";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitField(self);

  public OmlField:
    [seq of char] *
    (IOmlType) *
    (bool) ==> OmlField
  OmlField (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setIgnore(p3) );

  public OmlField:
    [seq of char] *
    (IOmlType) *
    (bool) *
    nat *
    nat ==> OmlField
  OmlField (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setIgnore(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "ignore" in
        if fname in set dom data
        then setIgnore(data(fname)) );

instance variables
  private ivIdentifier : [seq of char] := nil

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier
    pre hasIdentifier();

  public hasIdentifier: () ==> bool
  hasIdentifier () == return ivIdentifier <> nil;

  public setIdentifier: [ seq of char ] ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivIgnore : [bool] := nil

operations
  public getIgnore: () ==> bool
  getIgnore() == return ivIgnore;

  public setIgnore: bool ==> ()
  setIgnore(parg) == ivIgnore := parg;

end OmlField
\end{vdm_al}

\begin{vdm_al}
class OmlFieldReference is subclass of IOmlFieldReference
operations
  public identity: () ==> seq of char
  identity () == return "FieldReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFieldReference(self);

  public OmlFieldReference:
    (IOmlStateDesignator) *
    (seq of char) ==> OmlFieldReference
  OmlFieldReference (p1,p2) == 
    ( setStateDesignator(p1);
      setIdentifier(p2) );

  public OmlFieldReference:
    (IOmlStateDesignator) *
    (seq of char) *
    nat *
    nat ==> OmlFieldReference
  OmlFieldReference (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setIdentifier(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlFieldReference
\end{vdm_al}

\begin{vdm_al}
class OmlFieldSelect is subclass of IOmlFieldSelect
operations
  public identity: () ==> seq of char
  identity () == return "FieldSelect";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFieldSelect(self);

  public OmlFieldSelect:
    (IOmlExpression) *
    (IOmlName) ==> OmlFieldSelect
  OmlFieldSelect (p1,p2) == 
    ( setExpression(p1);
      setName(p2) );

  public OmlFieldSelect:
    (IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlFieldSelect
  OmlFieldSelect (p1,p2,line,column) == 
    ( setExpression(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlFieldSelect
\end{vdm_al}

\begin{vdm_al}
class OmlFinExpression is subclass of IOmlFinExpression
operations
  public identity: () ==> seq of char
  identity () == return "FinExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFinExpression(self);

  public OmlFinExpression:
    (seq of IOmlName) ==> OmlFinExpression
  OmlFinExpression (p1) == 
    ( setNameList(p1) );

  public OmlFinExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlFinExpression
  OmlFinExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlFinExpression
\end{vdm_al}

\begin{vdm_al}
class OmlForAllExpression is subclass of IOmlForAllExpression
operations
  public identity: () ==> seq of char
  identity () == return "ForAllExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitForAllExpression(self);

  public OmlForAllExpression:
    (seq of IOmlBind) *
    (IOmlExpression) ==> OmlForAllExpression
  OmlForAllExpression (p1,p2) == 
    ( setBindList(p1);
      setExpression(p2) );

  public OmlForAllExpression:
    (seq of IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlForAllExpression
  OmlForAllExpression (p1,p2,line,column) == 
    ( setBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlForAllExpression
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionBody is subclass of IOmlFunctionBody
operations
  public identity: () ==> seq of char
  identity () == return "FunctionBody";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionBody(self);

  public OmlFunctionBody:
    [IOmlExpression] *
    (bool) *
    (bool) ==> OmlFunctionBody
  OmlFunctionBody (p1,p2,p3) == 
    ( setFunctionBody(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3) );

  public OmlFunctionBody:
    [IOmlExpression] *
    (bool) *
    (bool) *
    nat *
    nat ==> OmlFunctionBody
  OmlFunctionBody (p1,p2,p3,line,column) == 
    ( setFunctionBody(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "function_body" in
        if fname in set dom data
        then setFunctionBody(data(fname));
      let fname = "not_yet_specified" in
        if fname in set dom data
        then setNotYetSpecified(data(fname));
      let fname = "subclass_responsibility" in
        if fname in set dom data
        then setSubclassResponsibility(data(fname)) );

instance variables
  private ivFunctionBody : [IOmlExpression] := nil

operations
  public getFunctionBody: () ==> IOmlExpression
  getFunctionBody() == return ivFunctionBody
    pre hasFunctionBody();

  public hasFunctionBody: () ==> bool
  hasFunctionBody () == return ivFunctionBody <> nil;

  public setFunctionBody: [ IOmlExpression ] ==> ()
  setFunctionBody(parg) == ivFunctionBody := parg;

instance variables
  private ivNotYetSpecified : [bool] := nil

operations
  public getNotYetSpecified: () ==> bool
  getNotYetSpecified() == return ivNotYetSpecified;

  public setNotYetSpecified: bool ==> ()
  setNotYetSpecified(parg) == ivNotYetSpecified := parg;

instance variables
  private ivSubclassResponsibility : [bool] := nil

operations
  public getSubclassResponsibility: () ==> bool
  getSubclassResponsibility() == return ivSubclassResponsibility;

  public setSubclassResponsibility: bool ==> ()
  setSubclassResponsibility(parg) == ivSubclassResponsibility := parg;

end OmlFunctionBody
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionDefinition is subclass of IOmlFunctionDefinition
operations
  public identity: () ==> seq of char
  identity () == return "FunctionDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionDefinition(self);

  public OmlFunctionDefinition:
    (IOmlAccessDefinition) *
    (IOmlFunctionShape) ==> OmlFunctionDefinition
  OmlFunctionDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlFunctionDefinition:
    (IOmlAccessDefinition) *
    (IOmlFunctionShape) *
    nat *
    nat ==> OmlFunctionDefinition
  OmlFunctionDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlFunctionShape] := nil

operations
  public getShape: () ==> IOmlFunctionShape
  getShape() == return ivShape;

  public setShape: IOmlFunctionShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlFunctionDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionDefinitions is subclass of IOmlFunctionDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "FunctionDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionDefinitions(self);

  public OmlFunctionDefinitions:
    (seq of IOmlFunctionDefinition) ==> OmlFunctionDefinitions
  OmlFunctionDefinitions (p1) == 
    ( setFunctionList(p1) );

  public OmlFunctionDefinitions:
    (seq of IOmlFunctionDefinition) *
    nat *
    nat ==> OmlFunctionDefinitions
  OmlFunctionDefinitions (p1,line,column) == 
    ( setFunctionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "function_list" in
        if fname in set dom data
        then setFunctionList(data(fname)) );

instance variables
  private ivFunctionList : seq of IOmlFunctionDefinition := []

operations
  public getFunctionList: () ==> seq of IOmlFunctionDefinition
  getFunctionList() == return ivFunctionList;

  public setFunctionList: seq of IOmlFunctionDefinition ==> ()
  setFunctionList(parg) == ivFunctionList := parg;

  public addFunctionList: IOmlNode ==> ()
  addFunctionList (parg) == ivFunctionList := ivFunctionList ^ [parg];

end OmlFunctionDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionShape is subclass of IOmlFunctionShape
operations
  public identity: () ==> seq of char
  identity () == return "FunctionShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionShape(self);

end OmlFunctionShape
\end{vdm_al}
\begin{vdm_al}
class OmlFunctionTrailer is subclass of IOmlFunctionTrailer
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTrailer";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTrailer(self);

  public OmlFunctionTrailer:
    [IOmlExpression] *
    [IOmlExpression] ==> OmlFunctionTrailer
  OmlFunctionTrailer (p1,p2) == 
    ( setPreExpression(p1);
      setPostExpression(p2) );

  public OmlFunctionTrailer:
    [IOmlExpression] *
    [IOmlExpression] *
    nat *
    nat ==> OmlFunctionTrailer
  OmlFunctionTrailer (p1,p2,line,column) == 
    ( setPreExpression(p1);
      setPostExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname)) );

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression
    pre hasPostExpression();

  public hasPostExpression: () ==> bool
  hasPostExpression () == return ivPostExpression <> nil;

  public setPostExpression: [ IOmlExpression ] ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

end OmlFunctionTrailer
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionTypeInstantiation is subclass of IOmlFunctionTypeInstantiation
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTypeInstantiation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTypeInstantiation(self);

  public OmlFunctionTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) ==> OmlFunctionTypeInstantiation
  OmlFunctionTypeInstantiation (p1,p2) == 
    ( setName(p1);
      setTypeList(p2) );

  public OmlFunctionTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) *
    nat *
    nat ==> OmlFunctionTypeInstantiation
  OmlFunctionTypeInstantiation (p1,p2,line,column) == 
    ( setName(p1);
      setTypeList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "type_list" in
        if fname in set dom data
        then setTypeList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivTypeList : seq of IOmlType := []

operations
  public getTypeList: () ==> seq of IOmlType
  getTypeList() == return ivTypeList;

  public setTypeList: seq of IOmlType ==> ()
  setTypeList(parg) == ivTypeList := parg;

  public addTypeList: IOmlNode ==> ()
  addTypeList (parg) == ivTypeList := ivTypeList ^ [parg];

end OmlFunctionTypeInstantiation
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionTypeSelect is subclass of IOmlFunctionTypeSelect
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTypeSelect";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTypeSelect(self);

  public OmlFunctionTypeSelect:
    (IOmlExpression) *
    (IOmlFunctionTypeInstantiation) ==> OmlFunctionTypeSelect
  OmlFunctionTypeSelect (p1,p2) == 
    ( setExpression(p1);
      setFunctionTypeInstantiation(p2) );

  public OmlFunctionTypeSelect:
    (IOmlExpression) *
    (IOmlFunctionTypeInstantiation) *
    nat *
    nat ==> OmlFunctionTypeSelect
  OmlFunctionTypeSelect (p1,p2,line,column) == 
    ( setExpression(p1);
      setFunctionTypeInstantiation(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "function_type_instantiation" in
        if fname in set dom data
        then setFunctionTypeInstantiation(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivFunctionTypeInstantiation : [IOmlFunctionTypeInstantiation] := nil

operations
  public getFunctionTypeInstantiation: () ==> IOmlFunctionTypeInstantiation
  getFunctionTypeInstantiation() == return ivFunctionTypeInstantiation;

  public setFunctionTypeInstantiation: IOmlFunctionTypeInstantiation ==> ()
  setFunctionTypeInstantiation(parg) == ivFunctionTypeInstantiation := parg;

end OmlFunctionTypeSelect
\end{vdm_al}

\begin{vdm_al}
class OmlGeneralMapType is subclass of IOmlGeneralMapType
operations
  public identity: () ==> seq of char
  identity () == return "GeneralMapType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitGeneralMapType(self);

  public OmlGeneralMapType:
    (IOmlType) *
    (IOmlType) ==> OmlGeneralMapType
  OmlGeneralMapType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlGeneralMapType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlGeneralMapType
  OmlGeneralMapType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlGeneralMapType
\end{vdm_al}

\begin{vdm_al}
class OmlIdentifierTypePair is subclass of IOmlIdentifierTypePair
operations
  public identity: () ==> seq of char
  identity () == return "IdentifierTypePair";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIdentifierTypePair(self);

  public OmlIdentifierTypePair:
    (seq of char) *
    (IOmlType) ==> OmlIdentifierTypePair
  OmlIdentifierTypePair (p1,p2) == 
    ( setIdentifier(p1);
      setType(p2) );

  public OmlIdentifierTypePair:
    (seq of char) *
    (IOmlType) *
    nat *
    nat ==> OmlIdentifierTypePair
  OmlIdentifierTypePair (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlIdentifierTypePair
\end{vdm_al}

\begin{vdm_al}
class OmlIfExpression is subclass of IOmlIfExpression
operations
  public identity: () ==> seq of char
  identity () == return "IfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIfExpression(self);

  public OmlIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (seq of IOmlElseIfExpression) *
    (IOmlExpression) ==> OmlIfExpression
  OmlIfExpression (p1,p2,p3,p4) == 
    ( setIfExpression(p1);
      setThenExpression(p2);
      setElseifExpressionList(p3);
      setElseExpression(p4) );

  public OmlIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (seq of IOmlElseIfExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIfExpression
  OmlIfExpression (p1,p2,p3,p4,line,column) == 
    ( setIfExpression(p1);
      setThenExpression(p2);
      setElseifExpressionList(p3);
      setElseExpression(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "if_expression" in
        if fname in set dom data
        then setIfExpression(data(fname));
      let fname = "then_expression" in
        if fname in set dom data
        then setThenExpression(data(fname));
      let fname = "elseif_expression_list" in
        if fname in set dom data
        then setElseifExpressionList(data(fname));
      let fname = "else_expression" in
        if fname in set dom data
        then setElseExpression(data(fname)) );

instance variables
  private ivIfExpression : [IOmlExpression] := nil

operations
  public getIfExpression: () ==> IOmlExpression
  getIfExpression() == return ivIfExpression;

  public setIfExpression: IOmlExpression ==> ()
  setIfExpression(parg) == ivIfExpression := parg;

instance variables
  private ivThenExpression : [IOmlExpression] := nil

operations
  public getThenExpression: () ==> IOmlExpression
  getThenExpression() == return ivThenExpression;

  public setThenExpression: IOmlExpression ==> ()
  setThenExpression(parg) == ivThenExpression := parg;

instance variables
  private ivElseifExpressionList : seq of IOmlElseIfExpression := []

operations
  public getElseifExpressionList: () ==> seq of IOmlElseIfExpression
  getElseifExpressionList() == return ivElseifExpressionList;

  public setElseifExpressionList: seq of IOmlElseIfExpression ==> ()
  setElseifExpressionList(parg) == ivElseifExpressionList := parg;

  public addElseifExpressionList: IOmlNode ==> ()
  addElseifExpressionList (parg) == ivElseifExpressionList := ivElseifExpressionList ^ [parg];

instance variables
  private ivElseExpression : [IOmlExpression] := nil

operations
  public getElseExpression: () ==> IOmlExpression
  getElseExpression() == return ivElseExpression;

  public setElseExpression: IOmlExpression ==> ()
  setElseExpression(parg) == ivElseExpression := parg;

end OmlIfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIfStatement is subclass of IOmlIfStatement
operations
  public identity: () ==> seq of char
  identity () == return "IfStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIfStatement(self);

  public OmlIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    (seq of IOmlElseIfStatement) *
    [IOmlStatement] ==> OmlIfStatement
  OmlIfStatement (p1,p2,p3,p4) == 
    ( setExpression(p1);
      setThenStatement(p2);
      setElseifStatement(p3);
      setElseStatement(p4) );

  public OmlIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    (seq of IOmlElseIfStatement) *
    [IOmlStatement] *
    nat *
    nat ==> OmlIfStatement
  OmlIfStatement (p1,p2,p3,p4,line,column) == 
    ( setExpression(p1);
      setThenStatement(p2);
      setElseifStatement(p3);
      setElseStatement(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "then_statement" in
        if fname in set dom data
        then setThenStatement(data(fname));
      let fname = "elseif_statement" in
        if fname in set dom data
        then setElseifStatement(data(fname));
      let fname = "else_statement" in
        if fname in set dom data
        then setElseStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivThenStatement : [IOmlStatement] := nil

operations
  public getThenStatement: () ==> IOmlStatement
  getThenStatement() == return ivThenStatement;

  public setThenStatement: IOmlStatement ==> ()
  setThenStatement(parg) == ivThenStatement := parg;

instance variables
  private ivElseifStatement : seq of IOmlElseIfStatement := []

operations
  public getElseifStatement: () ==> seq of IOmlElseIfStatement
  getElseifStatement() == return ivElseifStatement;

  public setElseifStatement: seq of IOmlElseIfStatement ==> ()
  setElseifStatement(parg) == ivElseifStatement := parg;

  public addElseifStatement: IOmlNode ==> ()
  addElseifStatement (parg) == ivElseifStatement := ivElseifStatement ^ [parg];

instance variables
  private ivElseStatement : [IOmlStatement] := nil

operations
  public getElseStatement: () ==> IOmlStatement
  getElseStatement() == return ivElseStatement
    pre hasElseStatement();

  public hasElseStatement: () ==> bool
  hasElseStatement () == return ivElseStatement <> nil;

  public setElseStatement: [ IOmlStatement ] ==> ()
  setElseStatement(parg) == ivElseStatement := parg;

end OmlIfStatement
\end{vdm_al}

\begin{vdm_al}
class OmlImplicitFunction is subclass of IOmlImplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ImplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitImplicitFunction(self);

  public OmlImplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionTrailer) ==> OmlImplicitFunction
  OmlImplicitFunction (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setTrailer(p5) );

  public OmlImplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlImplicitFunction
  OmlImplicitFunction (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlImplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlImplicitOperation is subclass of IOmlImplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ImplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitImplicitOperation(self);

  public OmlImplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationTrailer) ==> OmlImplicitOperation
  OmlImplicitOperation (p1,p2,p3,p4) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setTrailer(p4) );

  public OmlImplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlImplicitOperation
  OmlImplicitOperation (p1,p2,p3,p4,line,column) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setTrailer(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlImplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlIndexForLoop is subclass of IOmlIndexForLoop
operations
  public identity: () ==> seq of char
  identity () == return "IndexForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIndexForLoop(self);

  public OmlIndexForLoop:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    [IOmlExpression] *
    (IOmlStatement) ==> OmlIndexForLoop
  OmlIndexForLoop (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setInitExpression(p2);
      setLimitExpression(p3);
      setByExpression(p4);
      setStatement(p5) );

  public OmlIndexForLoop:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    [IOmlExpression] *
    (IOmlStatement) *
    nat *
    nat ==> OmlIndexForLoop
  OmlIndexForLoop (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setInitExpression(p2);
      setLimitExpression(p3);
      setByExpression(p4);
      setStatement(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "init_expression" in
        if fname in set dom data
        then setInitExpression(data(fname));
      let fname = "limit_expression" in
        if fname in set dom data
        then setLimitExpression(data(fname));
      let fname = "by_expression" in
        if fname in set dom data
        then setByExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivInitExpression : [IOmlExpression] := nil

operations
  public getInitExpression: () ==> IOmlExpression
  getInitExpression() == return ivInitExpression;

  public setInitExpression: IOmlExpression ==> ()
  setInitExpression(parg) == ivInitExpression := parg;

instance variables
  private ivLimitExpression : [IOmlExpression] := nil

operations
  public getLimitExpression: () ==> IOmlExpression
  getLimitExpression() == return ivLimitExpression;

  public setLimitExpression: IOmlExpression ==> ()
  setLimitExpression(parg) == ivLimitExpression := parg;

instance variables
  private ivByExpression : [IOmlExpression] := nil

operations
  public getByExpression: () ==> IOmlExpression
  getByExpression() == return ivByExpression
    pre hasByExpression();

  public hasByExpression: () ==> bool
  hasByExpression () == return ivByExpression <> nil;

  public setByExpression: [ IOmlExpression ] ==> ()
  setByExpression(parg) == ivByExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlIndexForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlInheritanceClause is subclass of IOmlInheritanceClause
operations
  public identity: () ==> seq of char
  identity () == return "InheritanceClause";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInheritanceClause(self);

  public OmlInheritanceClause:
    (seq of seq of char) ==> OmlInheritanceClause
  OmlInheritanceClause (p1) == 
    ( setIdentifierList(p1) );

  public OmlInheritanceClause:
    (seq of seq of char) *
    nat *
    nat ==> OmlInheritanceClause
  OmlInheritanceClause (p1,line,column) == 
    ( setIdentifierList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier_list" in
        if fname in set dom data
        then setIdentifierList(data(fname)) );

instance variables
  private ivIdentifierList : seq of seq of char := []

operations
  public getIdentifierList: () ==> seq of seq of char
  getIdentifierList() == return ivIdentifierList;

  public setIdentifierList: seq of seq of char ==> ()
  setIdentifierList(parg) == ivIdentifierList := parg;

  public addIdentifierList: seq of char ==> ()
  addIdentifierList (parg) == ivIdentifierList := ivIdentifierList ^ [parg];

end OmlInheritanceClause
\end{vdm_al}

\begin{vdm_al}
class OmlInjectiveMapType is subclass of IOmlInjectiveMapType
operations
  public identity: () ==> seq of char
  identity () == return "InjectiveMapType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInjectiveMapType(self);

  public OmlInjectiveMapType:
    (IOmlType) *
    (IOmlType) ==> OmlInjectiveMapType
  OmlInjectiveMapType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlInjectiveMapType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlInjectiveMapType
  OmlInjectiveMapType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlInjectiveMapType
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariable is subclass of IOmlInstanceVariable
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariable";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariable(self);

  public OmlInstanceVariable:
    (IOmlAccessDefinition) *
    (IOmlAssignmentDefinition) ==> OmlInstanceVariable
  OmlInstanceVariable (p1,p2) == 
    ( setAccess(p1);
      setAssignmentDefinition(p2) );

  public OmlInstanceVariable:
    (IOmlAccessDefinition) *
    (IOmlAssignmentDefinition) *
    nat *
    nat ==> OmlInstanceVariable
  OmlInstanceVariable (p1,p2,line,column) == 
    ( setAccess(p1);
      setAssignmentDefinition(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "assignment_definition" in
        if fname in set dom data
        then setAssignmentDefinition(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivAssignmentDefinition : [IOmlAssignmentDefinition] := nil

operations
  public getAssignmentDefinition: () ==> IOmlAssignmentDefinition
  getAssignmentDefinition() == return ivAssignmentDefinition;

  public setAssignmentDefinition: IOmlAssignmentDefinition ==> ()
  setAssignmentDefinition(parg) == ivAssignmentDefinition := parg;

end OmlInstanceVariable
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableDefinitions is subclass of IOmlInstanceVariableDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableDefinitions(self);

  public OmlInstanceVariableDefinitions:
    (seq of IOmlInstanceVariableShape) ==> OmlInstanceVariableDefinitions
  OmlInstanceVariableDefinitions (p1) == 
    ( setVariablesList(p1) );

  public OmlInstanceVariableDefinitions:
    (seq of IOmlInstanceVariableShape) *
    nat *
    nat ==> OmlInstanceVariableDefinitions
  OmlInstanceVariableDefinitions (p1,line,column) == 
    ( setVariablesList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "variables_list" in
        if fname in set dom data
        then setVariablesList(data(fname)) );

instance variables
  private ivVariablesList : seq of IOmlInstanceVariableShape := []

operations
  public getVariablesList: () ==> seq of IOmlInstanceVariableShape
  getVariablesList() == return ivVariablesList;

  public setVariablesList: seq of IOmlInstanceVariableShape ==> ()
  setVariablesList(parg) == ivVariablesList := parg;

  public addVariablesList: IOmlNode ==> ()
  addVariablesList (parg) == ivVariablesList := ivVariablesList ^ [parg];

end OmlInstanceVariableDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableInvariant is subclass of IOmlInstanceVariableInvariant
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableInvariant";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableInvariant(self);

  public OmlInstanceVariableInvariant:
    (IOmlExpression) ==> OmlInstanceVariableInvariant
  OmlInstanceVariableInvariant (p1) == 
    ( setInvariant(p1) );

  public OmlInstanceVariableInvariant:
    (IOmlExpression) *
    nat *
    nat ==> OmlInstanceVariableInvariant
  OmlInstanceVariableInvariant (p1,line,column) == 
    ( setInvariant(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivInvariant : [IOmlExpression] := nil

operations
  public getInvariant: () ==> IOmlExpression
  getInvariant() == return ivInvariant;

  public setInvariant: IOmlExpression ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlInstanceVariableInvariant
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableShape is subclass of IOmlInstanceVariableShape
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableShape(self);

end OmlInstanceVariableShape
\end{vdm_al}
\begin{vdm_al}
class OmlIntType is subclass of IOmlIntType
operations
  public identity: () ==> seq of char
  identity () == return "IntType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIntType(self);

  public OmlIntType:
    () ==> OmlIntType
  OmlIntType () == 
    skip;

  public OmlIntType:
    nat *
    nat ==> OmlIntType
  OmlIntType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlIntType
\end{vdm_al}

\begin{vdm_al}
class OmlInvariant is subclass of IOmlInvariant
operations
  public identity: () ==> seq of char
  identity () == return "Invariant";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInvariant(self);

  public OmlInvariant:
    (IOmlPattern) *
    (IOmlExpression) ==> OmlInvariant
  OmlInvariant (p1,p2) == 
    ( setPattern(p1);
      setExpression(p2) );

  public OmlInvariant:
    (IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlInvariant
  OmlInvariant (p1,p2,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlInvariant
\end{vdm_al}

\begin{vdm_al}
class OmlIotaExpression is subclass of IOmlIotaExpression
operations
  public identity: () ==> seq of char
  identity () == return "IotaExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIotaExpression(self);

  public OmlIotaExpression:
    (IOmlBind) *
    (IOmlExpression) ==> OmlIotaExpression
  OmlIotaExpression (p1,p2) == 
    ( setBind(p1);
      setExpression(p2) );

  public OmlIotaExpression:
    (IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIotaExpression
  OmlIotaExpression (p1,p2,line,column) == 
    ( setBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIotaExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsExpression is subclass of IOmlIsExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsExpression(self);

  public OmlIsExpression:
    (IOmlType) *
    (IOmlExpression) ==> OmlIsExpression
  OmlIsExpression (p1,p2) == 
    ( setType(p1);
      setExpression(p2) );

  public OmlIsExpression:
    (IOmlType) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsExpression
  OmlIsExpression (p1,p2,line,column) == 
    ( setType(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsofbaseclassExpression is subclass of IOmlIsofbaseclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsofbaseclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsofbaseclassExpression(self);

  public OmlIsofbaseclassExpression:
    (IOmlName) *
    (IOmlExpression) ==> OmlIsofbaseclassExpression
  OmlIsofbaseclassExpression (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlIsofbaseclassExpression:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsofbaseclassExpression
  OmlIsofbaseclassExpression (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsofbaseclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsofclassExpression is subclass of IOmlIsofclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsofclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsofclassExpression(self);

  public OmlIsofclassExpression:
    (IOmlName) *
    (IOmlExpression) ==> OmlIsofclassExpression
  OmlIsofclassExpression (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlIsofclassExpression:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsofclassExpression
  OmlIsofclassExpression (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsofclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLambdaExpression is subclass of IOmlLambdaExpression
operations
  public identity: () ==> seq of char
  identity () == return "LambdaExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLambdaExpression(self);

  public OmlLambdaExpression:
    (seq of IOmlTypeBind) *
    (IOmlExpression) ==> OmlLambdaExpression
  OmlLambdaExpression (p1,p2) == 
    ( setTypeBindList(p1);
      setExpression(p2) );

  public OmlLambdaExpression:
    (seq of IOmlTypeBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlLambdaExpression
  OmlLambdaExpression (p1,p2,line,column) == 
    ( setTypeBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type_bind_list" in
        if fname in set dom data
        then setTypeBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivTypeBindList : seq of IOmlTypeBind := []

operations
  public getTypeBindList: () ==> seq of IOmlTypeBind
  getTypeBindList() == return ivTypeBindList;

  public setTypeBindList: seq of IOmlTypeBind ==> ()
  setTypeBindList(parg) == ivTypeBindList := parg;

  public addTypeBindList: IOmlNode ==> ()
  addTypeBindList (parg) == ivTypeBindList := ivTypeBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLambdaExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetBeExpression is subclass of IOmlLetBeExpression
operations
  public identity: () ==> seq of char
  identity () == return "LetBeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetBeExpression(self);

  public OmlLetBeExpression:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlExpression) ==> OmlLetBeExpression
  OmlLetBeExpression (p1,p2,p3) == 
    ( setBind(p1);
      setBest(p2);
      setExpression(p3) );

  public OmlLetBeExpression:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlExpression) *
    nat *
    nat ==> OmlLetBeExpression
  OmlLetBeExpression (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLetBeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetBeStatement is subclass of IOmlLetBeStatement
operations
  public identity: () ==> seq of char
  identity () == return "LetBeStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetBeStatement(self);

  public OmlLetBeStatement:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlStatement) ==> OmlLetBeStatement
  OmlLetBeStatement (p1,p2,p3) == 
    ( setBind(p1);
      setBest(p2);
      setStatement(p3) );

  public OmlLetBeStatement:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlStatement) *
    nat *
    nat ==> OmlLetBeStatement
  OmlLetBeStatement (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlLetBeStatement
\end{vdm_al}

\begin{vdm_al}
class OmlLetExpression is subclass of IOmlLetExpression
operations
  public identity: () ==> seq of char
  identity () == return "LetExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetExpression(self);

  public OmlLetExpression:
    (seq of IOmlValueShape) *
    (IOmlExpression) ==> OmlLetExpression
  OmlLetExpression (p1,p2) == 
    ( setDefinitionList(p1);
      setExpression(p2) );

  public OmlLetExpression:
    (seq of IOmlValueShape) *
    (IOmlExpression) *
    nat *
    nat ==> OmlLetExpression
  OmlLetExpression (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLetExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetStatement is subclass of IOmlLetStatement
operations
  public identity: () ==> seq of char
  identity () == return "LetStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetStatement(self);

  public OmlLetStatement:
    (seq of IOmlValueShape) *
    (IOmlStatement) ==> OmlLetStatement
  OmlLetStatement (p1,p2) == 
    ( setDefinitionList(p1);
      setStatement(p2) );

  public OmlLetStatement:
    (seq of IOmlValueShape) *
    (IOmlStatement) *
    nat *
    nat ==> OmlLetStatement
  OmlLetStatement (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlLetStatement
\end{vdm_al}

\begin{vdm_al}
class OmlLexem is subclass of IOmlLexem

instance variables
  private ivLine : nat := 0

operations
  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLexem(self);

  public getLine: () ==> nat
  getLine () == return ivLine;

  public setLine: nat ==> ()
  setLine (pline) == ivLine := pline

instance variables
  private ivColumn : nat := 0

operations
  public getColumn: () ==> nat
  getColumn () == return ivColumn;

  public setColumn: nat ==> ()
  setColumn (pcolumn) == ivColumn := pcolumn

instance variables
  private ivLexval : nat := 0

operations
  public getLexval: () ==> nat
  getLexval () == return ivLexval;

  public setLexval: nat ==> ()
  setLexval (plexval) == ivLexval := plexval

instance variables
  private ivText : seq of char := []

operations
  public getText: () ==> seq of char
  getText () == return ivText;

  public setText: seq of char ==> ()
  setText (ptext) == ivText := ptext

instance variables
  private ivType : nat := ILEXEMUNKNOWN

operations
  public getType: () ==> nat
  getType () == return ivType;

  public isKeyword: () ==> bool
  isKeyword () == return ivType = ILEXEMKEYWORD;

  public isIdentifier: () ==> bool
  isIdentifier () == return ivType = ILEXEMIDENTIFIER;

  public isComment: () ==> bool
  isComment () == return (ivType = ILEXEMLINECOMMENT) or (ivType = ILEXEMBLOCKCOMMENT);

  public isLineComment: () ==> bool
  isLineComment () == return ivType = ILEXEMLINECOMMENT;

  public isBlockComment: () ==> bool
  isBlockComment () == return ivType = ILEXEMBLOCKCOMMENT;

  public OmlLexem: nat * nat * nat * seq of char * nat ==> OmlLexem
  OmlLexem (pline, pcolumn, plexval, ptext, ptype) ==
    ( ivLine := pline;
      ivColumn := pcolumn;
      ivLexval := plexval;
      ivText := ptext;
      ivType := ptype )

end OmlLexem
\end{vdm_al}
\begin{vdm_al}
class OmlLiteral is subclass of IOmlLiteral
operations
  public identity: () ==> seq of char
  identity () == return "Literal";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLiteral(self);

end OmlLiteral
\end{vdm_al}
\begin{vdm_al}
class OmlMapComprehension is subclass of IOmlMapComprehension
operations
  public identity: () ==> seq of char
  identity () == return "MapComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapComprehension(self);

  public OmlMapComprehension:
    (IOmlMaplet) *
    (seq of IOmlBind) *
    [IOmlExpression] ==> OmlMapComprehension
  OmlMapComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3) );

  public OmlMapComprehension:
    (IOmlMaplet) *
    (seq of IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlMapComprehension
  OmlMapComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlMaplet] := nil

operations
  public getExpression: () ==> IOmlMaplet
  getExpression() == return ivExpression;

  public setExpression: IOmlMaplet ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlMapComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlMapEnumeration is subclass of IOmlMapEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "MapEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapEnumeration(self);

  public OmlMapEnumeration:
    (seq of IOmlMaplet) ==> OmlMapEnumeration
  OmlMapEnumeration (p1) == 
    ( setMapletList(p1) );

  public OmlMapEnumeration:
    (seq of IOmlMaplet) *
    nat *
    nat ==> OmlMapEnumeration
  OmlMapEnumeration (p1,line,column) == 
    ( setMapletList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "maplet_list" in
        if fname in set dom data
        then setMapletList(data(fname)) );

instance variables
  private ivMapletList : seq of IOmlMaplet := []

operations
  public getMapletList: () ==> seq of IOmlMaplet
  getMapletList() == return ivMapletList;

  public setMapletList: seq of IOmlMaplet ==> ()
  setMapletList(parg) == ivMapletList := parg;

  public addMapletList: IOmlNode ==> ()
  addMapletList (parg) == ivMapletList := ivMapletList ^ [parg];

end OmlMapEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlMapOrSequenceReference is subclass of IOmlMapOrSequenceReference
operations
  public identity: () ==> seq of char
  identity () == return "MapOrSequenceReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapOrSequenceReference(self);

  public OmlMapOrSequenceReference:
    (IOmlStateDesignator) *
    (IOmlExpression) ==> OmlMapOrSequenceReference
  OmlMapOrSequenceReference (p1,p2) == 
    ( setStateDesignator(p1);
      setExpression(p2) );

  public OmlMapOrSequenceReference:
    (IOmlStateDesignator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlMapOrSequenceReference
  OmlMapOrSequenceReference (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlMapOrSequenceReference
\end{vdm_al}

\begin{vdm_al}
class OmlMaplet is subclass of IOmlMaplet
operations
  public identity: () ==> seq of char
  identity () == return "Maplet";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMaplet(self);

  public OmlMaplet:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlMaplet
  OmlMaplet (p1,p2) == 
    ( setDomExpression(p1);
      setRngExpression(p2) );

  public OmlMaplet:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlMaplet
  OmlMaplet (p1,p2,line,column) == 
    ( setDomExpression(p1);
      setRngExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_expression" in
        if fname in set dom data
        then setDomExpression(data(fname));
      let fname = "rng_expression" in
        if fname in set dom data
        then setRngExpression(data(fname)) );

instance variables
  private ivDomExpression : [IOmlExpression] := nil

operations
  public getDomExpression: () ==> IOmlExpression
  getDomExpression() == return ivDomExpression;

  public setDomExpression: IOmlExpression ==> ()
  setDomExpression(parg) == ivDomExpression := parg;

instance variables
  private ivRngExpression : [IOmlExpression] := nil

operations
  public getRngExpression: () ==> IOmlExpression
  getRngExpression() == return ivRngExpression;

  public setRngExpression: IOmlExpression ==> ()
  setRngExpression(parg) == ivRngExpression := parg;

end OmlMaplet
\end{vdm_al}

\begin{vdm_al}
class OmlMatchValue is subclass of IOmlMatchValue
operations
  public identity: () ==> seq of char
  identity () == return "MatchValue";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMatchValue(self);

  public OmlMatchValue:
    (IOmlExpression) ==> OmlMatchValue
  OmlMatchValue (p1) == 
    ( setExpression(p1) );

  public OmlMatchValue:
    (IOmlExpression) *
    nat *
    nat ==> OmlMatchValue
  OmlMatchValue (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlMatchValue
\end{vdm_al}

\begin{vdm_al}
class OmlMode is subclass of IOmlMode
operations
  public identity: () ==> seq of char
  identity () == return "Mode";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMode(self);

  public OmlMode: nat ==> OmlMode
  OmlMode (pv) == setValue(pv);

  public OmlMode: nat * nat * nat ==> OmlMode
  OmlMode (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlModeQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlModeQuotes`getQuoteName(val)
    pre val <> nil;

end OmlMode
\end{vdm_al}
\begin{vdm_al}
class OmlModeQuotes
instance variables
  static public IQWR : nat := 0;
  static public IQRD : nat := 1;

  static private qmap : map nat to seq of char :=
    { IQWR |-> "<WR>",
      IQRD |-> "<RD>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlModeQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlMuExpression is subclass of IOmlMuExpression
operations
  public identity: () ==> seq of char
  identity () == return "MuExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMuExpression(self);

  public OmlMuExpression:
    (IOmlExpression) *
    (seq of IOmlRecordModifier) ==> OmlMuExpression
  OmlMuExpression (p1,p2) == 
    ( setExpression(p1);
      setModifierList(p2) );

  public OmlMuExpression:
    (IOmlExpression) *
    (seq of IOmlRecordModifier) *
    nat *
    nat ==> OmlMuExpression
  OmlMuExpression (p1,p2,line,column) == 
    ( setExpression(p1);
      setModifierList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "modifier_list" in
        if fname in set dom data
        then setModifierList(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivModifierList : seq of IOmlRecordModifier := []

operations
  public getModifierList: () ==> seq of IOmlRecordModifier
  getModifierList() == return ivModifierList;

  public setModifierList: seq of IOmlRecordModifier ==> ()
  setModifierList(parg) == ivModifierList := parg;

  public addModifierList: IOmlNode ==> ()
  addModifierList (parg) == ivModifierList := ivModifierList ^ [parg];

end OmlMuExpression
\end{vdm_al}

\begin{vdm_al}
class OmlMutexAllPredicate is subclass of IOmlMutexAllPredicate
operations
  public identity: () ==> seq of char
  identity () == return "MutexAllPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMutexAllPredicate(self);

  public OmlMutexAllPredicate:
    () ==> OmlMutexAllPredicate
  OmlMutexAllPredicate () == 
    skip;

  public OmlMutexAllPredicate:
    nat *
    nat ==> OmlMutexAllPredicate
  OmlMutexAllPredicate (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlMutexAllPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlMutexPredicate is subclass of IOmlMutexPredicate
operations
  public identity: () ==> seq of char
  identity () == return "MutexPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMutexPredicate(self);

  public OmlMutexPredicate:
    (seq of IOmlName) ==> OmlMutexPredicate
  OmlMutexPredicate (p1) == 
    ( setNameList(p1) );

  public OmlMutexPredicate:
    (seq of IOmlName) *
    nat *
    nat ==> OmlMutexPredicate
  OmlMutexPredicate (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlMutexPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlName is subclass of IOmlName
operations
  public identity: () ==> seq of char
  identity () == return "Name";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitName(self);

  public OmlName:
    [seq of char] *
    (seq of char) ==> OmlName
  OmlName (p1,p2) == 
    ( setClassIdentifier(p1);
      setIdentifier(p2) );

  public OmlName:
    [seq of char] *
    (seq of char) *
    nat *
    nat ==> OmlName
  OmlName (p1,p2,line,column) == 
    ( setClassIdentifier(p1);
      setIdentifier(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "class_identifier" in
        if fname in set dom data
        then setClassIdentifier(data(fname));
      let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivClassIdentifier : [seq of char] := nil

operations
  public getClassIdentifier: () ==> seq of char
  getClassIdentifier() == return ivClassIdentifier
    pre hasClassIdentifier();

  public hasClassIdentifier: () ==> bool
  hasClassIdentifier () == return ivClassIdentifier <> nil;

  public setClassIdentifier: [ seq of char ] ==> ()
  setClassIdentifier(parg) == ivClassIdentifier := parg;

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlName
\end{vdm_al}

\begin{vdm_al}
class OmlNamedTrace is subclass of IOmlNamedTrace
operations
  public identity: () ==> seq of char
  identity () == return "NamedTrace";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNamedTrace(self);

--  public OmlNamedTrace:
--    (seq of char) *
--    (IOmlTraceDefinition) ==> OmlNamedTrace
--  OmlNamedTrace (p1,p2) == 
--    ( setName([p1]);
--      setDefs(p2) );

  public OmlNamedTrace:
    (seq of seq of char) *
    (IOmlTraceDefinition) ==> OmlNamedTrace
  OmlNamedTrace (p1,p2) == 
    ( setName(p1);
      setDefs(p2) );

--  public OmlNamedTrace:
--    (seq of char) *
--    (IOmlTraceDefinition) *
--    nat *
--    nat ==> OmlNamedTrace
--  OmlNamedTrace (p1,p2,line,column) == 
--    ( setName([p1]);
--      setDefs(p2);
--      setPosition(line, column) );

  public OmlNamedTrace:
    (seq of seq of char) *
    (IOmlTraceDefinition) *
    nat *
    nat ==> OmlNamedTrace
  OmlNamedTrace (p1,p2,line,column) == 
    ( setName(p1);
      setDefs(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName([data(fname)]);
      let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivName : seq of seq of char := []

operations
  public getName: () ==> seq of seq of char
  getName() == return ivName;

--  public setName: seq of char ==> ()
--  setName(parg) == ivName := parg;

  public setName: seq of seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivDefs : [IOmlTraceDefinition] := nil

operations
  public getDefs: () ==> IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

end OmlNamedTrace
\end{vdm_al}

\begin{vdm_al}
class OmlNat1Type is subclass of IOmlNat1Type
operations
  public identity: () ==> seq of char
  identity () == return "Nat1Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNat1Type(self);

  public OmlNat1Type:
    () ==> OmlNat1Type
  OmlNat1Type () == 
    skip;

  public OmlNat1Type:
    nat *
    nat ==> OmlNat1Type
  OmlNat1Type (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNat1Type
\end{vdm_al}

\begin{vdm_al}
class OmlNatType is subclass of IOmlNatType
operations
  public identity: () ==> seq of char
  identity () == return "NatType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNatType(self);

  public OmlNatType:
    () ==> OmlNatType
  OmlNatType () == 
    skip;

  public OmlNatType:
    nat *
    nat ==> OmlNatType
  OmlNatType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNatType
\end{vdm_al}

\begin{vdm_al}
class OmlNewExpression is subclass of IOmlNewExpression
operations
  public identity: () ==> seq of char
  identity () == return "NewExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNewExpression(self);

  public OmlNewExpression:
    (IOmlName) *
    (seq of IOmlType) *
    (seq of IOmlExpression) ==> OmlNewExpression
  OmlNewExpression (p1,p2,p3) == 
    ( setName(p1);
      setGenericTypes(p2);
      setExpressionList(p3) );

  public OmlNewExpression:
    (IOmlName) *
    (seq of IOmlType) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlNewExpression
  OmlNewExpression (p1,p2,p3,line,column) == 
    ( setName(p1);
      setGenericTypes(p2);
      setExpressionList(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlNewExpression
\end{vdm_al}

\begin{vdm_al}
class OmlNilLiteral is subclass of IOmlNilLiteral
operations
  public identity: () ==> seq of char
  identity () == return "NilLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNilLiteral(self);

  public OmlNilLiteral:
    () ==> OmlNilLiteral
  OmlNilLiteral () == 
    skip;

  public OmlNilLiteral:
    nat *
    nat ==> OmlNilLiteral
  OmlNilLiteral (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNilLiteral
\end{vdm_al}

\begin{vdm_al}
class IOmlContextInfo

operations
  public accept: IOmlVisitor ==> ()
  accept (-) == is subclass responsibility

end IOmlContextInfo
\end{vdm_al}

\begin{vdm_al}
-- important note: this class is renamed to OmlNode by the patch script!
class IOmlNode

values
  public static prefix : seq of char = "Oml"

types
  public FieldValue = 
    bool | char | nat | real | IOmlNode | 
    seq of FieldValue |
    set of FieldValue |
    map FieldValue to FieldValue

instance variables
  private ivInfo : map nat to IOmlContextInfo := {|->}

operations
  public identity: () ==> seq of char
  identity () == return "Node";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNode(self);

  public getContextInfo: nat ==> IOmlContextInfo
  getContextInfo (pci) == return ivInfo(pci)
    pre pci in set dom ivInfo;

  public getContextInfoCount: () ==> nat
  getContextInfoCount () == return card dom ivInfo;

  public addContextInfo: IOmlContextInfo ==> nat
  addContextInfo (pci) ==
    ( dcl res : nat := card dom ivInfo + 1;
      ivInfo := ivInfo munion {res |-> pci};
      return res )

instance variables
  private ivLine : nat := 0;
  private ivColumn : nat := 0;

operations
  public getLine : () ==> nat
  getLine () == return ivLine;

  public setLine : nat ==> ()
  setLine (pl) == ivLine := pl;

  public getColumn : () ==> nat
  getColumn () == return ivColumn;

  public setColumn : nat ==> ()
  setColumn (pc) == ivColumn := pc;

  public setPosition : nat * nat ==> ()
  setPosition (pl, pc) ==
    ( setLine(pl); setColumn(pc) );

  public setPosLexem : IOmlLexem ==> ()
  setPosLexem (pol) ==
    ( setLine(pol.getLine());
      setColumn(pol.getColumn()) );

  public setPosNode : IOmlNode ==> ()
  setPosNode (pnd) ==
    ( setLine(pnd.getLine());
      setColumn(pnd.getColumn()) )

end IOmlNode
\end{vdm_al}

\begin{vdm_al}
class OmlNondeterministicStatement is subclass of IOmlNondeterministicStatement
operations
  public identity: () ==> seq of char
  identity () == return "NondeterministicStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNondeterministicStatement(self);

  public OmlNondeterministicStatement:
    (seq of IOmlStatement) ==> OmlNondeterministicStatement
  OmlNondeterministicStatement (p1) == 
    ( setStatementList(p1) );

  public OmlNondeterministicStatement:
    (seq of IOmlStatement) *
    nat *
    nat ==> OmlNondeterministicStatement
  OmlNondeterministicStatement (p1,line,column) == 
    ( setStatementList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement_list" in
        if fname in set dom data
        then setStatementList(data(fname)) );

instance variables
  private ivStatementList : seq of IOmlStatement := []

operations
  public getStatementList: () ==> seq of IOmlStatement
  getStatementList() == return ivStatementList;

  public setStatementList: seq of IOmlStatement ==> ()
  setStatementList(parg) == ivStatementList := parg;

  public addStatementList: IOmlNode ==> ()
  addStatementList (parg) == ivStatementList := ivStatementList ^ [parg];

end OmlNondeterministicStatement
\end{vdm_al}

\begin{vdm_al}
class OmlNumericLiteral is subclass of IOmlNumericLiteral
operations
  public identity: () ==> seq of char
  identity () == return "NumericLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNumericLiteral(self);

  public OmlNumericLiteral:
    (nat) ==> OmlNumericLiteral
  OmlNumericLiteral (p1) == 
    ( setVal(p1) );

  public OmlNumericLiteral:
    (nat) *
    nat *
    nat ==> OmlNumericLiteral
  OmlNumericLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [nat] := nil

operations
  public getVal: () ==> nat
  getVal() == return ivVal;

  public setVal: nat ==> ()
  setVal(parg) == ivVal := parg;

end OmlNumericLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlObjectApply is subclass of IOmlObjectApply
operations
  public identity: () ==> seq of char
  identity () == return "ObjectApply";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectApply(self);

  public OmlObjectApply:
    (IOmlObjectDesignator) *
    (seq of IOmlExpression) ==> OmlObjectApply
  OmlObjectApply (p1,p2) == 
    ( setObjectDesignator(p1);
      setExpressionList(p2) );

  public OmlObjectApply:
    (IOmlObjectDesignator) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlObjectApply
  OmlObjectApply (p1,p2,line,column) == 
    ( setObjectDesignator(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator;

  public setObjectDesignator: IOmlObjectDesignator ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlObjectApply
\end{vdm_al}

\begin{vdm_al}
class OmlObjectDesignator is subclass of IOmlObjectDesignator
operations
  public identity: () ==> seq of char
  identity () == return "ObjectDesignator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectDesignator(self);

end OmlObjectDesignator
\end{vdm_al}
\begin{vdm_al}
class OmlObjectDesignatorExpression is subclass of IOmlObjectDesignatorExpression
operations
  public identity: () ==> seq of char
  identity () == return "ObjectDesignatorExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectDesignatorExpression(self);

  public OmlObjectDesignatorExpression:
    (IOmlExpression) ==> OmlObjectDesignatorExpression
  OmlObjectDesignatorExpression (p1) == 
    ( setExpression(p1) );

  public OmlObjectDesignatorExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlObjectDesignatorExpression
  OmlObjectDesignatorExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlObjectDesignatorExpression
\end{vdm_al}

\begin{vdm_al}
class OmlObjectFieldReference is subclass of IOmlObjectFieldReference
operations
  public identity: () ==> seq of char
  identity () == return "ObjectFieldReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectFieldReference(self);

  public OmlObjectFieldReference:
    (IOmlObjectDesignator) *
    (IOmlName) ==> OmlObjectFieldReference
  OmlObjectFieldReference (p1,p2) == 
    ( setObjectDesignator(p1);
      setName(p2) );

  public OmlObjectFieldReference:
    (IOmlObjectDesignator) *
    (IOmlName) *
    nat *
    nat ==> OmlObjectFieldReference
  OmlObjectFieldReference (p1,p2,line,column) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator;

  public setObjectDesignator: IOmlObjectDesignator ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlObjectFieldReference
\end{vdm_al}

\begin{vdm_al}
class OmlOldName is subclass of IOmlOldName
operations
  public identity: () ==> seq of char
  identity () == return "OldName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOldName(self);

  public OmlOldName:
    (seq of char) ==> OmlOldName
  OmlOldName (p1) == 
    ( setIdentifier(p1) );

  public OmlOldName:
    (seq of char) *
    nat *
    nat ==> OmlOldName
  OmlOldName (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlOldName
\end{vdm_al}

\begin{vdm_al}
class OmlOperationBody is subclass of IOmlOperationBody
operations
  public identity: () ==> seq of char
  identity () == return "OperationBody";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationBody(self);

  public OmlOperationBody:
    [IOmlStatement] *
    (bool) *
    (bool) ==> OmlOperationBody
  OmlOperationBody (p1,p2,p3) == 
    ( setStatement(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3) );

  public OmlOperationBody:
    [IOmlStatement] *
    (bool) *
    (bool) *
    nat *
    nat ==> OmlOperationBody
  OmlOperationBody (p1,p2,p3,line,column) == 
    ( setStatement(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname));
      let fname = "not_yet_specified" in
        if fname in set dom data
        then setNotYetSpecified(data(fname));
      let fname = "subclass_responsibility" in
        if fname in set dom data
        then setSubclassResponsibility(data(fname)) );

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement
    pre hasStatement();

  public hasStatement: () ==> bool
  hasStatement () == return ivStatement <> nil;

  public setStatement: [ IOmlStatement ] ==> ()
  setStatement(parg) == ivStatement := parg;

instance variables
  private ivNotYetSpecified : [bool] := nil

operations
  public getNotYetSpecified: () ==> bool
  getNotYetSpecified() == return ivNotYetSpecified;

  public setNotYetSpecified: bool ==> ()
  setNotYetSpecified(parg) == ivNotYetSpecified := parg;

instance variables
  private ivSubclassResponsibility : [bool] := nil

operations
  public getSubclassResponsibility: () ==> bool
  getSubclassResponsibility() == return ivSubclassResponsibility;

  public setSubclassResponsibility: bool ==> ()
  setSubclassResponsibility(parg) == ivSubclassResponsibility := parg;

end OmlOperationBody
\end{vdm_al}

\begin{vdm_al}
class OmlOperationDefinition is subclass of IOmlOperationDefinition
operations
  public identity: () ==> seq of char
  identity () == return "OperationDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationDefinition(self);

  public OmlOperationDefinition:
    (IOmlAccessDefinition) *
    (IOmlOperationShape) ==> OmlOperationDefinition
  OmlOperationDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlOperationDefinition:
    (IOmlAccessDefinition) *
    (IOmlOperationShape) *
    nat *
    nat ==> OmlOperationDefinition
  OmlOperationDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlOperationShape] := nil

operations
  public getShape: () ==> IOmlOperationShape
  getShape() == return ivShape;

  public setShape: IOmlOperationShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlOperationDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlOperationDefinitions is subclass of IOmlOperationDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "OperationDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationDefinitions(self);

  public OmlOperationDefinitions:
    (seq of IOmlOperationDefinition) ==> OmlOperationDefinitions
  OmlOperationDefinitions (p1) == 
    ( setOperationList(p1) );

  public OmlOperationDefinitions:
    (seq of IOmlOperationDefinition) *
    nat *
    nat ==> OmlOperationDefinitions
  OmlOperationDefinitions (p1,line,column) == 
    ( setOperationList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operation_list" in
        if fname in set dom data
        then setOperationList(data(fname)) );

instance variables
  private ivOperationList : seq of IOmlOperationDefinition := []

operations
  public getOperationList: () ==> seq of IOmlOperationDefinition
  getOperationList() == return ivOperationList;

  public setOperationList: seq of IOmlOperationDefinition ==> ()
  setOperationList(parg) == ivOperationList := parg;

  public addOperationList: IOmlNode ==> ()
  addOperationList (parg) == ivOperationList := ivOperationList ^ [parg];

end OmlOperationDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlOperationShape is subclass of IOmlOperationShape
operations
  public identity: () ==> seq of char
  identity () == return "OperationShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationShape(self);

end OmlOperationShape
\end{vdm_al}
\begin{vdm_al}
class OmlOperationTrailer is subclass of IOmlOperationTrailer
operations
  public identity: () ==> seq of char
  identity () == return "OperationTrailer";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationTrailer(self);

  public OmlOperationTrailer:
    [IOmlExternals] *
    [IOmlExpression] *
    [IOmlExpression] *
    [IOmlExceptions] ==> OmlOperationTrailer
  OmlOperationTrailer (p1,p2,p3,p4) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4) );

  public OmlOperationTrailer:
    [IOmlExternals] *
    [IOmlExpression] *
    [IOmlExpression] *
    [IOmlExceptions] *
    nat *
    nat ==> OmlOperationTrailer
  OmlOperationTrailer (p1,p2,p3,p4,line,column) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "externals" in
        if fname in set dom data
        then setExternals(data(fname));
      let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname));
      let fname = "exceptions" in
        if fname in set dom data
        then setExceptions(data(fname)) );

instance variables
  private ivExternals : [IOmlExternals] := nil

operations
  public getExternals: () ==> IOmlExternals
  getExternals() == return ivExternals
    pre hasExternals();

  public hasExternals: () ==> bool
  hasExternals () == return ivExternals <> nil;

  public setExternals: [ IOmlExternals ] ==> ()
  setExternals(parg) == ivExternals := parg;

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression
    pre hasPostExpression();

  public hasPostExpression: () ==> bool
  hasPostExpression () == return ivPostExpression <> nil;

  public setPostExpression: [ IOmlExpression ] ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

instance variables
  private ivExceptions : [IOmlExceptions] := nil

operations
  public getExceptions: () ==> IOmlExceptions
  getExceptions() == return ivExceptions
    pre hasExceptions();

  public hasExceptions: () ==> bool
  hasExceptions () == return ivExceptions <> nil;

  public setExceptions: [ IOmlExceptions ] ==> ()
  setExceptions(parg) == ivExceptions := parg;

end OmlOperationTrailer
\end{vdm_al}

\begin{vdm_al}
class OmlOperationType is subclass of IOmlOperationType
operations
  public identity: () ==> seq of char
  identity () == return "OperationType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationType(self);

  public OmlOperationType:
    (IOmlType) *
    (IOmlType) ==> OmlOperationType
  OmlOperationType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlOperationType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlOperationType
  OmlOperationType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlOperationType
\end{vdm_al}

\begin{vdm_al}
class OmlOptionalType is subclass of IOmlOptionalType
operations
  public identity: () ==> seq of char
  identity () == return "OptionalType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOptionalType(self);

  public OmlOptionalType:
    (IOmlType) ==> OmlOptionalType
  OmlOptionalType (p1) == 
    ( setType(p1) );

  public OmlOptionalType:
    (IOmlType) *
    nat *
    nat ==> OmlOptionalType
  OmlOptionalType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlOptionalType
\end{vdm_al}

\begin{vdm_al}
class OmlParameter is subclass of IOmlParameter
operations
  public identity: () ==> seq of char
  identity () == return "Parameter";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitParameter(self);

  public OmlParameter:
    (seq of IOmlPattern) ==> OmlParameter
  OmlParameter (p1) == 
    ( setPatternList(p1) );

  public OmlParameter:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlParameter
  OmlParameter (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlParameter
\end{vdm_al}

\begin{vdm_al}
class OmlPartialFunctionType is subclass of IOmlPartialFunctionType
operations
  public identity: () ==> seq of char
  identity () == return "PartialFunctionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPartialFunctionType(self);

  public OmlPartialFunctionType:
    (IOmlType) *
    (IOmlType) ==> OmlPartialFunctionType
  OmlPartialFunctionType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlPartialFunctionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlPartialFunctionType
  OmlPartialFunctionType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlPartialFunctionType
\end{vdm_al}

\begin{vdm_al}
class OmlPattern is subclass of IOmlPattern
operations
  public identity: () ==> seq of char
  identity () == return "Pattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPattern(self);

end OmlPattern
\end{vdm_al}
\begin{vdm_al}
class OmlPatternBind is subclass of IOmlPatternBind
operations
  public identity: () ==> seq of char
  identity () == return "PatternBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternBind(self);

end OmlPatternBind
\end{vdm_al}
\begin{vdm_al}
class OmlPatternBindExpression is subclass of IOmlPatternBindExpression
operations
  public identity: () ==> seq of char
  identity () == return "PatternBindExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternBindExpression(self);

  public OmlPatternBindExpression:
    (IOmlPatternBind) *
    (IOmlExpression) ==> OmlPatternBindExpression
  OmlPatternBindExpression (p1,p2) == 
    ( setPatternBind(p1);
      setExpression(p2) );

  public OmlPatternBindExpression:
    (IOmlPatternBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlPatternBindExpression
  OmlPatternBindExpression (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlPatternBindExpression
\end{vdm_al}

\begin{vdm_al}
class OmlPatternIdentifier is subclass of IOmlPatternIdentifier
operations
  public identity: () ==> seq of char
  identity () == return "PatternIdentifier";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternIdentifier(self);

  public OmlPatternIdentifier:
    (seq of char) ==> OmlPatternIdentifier
  OmlPatternIdentifier (p1) == 
    ( setIdentifier(p1) );

  public OmlPatternIdentifier:
    (seq of char) *
    nat *
    nat ==> OmlPatternIdentifier
  OmlPatternIdentifier (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlPatternIdentifier
\end{vdm_al}

\begin{vdm_al}
class OmlPatternTypePair is subclass of IOmlPatternTypePair
operations
  public identity: () ==> seq of char
  identity () == return "PatternTypePair";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternTypePair(self);

  public OmlPatternTypePair:
    (seq of IOmlPattern) *
    (IOmlType) ==> OmlPatternTypePair
  OmlPatternTypePair (p1,p2) == 
    ( setPatternList(p1);
      setType(p2) );

  public OmlPatternTypePair:
    (seq of IOmlPattern) *
    (IOmlType) *
    nat *
    nat ==> OmlPatternTypePair
  OmlPatternTypePair (p1,p2,line,column) == 
    ( setPatternList(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlPatternTypePair
\end{vdm_al}

\begin{vdm_al}
class OmlPeriodicThread is subclass of IOmlPeriodicThread
operations
  public identity: () ==> seq of char
  identity () == return "PeriodicThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPeriodicThread(self);

  public OmlPeriodicThread:
    (seq of IOmlExpression) *
    (IOmlName) ==> OmlPeriodicThread
  OmlPeriodicThread (p1,p2) == 
    ( setArgs(p1);
      setName(p2) );

  public OmlPeriodicThread:
    (seq of IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlPeriodicThread
  OmlPeriodicThread (p1,p2,line,column) == 
    ( setArgs(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlPeriodicThread
\end{vdm_al}

\begin{vdm_al}
class OmlPermissionPredicate is subclass of IOmlPermissionPredicate
operations
  public identity: () ==> seq of char
  identity () == return "PermissionPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPermissionPredicate(self);

  public OmlPermissionPredicate:
    (IOmlName) *
    (IOmlExpression) ==> OmlPermissionPredicate
  OmlPermissionPredicate (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlPermissionPredicate:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlPermissionPredicate
  OmlPermissionPredicate (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlPermissionPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlPreconditionExpression is subclass of IOmlPreconditionExpression
operations
  public identity: () ==> seq of char
  identity () == return "PreconditionExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPreconditionExpression(self);

  public OmlPreconditionExpression:
    (seq of IOmlExpression) ==> OmlPreconditionExpression
  OmlPreconditionExpression (p1) == 
    ( setExpressionList(p1) );

  public OmlPreconditionExpression:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlPreconditionExpression
  OmlPreconditionExpression (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlPreconditionExpression
\end{vdm_al}

\begin{vdm_al}
class OmlProcedureThread is subclass of IOmlProcedureThread
operations
  public identity: () ==> seq of char
  identity () == return "ProcedureThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitProcedureThread(self);

  public OmlProcedureThread:
    (IOmlStatement) ==> OmlProcedureThread
  OmlProcedureThread (p1) == 
    ( setStatement(p1) );

  public OmlProcedureThread:
    (IOmlStatement) *
    nat *
    nat ==> OmlProcedureThread
  OmlProcedureThread (p1,line,column) == 
    ( setStatement(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlProcedureThread
\end{vdm_al}

\begin{vdm_al}
class OmlProductType is subclass of IOmlProductType
operations
  public identity: () ==> seq of char
  identity () == return "ProductType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitProductType(self);

  public OmlProductType:
    (IOmlType) *
    (IOmlType) ==> OmlProductType
  OmlProductType (p1,p2) == 
    ( setLhsType(p1);
      setRhsType(p2) );

  public OmlProductType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlProductType
  OmlProductType (p1,p2,line,column) == 
    ( setLhsType(p1);
      setRhsType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_type" in
        if fname in set dom data
        then setLhsType(data(fname));
      let fname = "rhs_type" in
        if fname in set dom data
        then setRhsType(data(fname)) );

instance variables
  private ivLhsType : [IOmlType] := nil

operations
  public getLhsType: () ==> IOmlType
  getLhsType() == return ivLhsType;

  public setLhsType: IOmlType ==> ()
  setLhsType(parg) == ivLhsType := parg;

instance variables
  private ivRhsType : [IOmlType] := nil

operations
  public getRhsType: () ==> IOmlType
  getRhsType() == return ivRhsType;

  public setRhsType: IOmlType ==> ()
  setRhsType(parg) == ivRhsType := parg;

end OmlProductType
\end{vdm_al}

\begin{vdm_al}
class OmlQuoteLiteral is subclass of IOmlQuoteLiteral
operations
  public identity: () ==> seq of char
  identity () == return "QuoteLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitQuoteLiteral(self);

  public OmlQuoteLiteral:
    (seq of char) ==> OmlQuoteLiteral
  OmlQuoteLiteral (p1) == 
    ( setVal(p1) );

  public OmlQuoteLiteral:
    (seq of char) *
    nat *
    nat ==> OmlQuoteLiteral
  OmlQuoteLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : seq of char := []

operations
  public getVal: () ==> seq of char
  getVal() == return ivVal;

  public setVal: seq of char ==> ()
  setVal(parg) == ivVal := parg;

end OmlQuoteLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlQuoteType is subclass of IOmlQuoteType
operations
  public identity: () ==> seq of char
  identity () == return "QuoteType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitQuoteType(self);

  public OmlQuoteType:
    (IOmlQuoteLiteral) ==> OmlQuoteType
  OmlQuoteType (p1) == 
    ( setQuoteLiteral(p1) );

  public OmlQuoteType:
    (IOmlQuoteLiteral) *
    nat *
    nat ==> OmlQuoteType
  OmlQuoteType (p1,line,column) == 
    ( setQuoteLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "quote_literal" in
        if fname in set dom data
        then setQuoteLiteral(data(fname)) );

instance variables
  private ivQuoteLiteral : [IOmlQuoteLiteral] := nil

operations
  public getQuoteLiteral: () ==> IOmlQuoteLiteral
  getQuoteLiteral() == return ivQuoteLiteral;

  public setQuoteLiteral: IOmlQuoteLiteral ==> ()
  setQuoteLiteral(parg) == ivQuoteLiteral := parg;

end OmlQuoteType
\end{vdm_al}

\begin{vdm_al}
class OmlRatType is subclass of IOmlRatType
operations
  public identity: () ==> seq of char
  identity () == return "RatType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRatType(self);

  public OmlRatType:
    () ==> OmlRatType
  OmlRatType () == 
    skip;

  public OmlRatType:
    nat *
    nat ==> OmlRatType
  OmlRatType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlRatType
\end{vdm_al}

\begin{vdm_al}
class OmlRealLiteral is subclass of IOmlRealLiteral
operations
  public identity: () ==> seq of char
  identity () == return "RealLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRealLiteral(self);

  public OmlRealLiteral:
    (real) ==> OmlRealLiteral
  OmlRealLiteral (p1) == 
    ( setVal(p1) );

  public OmlRealLiteral:
    (real) *
    nat *
    nat ==> OmlRealLiteral
  OmlRealLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [real] := nil

operations
  public getVal: () ==> real
  getVal() == return ivVal;

  public setVal: real ==> ()
  setVal(parg) == ivVal := parg;

end OmlRealLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlRealType is subclass of IOmlRealType
operations
  public identity: () ==> seq of char
  identity () == return "RealType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRealType(self);

  public OmlRealType:
    () ==> OmlRealType
  OmlRealType () == 
    skip;

  public OmlRealType:
    nat *
    nat ==> OmlRealType
  OmlRealType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlRealType
\end{vdm_al}

\begin{vdm_al}
class OmlRecordConstructor is subclass of IOmlRecordConstructor
operations
  public identity: () ==> seq of char
  identity () == return "RecordConstructor";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordConstructor(self);

  public OmlRecordConstructor:
    (IOmlName) *
    (seq of IOmlExpression) ==> OmlRecordConstructor
  OmlRecordConstructor (p1,p2) == 
    ( setName(p1);
      setExpressionList(p2) );

  public OmlRecordConstructor:
    (IOmlName) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlRecordConstructor
  OmlRecordConstructor (p1,p2,line,column) == 
    ( setName(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlRecordConstructor
\end{vdm_al}

\begin{vdm_al}
class OmlRecordModifier is subclass of IOmlRecordModifier
operations
  public identity: () ==> seq of char
  identity () == return "RecordModifier";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordModifier(self);

  public OmlRecordModifier:
    (seq of char) *
    (IOmlExpression) ==> OmlRecordModifier
  OmlRecordModifier (p1,p2) == 
    ( setIdentifier(p1);
      setExpression(p2) );

  public OmlRecordModifier:
    (seq of char) *
    (IOmlExpression) *
    nat *
    nat ==> OmlRecordModifier
  OmlRecordModifier (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlRecordModifier
\end{vdm_al}

\begin{vdm_al}
class OmlRecordPattern is subclass of IOmlRecordPattern
operations
  public identity: () ==> seq of char
  identity () == return "RecordPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordPattern(self);

  public OmlRecordPattern:
    (IOmlName) *
    (seq of IOmlPattern) ==> OmlRecordPattern
  OmlRecordPattern (p1,p2) == 
    ( setName(p1);
      setPatternList(p2) );

  public OmlRecordPattern:
    (IOmlName) *
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlRecordPattern
  OmlRecordPattern (p1,p2,line,column) == 
    ( setName(p1);
      setPatternList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlRecordPattern
\end{vdm_al}

\begin{vdm_al}
class OmlRecursiveTrapStatement is subclass of IOmlRecursiveTrapStatement
operations
  public identity: () ==> seq of char
  identity () == return "RecursiveTrapStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecursiveTrapStatement(self);

  public OmlRecursiveTrapStatement:
    (seq of IOmlTrapDefinition) *
    (IOmlStatement) ==> OmlRecursiveTrapStatement
  OmlRecursiveTrapStatement (p1,p2) == 
    ( setTrapList(p1);
      setInPart(p2) );

  public OmlRecursiveTrapStatement:
    (seq of IOmlTrapDefinition) *
    (IOmlStatement) *
    nat *
    nat ==> OmlRecursiveTrapStatement
  OmlRecursiveTrapStatement (p1,p2,line,column) == 
    ( setTrapList(p1);
      setInPart(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "trap_list" in
        if fname in set dom data
        then setTrapList(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivTrapList : seq of IOmlTrapDefinition := []

operations
  public getTrapList: () ==> seq of IOmlTrapDefinition
  getTrapList() == return ivTrapList;

  public setTrapList: seq of IOmlTrapDefinition ==> ()
  setTrapList(parg) == ivTrapList := parg;

  public addTrapList: IOmlNode ==> ()
  addTrapList (parg) == ivTrapList := ivTrapList ^ [parg];

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlRecursiveTrapStatement
\end{vdm_al}

\begin{vdm_al}
class OmlReqExpression is subclass of IOmlReqExpression
operations
  public identity: () ==> seq of char
  identity () == return "ReqExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitReqExpression(self);

  public OmlReqExpression:
    (seq of IOmlName) ==> OmlReqExpression
  OmlReqExpression (p1) == 
    ( setNameList(p1) );

  public OmlReqExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlReqExpression
  OmlReqExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlReqExpression
\end{vdm_al}

\begin{vdm_al}
class OmlReturnStatement is subclass of IOmlReturnStatement
operations
  public identity: () ==> seq of char
  identity () == return "ReturnStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitReturnStatement(self);

  public OmlReturnStatement:
    [IOmlExpression] ==> OmlReturnStatement
  OmlReturnStatement (p1) == 
    ( setExpression(p1) );

  public OmlReturnStatement:
    [IOmlExpression] *
    nat *
    nat ==> OmlReturnStatement
  OmlReturnStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlReturnStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSamebaseclassExpression is subclass of IOmlSamebaseclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "SamebaseclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSamebaseclassExpression(self);

  public OmlSamebaseclassExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSamebaseclassExpression
  OmlSamebaseclassExpression (p1,p2) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2) );

  public OmlSamebaseclassExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSamebaseclassExpression
  OmlSamebaseclassExpression (p1,p2,line,column) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlSamebaseclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSameclassExpression is subclass of IOmlSameclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "SameclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSameclassExpression(self);

  public OmlSameclassExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSameclassExpression
  OmlSameclassExpression (p1,p2) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2) );

  public OmlSameclassExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSameclassExpression
  OmlSameclassExpression (p1,p2,line,column) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlSameclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlScope is subclass of IOmlScope
operations
  public identity: () ==> seq of char
  identity () == return "Scope";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitScope(self);

  public OmlScope: nat ==> OmlScope
  OmlScope (pv) == setValue(pv);

  public OmlScope: nat * nat * nat ==> OmlScope
  OmlScope (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlScopeQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlScopeQuotes`getQuoteName(val)
    pre val <> nil;

end OmlScope
\end{vdm_al}
\begin{vdm_al}
class OmlScopeQuotes
values
  static public IQPROTECTED : nat = 0;
  static public IQPRIVATE : nat = 1;
  static public IQPUBLIC : nat = 2;
  static public IQDEFAULT : nat = 3;
instance variables


  static private qmap : map nat to seq of char :=
    { IQPROTECTED |-> "<PROTECTED>",
      IQPRIVATE |-> "<PRIVATE>",
      IQPUBLIC |-> "<PUBLIC>",
      IQDEFAULT |-> "<DEFAULT>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlScopeQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlSelfExpression is subclass of IOmlSelfExpression
operations
  public identity: () ==> seq of char
  identity () == return "SelfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSelfExpression(self);

  public OmlSelfExpression:
    () ==> OmlSelfExpression
  OmlSelfExpression () == 
    skip;

  public OmlSelfExpression:
    nat *
    nat ==> OmlSelfExpression
  OmlSelfExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlSelfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSeq0Type is subclass of IOmlSeq0Type
operations
  public identity: () ==> seq of char
  identity () == return "Seq0Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeq0Type(self);

  public OmlSeq0Type:
    (IOmlType) ==> OmlSeq0Type
  OmlSeq0Type (p1) == 
    ( setType(p1) );

  public OmlSeq0Type:
    (IOmlType) *
    nat *
    nat ==> OmlSeq0Type
  OmlSeq0Type (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSeq0Type
\end{vdm_al}

\begin{vdm_al}
class OmlSeq1Type is subclass of IOmlSeq1Type
operations
  public identity: () ==> seq of char
  identity () == return "Seq1Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeq1Type(self);

  public OmlSeq1Type:
    (IOmlType) ==> OmlSeq1Type
  OmlSeq1Type (p1) == 
    ( setType(p1) );

  public OmlSeq1Type:
    (IOmlType) *
    nat *
    nat ==> OmlSeq1Type
  OmlSeq1Type (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSeq1Type
\end{vdm_al}

\begin{vdm_al}
class OmlSeqConcPattern is subclass of IOmlSeqConcPattern
operations
  public identity: () ==> seq of char
  identity () == return "SeqConcPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeqConcPattern(self);

  public OmlSeqConcPattern:
    (IOmlPattern) *
    (IOmlPattern) ==> OmlSeqConcPattern
  OmlSeqConcPattern (p1,p2) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2) );

  public OmlSeqConcPattern:
    (IOmlPattern) *
    (IOmlPattern) *
    nat *
    nat ==> OmlSeqConcPattern
  OmlSeqConcPattern (p1,p2,line,column) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_pattern" in
        if fname in set dom data
        then setLhsPattern(data(fname));
      let fname = "rhs_pattern" in
        if fname in set dom data
        then setRhsPattern(data(fname)) );

instance variables
  private ivLhsPattern : [IOmlPattern] := nil

operations
  public getLhsPattern: () ==> IOmlPattern
  getLhsPattern() == return ivLhsPattern;

  public setLhsPattern: IOmlPattern ==> ()
  setLhsPattern(parg) == ivLhsPattern := parg;

instance variables
  private ivRhsPattern : [IOmlPattern] := nil

operations
  public getRhsPattern: () ==> IOmlPattern
  getRhsPattern() == return ivRhsPattern;

  public setRhsPattern: IOmlPattern ==> ()
  setRhsPattern(parg) == ivRhsPattern := parg;

end OmlSeqConcPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSeqEnumPattern is subclass of IOmlSeqEnumPattern
operations
  public identity: () ==> seq of char
  identity () == return "SeqEnumPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeqEnumPattern(self);

  public OmlSeqEnumPattern:
    (seq of IOmlPattern) ==> OmlSeqEnumPattern
  OmlSeqEnumPattern (p1) == 
    ( setPatternList(p1) );

  public OmlSeqEnumPattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlSeqEnumPattern
  OmlSeqEnumPattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlSeqEnumPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceComprehension is subclass of IOmlSequenceComprehension
operations
  public identity: () ==> seq of char
  identity () == return "SequenceComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceComprehension(self);

  public OmlSequenceComprehension:
    (IOmlExpression) *
    (IOmlSetBind) *
    [IOmlExpression] ==> OmlSequenceComprehension
  OmlSequenceComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setSetBind(p2);
      setGuard(p3) );

  public OmlSequenceComprehension:
    (IOmlExpression) *
    (IOmlSetBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlSequenceComprehension
  OmlSequenceComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setSetBind(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "set_bind" in
        if fname in set dom data
        then setSetBind(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivSetBind : [IOmlSetBind] := nil

operations
  public getSetBind: () ==> IOmlSetBind
  getSetBind() == return ivSetBind;

  public setSetBind: IOmlSetBind ==> ()
  setSetBind(parg) == ivSetBind := parg;

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlSequenceComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceEnumeration is subclass of IOmlSequenceEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "SequenceEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceEnumeration(self);

  public OmlSequenceEnumeration:
    (seq of IOmlExpression) ==> OmlSequenceEnumeration
  OmlSequenceEnumeration (p1) == 
    ( setExpressionList(p1) );

  public OmlSequenceEnumeration:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlSequenceEnumeration
  OmlSequenceEnumeration (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlSequenceEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceForLoop is subclass of IOmlSequenceForLoop
operations
  public identity: () ==> seq of char
  identity () == return "SequenceForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceForLoop(self);

  public OmlSequenceForLoop:
    (IOmlPatternBind) *
    (bool) *
    (IOmlExpression) *
    (IOmlStatement) ==> OmlSequenceForLoop
  OmlSequenceForLoop (p1,p2,p3,p4) == 
    ( setPatternBind(p1);
      setInReverse(p2);
      setExpression(p3);
      setStatement(p4) );

  public OmlSequenceForLoop:
    (IOmlPatternBind) *
    (bool) *
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlSequenceForLoop
  OmlSequenceForLoop (p1,p2,p3,p4,line,column) == 
    ( setPatternBind(p1);
      setInReverse(p2);
      setExpression(p3);
      setStatement(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "in_reverse" in
        if fname in set dom data
        then setInReverse(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivInReverse : [bool] := nil

operations
  public getInReverse: () ==> bool
  getInReverse() == return ivInReverse;

  public setInReverse: bool ==> ()
  setInReverse(parg) == ivInReverse := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlSequenceForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlSetBind is subclass of IOmlSetBind
operations
  public identity: () ==> seq of char
  identity () == return "SetBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetBind(self);

  public OmlSetBind:
    (seq of IOmlPattern) *
    (IOmlExpression) ==> OmlSetBind
  OmlSetBind (p1,p2) == 
    ( setPattern(p1);
      setExpression(p2) );

  public OmlSetBind:
    (seq of IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSetBind
  OmlSetBind (p1,p2,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : seq of IOmlPattern := []

operations
  public getPattern: () ==> seq of IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: seq of IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

  public addPattern: IOmlNode ==> ()
  addPattern (parg) == ivPattern := ivPattern ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlSetBind
\end{vdm_al}

\begin{vdm_al}
class OmlSetComprehension is subclass of IOmlSetComprehension
operations
  public identity: () ==> seq of char
  identity () == return "SetComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetComprehension(self);

  public OmlSetComprehension:
    (IOmlExpression) *
    (seq of IOmlBind) *
    [IOmlExpression] ==> OmlSetComprehension
  OmlSetComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3) );

  public OmlSetComprehension:
    (IOmlExpression) *
    (seq of IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlSetComprehension
  OmlSetComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlSetComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlSetEnumPattern is subclass of IOmlSetEnumPattern
operations
  public identity: () ==> seq of char
  identity () == return "SetEnumPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetEnumPattern(self);

  public OmlSetEnumPattern:
    (seq of IOmlPattern) ==> OmlSetEnumPattern
  OmlSetEnumPattern (p1) == 
    ( setPatternList(p1) );

  public OmlSetEnumPattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlSetEnumPattern
  OmlSetEnumPattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlSetEnumPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSetEnumeration is subclass of IOmlSetEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "SetEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetEnumeration(self);

  public OmlSetEnumeration:
    (seq of IOmlExpression) ==> OmlSetEnumeration
  OmlSetEnumeration (p1) == 
    ( setExpressionList(p1) );

  public OmlSetEnumeration:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlSetEnumeration
  OmlSetEnumeration (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlSetEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlSetForLoop is subclass of IOmlSetForLoop
operations
  public identity: () ==> seq of char
  identity () == return "SetForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetForLoop(self);

  public OmlSetForLoop:
    (IOmlPattern) *
    (IOmlExpression) *
    (IOmlStatement) ==> OmlSetForLoop
  OmlSetForLoop (p1,p2,p3) == 
    ( setPattern(p1);
      setExpression(p2);
      setStatement(p3) );

  public OmlSetForLoop:
    (IOmlPattern) *
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlSetForLoop
  OmlSetForLoop (p1,p2,p3,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlSetForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlSetRangeExpression is subclass of IOmlSetRangeExpression
operations
  public identity: () ==> seq of char
  identity () == return "SetRangeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetRangeExpression(self);

  public OmlSetRangeExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSetRangeExpression
  OmlSetRangeExpression (p1,p2) == 
    ( setLower(p1);
      setUpper(p2) );

  public OmlSetRangeExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSetRangeExpression
  OmlSetRangeExpression (p1,p2,line,column) == 
    ( setLower(p1);
      setUpper(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivLower : [IOmlExpression] := nil

operations
  public getLower: () ==> IOmlExpression
  getLower() == return ivLower;

  public setLower: IOmlExpression ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlExpression] := nil

operations
  public getUpper: () ==> IOmlExpression
  getUpper() == return ivUpper;

  public setUpper: IOmlExpression ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlSetRangeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSetType is subclass of IOmlSetType
operations
  public identity: () ==> seq of char
  identity () == return "SetType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetType(self);

  public OmlSetType:
    (IOmlType) ==> OmlSetType
  OmlSetType (p1) == 
    ( setType(p1) );

  public OmlSetType:
    (IOmlType) *
    nat *
    nat ==> OmlSetType
  OmlSetType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSetType
\end{vdm_al}

\begin{vdm_al}
class OmlSetUnionPattern is subclass of IOmlSetUnionPattern
operations
  public identity: () ==> seq of char
  identity () == return "SetUnionPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetUnionPattern(self);

  public OmlSetUnionPattern:
    (IOmlPattern) *
    (IOmlPattern) ==> OmlSetUnionPattern
  OmlSetUnionPattern (p1,p2) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2) );

  public OmlSetUnionPattern:
    (IOmlPattern) *
    (IOmlPattern) *
    nat *
    nat ==> OmlSetUnionPattern
  OmlSetUnionPattern (p1,p2,line,column) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_pattern" in
        if fname in set dom data
        then setLhsPattern(data(fname));
      let fname = "rhs_pattern" in
        if fname in set dom data
        then setRhsPattern(data(fname)) );

instance variables
  private ivLhsPattern : [IOmlPattern] := nil

operations
  public getLhsPattern: () ==> IOmlPattern
  getLhsPattern() == return ivLhsPattern;

  public setLhsPattern: IOmlPattern ==> ()
  setLhsPattern(parg) == ivLhsPattern := parg;

instance variables
  private ivRhsPattern : [IOmlPattern] := nil

operations
  public getRhsPattern: () ==> IOmlPattern
  getRhsPattern() == return ivRhsPattern;

  public setRhsPattern: IOmlPattern ==> ()
  setRhsPattern(parg) == ivRhsPattern := parg;

end OmlSetUnionPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSimpleType is subclass of IOmlSimpleType
operations
  public identity: () ==> seq of char
  identity () == return "SimpleType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSimpleType(self);

  public OmlSimpleType:
    (seq of char) *
    (IOmlType) *
    [IOmlInvariant] ==> OmlSimpleType
  OmlSimpleType (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setInvariant(p3) );

  public OmlSimpleType:
    (seq of char) *
    (IOmlType) *
    [IOmlInvariant] *
    nat *
    nat ==> OmlSimpleType
  OmlSimpleType (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setInvariant(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivInvariant : [IOmlInvariant] := nil

operations
  public getInvariant: () ==> IOmlInvariant
  getInvariant() == return ivInvariant
    pre hasInvariant();

  public hasInvariant: () ==> bool
  hasInvariant () == return ivInvariant <> nil;

  public setInvariant: [ IOmlInvariant ] ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlSimpleType
\end{vdm_al}

\begin{vdm_al}
class OmlSkipStatement is subclass of IOmlSkipStatement
operations
  public identity: () ==> seq of char
  identity () == return "SkipStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSkipStatement(self);

  public OmlSkipStatement:
    () ==> OmlSkipStatement
  OmlSkipStatement () == 
    skip;

  public OmlSkipStatement:
    nat *
    nat ==> OmlSkipStatement
  OmlSkipStatement (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlSkipStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSpecificationStatement is subclass of IOmlSpecificationStatement
operations
  public identity: () ==> seq of char
  identity () == return "SpecificationStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSpecificationStatement(self);

  public OmlSpecificationStatement:
    [IOmlExternals] *
    [IOmlExpression] *
    (IOmlExpression) *
    [IOmlExceptions] ==> OmlSpecificationStatement
  OmlSpecificationStatement (p1,p2,p3,p4) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4) );

  public OmlSpecificationStatement:
    [IOmlExternals] *
    [IOmlExpression] *
    (IOmlExpression) *
    [IOmlExceptions] *
    nat *
    nat ==> OmlSpecificationStatement
  OmlSpecificationStatement (p1,p2,p3,p4,line,column) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "externals" in
        if fname in set dom data
        then setExternals(data(fname));
      let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname));
      let fname = "exceptions" in
        if fname in set dom data
        then setExceptions(data(fname)) );

instance variables
  private ivExternals : [IOmlExternals] := nil

operations
  public getExternals: () ==> IOmlExternals
  getExternals() == return ivExternals
    pre hasExternals();

  public hasExternals: () ==> bool
  hasExternals () == return ivExternals <> nil;

  public setExternals: [ IOmlExternals ] ==> ()
  setExternals(parg) == ivExternals := parg;

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression;

  public setPostExpression: IOmlExpression ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

instance variables
  private ivExceptions : [IOmlExceptions] := nil

operations
  public getExceptions: () ==> IOmlExceptions
  getExceptions() == return ivExceptions
    pre hasExceptions();

  public hasExceptions: () ==> bool
  hasExceptions () == return ivExceptions <> nil;

  public setExceptions: [ IOmlExceptions ] ==> ()
  setExceptions(parg) == ivExceptions := parg;

end OmlSpecificationStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSpecifications is subclass of IOmlSpecifications
operations
  public identity: () ==> seq of char
  identity () == return "Specifications";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSpecifications(self);

  public OmlSpecifications:
    (seq of IOmlClass) ==> OmlSpecifications
  OmlSpecifications (p1) == 
    ( setClassList(p1) );

  public OmlSpecifications:
    (seq of IOmlClass) *
    nat *
    nat ==> OmlSpecifications
  OmlSpecifications (p1,line,column) == 
    ( setClassList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "class_list" in
        if fname in set dom data
        then setClassList(data(fname)) );

instance variables
  private ivClassList : seq of IOmlClass := []

operations
  public getClassList: () ==> seq of IOmlClass
  getClassList() == return ivClassList;

  public setClassList: seq of IOmlClass ==> ()
  setClassList(parg) == ivClassList := parg;

  public addClassList: IOmlNode ==> ()
  addClassList (parg) == ivClassList := ivClassList ^ [parg];

end OmlSpecifications
\end{vdm_al}

\begin{vdm_al}
class OmlSporadicThread is subclass of IOmlSporadicThread
operations
  public identity: () ==> seq of char
  identity () == return "SporadicThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSporadicThread(self);

  public OmlSporadicThread:
    (seq of IOmlExpression) *
    (IOmlName) ==> OmlSporadicThread
  OmlSporadicThread (p1,p2) == 
    ( setArgs(p1);
      setName(p2) );

  public OmlSporadicThread:
    (seq of IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlSporadicThread
  OmlSporadicThread (p1,p2,line,column) == 
    ( setArgs(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlSporadicThread
\end{vdm_al}

\begin{vdm_al}
class OmlStartStatement is subclass of IOmlStartStatement
operations
  public identity: () ==> seq of char
  identity () == return "StartStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStartStatement(self);

  public OmlStartStatement:
    (IOmlExpression) ==> OmlStartStatement
  OmlStartStatement (p1) == 
    ( setExpression(p1) );

  public OmlStartStatement:
    (IOmlExpression) *
    nat *
    nat ==> OmlStartStatement
  OmlStartStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlStartStatement
\end{vdm_al}

\begin{vdm_al}
class OmlStateDesignator is subclass of IOmlStateDesignator
operations
  public identity: () ==> seq of char
  identity () == return "StateDesignator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStateDesignator(self);

end OmlStateDesignator
\end{vdm_al}
\begin{vdm_al}
class OmlStateDesignatorName is subclass of IOmlStateDesignatorName
operations
  public identity: () ==> seq of char
  identity () == return "StateDesignatorName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStateDesignatorName(self);

  public OmlStateDesignatorName:
    (IOmlName) ==> OmlStateDesignatorName
  OmlStateDesignatorName (p1) == 
    ( setName(p1) );

  public OmlStateDesignatorName:
    (IOmlName) *
    nat *
    nat ==> OmlStateDesignatorName
  OmlStateDesignatorName (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlStateDesignatorName
\end{vdm_al}

\begin{vdm_al}
class OmlStatement is subclass of IOmlStatement
operations
  public identity: () ==> seq of char
  identity () == return "Statement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStatement(self);

end OmlStatement
\end{vdm_al}
\begin{vdm_al}
class OmlSubsequenceExpression is subclass of IOmlSubsequenceExpression
operations
  public identity: () ==> seq of char
  identity () == return "SubsequenceExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSubsequenceExpression(self);

  public OmlSubsequenceExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSubsequenceExpression
  OmlSubsequenceExpression (p1,p2,p3) == 
    ( setExpression(p1);
      setLower(p2);
      setUpper(p3) );

  public OmlSubsequenceExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSubsequenceExpression
  OmlSubsequenceExpression (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setLower(p2);
      setUpper(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivLower : [IOmlExpression] := nil

operations
  public getLower: () ==> IOmlExpression
  getLower() == return ivLower;

  public setLower: IOmlExpression ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlExpression] := nil

operations
  public getUpper: () ==> IOmlExpression
  getUpper() == return ivUpper;

  public setUpper: IOmlExpression ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlSubsequenceExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSymbolicLiteralExpression is subclass of IOmlSymbolicLiteralExpression
operations
  public identity: () ==> seq of char
  identity () == return "SymbolicLiteralExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSymbolicLiteralExpression(self);

  public OmlSymbolicLiteralExpression:
    (IOmlLiteral) ==> OmlSymbolicLiteralExpression
  OmlSymbolicLiteralExpression (p1) == 
    ( setLiteral(p1) );

  public OmlSymbolicLiteralExpression:
    (IOmlLiteral) *
    nat *
    nat ==> OmlSymbolicLiteralExpression
  OmlSymbolicLiteralExpression (p1,line,column) == 
    ( setLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "literal" in
        if fname in set dom data
        then setLiteral(data(fname)) );

instance variables
  private ivLiteral : [IOmlLiteral] := nil

operations
  public getLiteral: () ==> IOmlLiteral
  getLiteral() == return ivLiteral;

  public setLiteral: IOmlLiteral ==> ()
  setLiteral(parg) == ivLiteral := parg;

end OmlSymbolicLiteralExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSymbolicLiteralPattern is subclass of IOmlSymbolicLiteralPattern
operations
  public identity: () ==> seq of char
  identity () == return "SymbolicLiteralPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSymbolicLiteralPattern(self);

  public OmlSymbolicLiteralPattern:
    (IOmlLiteral) ==> OmlSymbolicLiteralPattern
  OmlSymbolicLiteralPattern (p1) == 
    ( setLiteral(p1) );

  public OmlSymbolicLiteralPattern:
    (IOmlLiteral) *
    nat *
    nat ==> OmlSymbolicLiteralPattern
  OmlSymbolicLiteralPattern (p1,line,column) == 
    ( setLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "literal" in
        if fname in set dom data
        then setLiteral(data(fname)) );

instance variables
  private ivLiteral : [IOmlLiteral] := nil

operations
  public getLiteral: () ==> IOmlLiteral
  getLiteral() == return ivLiteral;

  public setLiteral: IOmlLiteral ==> ()
  setLiteral(parg) == ivLiteral := parg;

end OmlSymbolicLiteralPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSyncPredicate is subclass of IOmlSyncPredicate
operations
  public identity: () ==> seq of char
  identity () == return "SyncPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSyncPredicate(self);

end OmlSyncPredicate
\end{vdm_al}
\begin{vdm_al}
class OmlSynchronizationDefinitions is subclass of IOmlSynchronizationDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "SynchronizationDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSynchronizationDefinitions(self);

  public OmlSynchronizationDefinitions:
    (seq of IOmlSyncPredicate) ==> OmlSynchronizationDefinitions
  OmlSynchronizationDefinitions (p1) == 
    ( setSyncList(p1) );

  public OmlSynchronizationDefinitions:
    (seq of IOmlSyncPredicate) *
    nat *
    nat ==> OmlSynchronizationDefinitions
  OmlSynchronizationDefinitions (p1,line,column) == 
    ( setSyncList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "sync_list" in
        if fname in set dom data
        then setSyncList(data(fname)) );

instance variables
  private ivSyncList : seq of IOmlSyncPredicate := []

operations
  public getSyncList: () ==> seq of IOmlSyncPredicate
  getSyncList() == return ivSyncList;

  public setSyncList: seq of IOmlSyncPredicate ==> ()
  setSyncList(parg) == ivSyncList := parg;

  public addSyncList: IOmlNode ==> ()
  addSyncList (parg) == ivSyncList := ivSyncList ^ [parg];

end OmlSynchronizationDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTextLiteral is subclass of IOmlTextLiteral
operations
  public identity: () ==> seq of char
  identity () == return "TextLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTextLiteral(self);

  public OmlTextLiteral:
    (seq of char) ==> OmlTextLiteral
  OmlTextLiteral (p1) == 
    ( setVal(p1) );

  public OmlTextLiteral:
    (seq of char) *
    nat *
    nat ==> OmlTextLiteral
  OmlTextLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : seq of char := []

operations
  public getVal: () ==> seq of char
  getVal() == return ivVal;

  public setVal: seq of char ==> ()
  setVal(parg) == ivVal := parg;

end OmlTextLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlThreadDefinition is subclass of IOmlThreadDefinition
operations
  public identity: () ==> seq of char
  identity () == return "ThreadDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadDefinition(self);

  public OmlThreadDefinition:
    [IOmlThreadSpecification] ==> OmlThreadDefinition
  OmlThreadDefinition (p1) == 
    ( setThreadSpecification(p1) );

  public OmlThreadDefinition:
    [IOmlThreadSpecification] *
    nat *
    nat ==> OmlThreadDefinition
  OmlThreadDefinition (p1,line,column) == 
    ( setThreadSpecification(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "thread_specification" in
        if fname in set dom data
        then setThreadSpecification(data(fname)) );

instance variables
  private ivThreadSpecification : [IOmlThreadSpecification] := nil

operations
  public getThreadSpecification: () ==> IOmlThreadSpecification
  getThreadSpecification() == return ivThreadSpecification
    pre hasThreadSpecification();

  public hasThreadSpecification: () ==> bool
  hasThreadSpecification () == return ivThreadSpecification <> nil;

  public setThreadSpecification: [ IOmlThreadSpecification ] ==> ()
  setThreadSpecification(parg) == ivThreadSpecification := parg;

end OmlThreadDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlThreadIdExpression is subclass of IOmlThreadIdExpression
operations
  public identity: () ==> seq of char
  identity () == return "ThreadIdExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadIdExpression(self);

  public OmlThreadIdExpression:
    () ==> OmlThreadIdExpression
  OmlThreadIdExpression () == 
    skip;

  public OmlThreadIdExpression:
    nat *
    nat ==> OmlThreadIdExpression
  OmlThreadIdExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlThreadIdExpression
\end{vdm_al}

\begin{vdm_al}
class OmlThreadSpecification is subclass of IOmlThreadSpecification
operations
  public identity: () ==> seq of char
  identity () == return "ThreadSpecification";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadSpecification(self);

end OmlThreadSpecification
\end{vdm_al}
\begin{vdm_al}
class OmlTimeExpression is subclass of IOmlTimeExpression
operations
  public identity: () ==> seq of char
  identity () == return "TimeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTimeExpression(self);

  public OmlTimeExpression:
    () ==> OmlTimeExpression
  OmlTimeExpression () == 
    skip;

  public OmlTimeExpression:
    nat *
    nat ==> OmlTimeExpression
  OmlTimeExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTimeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlTokenExpression is subclass of IOmlTokenExpression
operations
  public identity: () ==> seq of char
  identity () == return "TokenExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTokenExpression(self);

  public OmlTokenExpression:
    (IOmlExpression) ==> OmlTokenExpression
  OmlTokenExpression (p1) == 
    ( setExpression(p1) );

  public OmlTokenExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlTokenExpression
  OmlTokenExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlTokenExpression
\end{vdm_al}

\begin{vdm_al}
class OmlTokenType is subclass of IOmlTokenType
operations
  public identity: () ==> seq of char
  identity () == return "TokenType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTokenType(self);

  public OmlTokenType:
    () ==> OmlTokenType
  OmlTokenType () == 
    skip;

  public OmlTokenType:
    nat *
    nat ==> OmlTokenType
  OmlTokenType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTokenType
\end{vdm_al}

\begin{vdm_al}
class OmlTotalFunctionType is subclass of IOmlTotalFunctionType
operations
  public identity: () ==> seq of char
  identity () == return "TotalFunctionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTotalFunctionType(self);

  public OmlTotalFunctionType:
    (IOmlType) *
    (IOmlType) ==> OmlTotalFunctionType
  OmlTotalFunctionType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlTotalFunctionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlTotalFunctionType
  OmlTotalFunctionType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlTotalFunctionType
\end{vdm_al}

\begin{vdm_al}
class OmlTraceBinding is subclass of IOmlTraceBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceBinding(self);

end OmlTraceBinding
\end{vdm_al}
\begin{vdm_al}
class OmlTraceBracketedDefinition is subclass of IOmlTraceBracketedDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceBracketedDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceBracketedDefinition(self);

  public OmlTraceBracketedDefinition:
    (IOmlTraceDefinition) ==> OmlTraceBracketedDefinition
  OmlTraceBracketedDefinition (p1) == 
    ( setDefinition(p1) );

  public OmlTraceBracketedDefinition:
    (IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceBracketedDefinition
  OmlTraceBracketedDefinition (p1,line,column) == 
    ( setDefinition(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition" in
        if fname in set dom data
        then setDefinition(data(fname)) );

instance variables
  private ivDefinition : [IOmlTraceDefinition] := nil

operations
  public getDefinition: () ==> IOmlTraceDefinition
  getDefinition() == return ivDefinition;

  public setDefinition: IOmlTraceDefinition ==> ()
  setDefinition(parg) == ivDefinition := parg;

end OmlTraceBracketedDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceChoiceDefinition is subclass of IOmlTraceChoiceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceChoiceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceChoiceDefinition(self);

  public OmlTraceChoiceDefinition:
    (seq of IOmlTraceDefinition) ==> OmlTraceChoiceDefinition
  OmlTraceChoiceDefinition (p1) == 
    ( setDefs(p1) );

  public OmlTraceChoiceDefinition:
    (seq of IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceChoiceDefinition
  OmlTraceChoiceDefinition (p1,line,column) == 
    ( setDefs(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivDefs : seq of IOmlTraceDefinition := []

operations
  public getDefs: () ==> seq of IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: seq of IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

  public addDefs: IOmlNode ==> ()
  addDefs (parg) == ivDefs := ivDefs ^ [parg];

end OmlTraceChoiceDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceCoreDefinition is subclass of IOmlTraceCoreDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceCoreDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceCoreDefinition(self);

end OmlTraceCoreDefinition
\end{vdm_al}
\begin{vdm_al}
class OmlTraceDefinition is subclass of IOmlTraceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinition(self);

end OmlTraceDefinition
\end{vdm_al}
\begin{vdm_al}
class OmlTraceDefinitionItem is subclass of IOmlTraceDefinitionItem
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinitionItem";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinitionItem(self);

  public OmlTraceDefinitionItem:
    (seq of IOmlTraceBinding) *
    (IOmlTraceCoreDefinition) *
    [IOmlTraceRepeatPattern] ==> OmlTraceDefinitionItem
  OmlTraceDefinitionItem (p1,p2,p3) == 
    ( setBind(p1);
      setTest(p2);
      setRegexpr(p3) );

  public OmlTraceDefinitionItem:
    (seq of IOmlTraceBinding) *
    (IOmlTraceCoreDefinition) *
    [IOmlTraceRepeatPattern] *
    nat *
    nat ==> OmlTraceDefinitionItem
  OmlTraceDefinitionItem (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setTest(p2);
      setRegexpr(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "test" in
        if fname in set dom data
        then setTest(data(fname));
      let fname = "regexpr" in
        if fname in set dom data
        then setRegexpr(data(fname)) );

instance variables
  private ivBind : seq of IOmlTraceBinding := []

operations
  public getBind: () ==> seq of IOmlTraceBinding
  getBind() == return ivBind;

  public setBind: seq of IOmlTraceBinding ==> ()
  setBind(parg) == ivBind := parg;

  public addBind: IOmlNode ==> ()
  addBind (parg) == ivBind := ivBind ^ [parg];

instance variables
  private ivTest : [IOmlTraceCoreDefinition] := nil

operations
  public getTest: () ==> IOmlTraceCoreDefinition
  getTest() == return ivTest;

  public setTest: IOmlTraceCoreDefinition ==> ()
  setTest(parg) == ivTest := parg;

instance variables
  private ivRegexpr : [IOmlTraceRepeatPattern] := nil

operations
  public getRegexpr: () ==> IOmlTraceRepeatPattern
  getRegexpr() == return ivRegexpr
    pre hasRegexpr();

  public hasRegexpr: () ==> bool
  hasRegexpr () == return ivRegexpr <> nil;

  public setRegexpr: [ IOmlTraceRepeatPattern ] ==> ()
  setRegexpr(parg) == ivRegexpr := parg;

end OmlTraceDefinitionItem
\end{vdm_al}

\begin{vdm_al}
class OmlTraceDefinitions is subclass of IOmlTraceDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinitions(self);

  public OmlTraceDefinitions:
    (seq of IOmlNamedTrace) ==> OmlTraceDefinitions
  OmlTraceDefinitions (p1) == 
    ( setTraces(p1) );

  public OmlTraceDefinitions:
    (seq of IOmlNamedTrace) *
    nat *
    nat ==> OmlTraceDefinitions
  OmlTraceDefinitions (p1,line,column) == 
    ( setTraces(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "traces" in
        if fname in set dom data
        then setTraces(data(fname)) );

instance variables
  private ivTraces : seq of IOmlNamedTrace := []

operations
  public getTraces: () ==> seq of IOmlNamedTrace
  getTraces() == return ivTraces;

  public setTraces: seq of IOmlNamedTrace ==> ()
  setTraces(parg) == ivTraces := parg;

  public addTraces: IOmlNode ==> ()
  addTraces (parg) == ivTraces := ivTraces ^ [parg];

end OmlTraceDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTraceLetBeBinding is subclass of IOmlTraceLetBeBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceLetBeBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceLetBeBinding(self);

  public OmlTraceLetBeBinding:
    (IOmlBind) *
    [IOmlExpression] ==> OmlTraceLetBeBinding
  OmlTraceLetBeBinding (p1,p2) == 
    ( setBind(p1);
      setBest(p2) );

  public OmlTraceLetBeBinding:
    (IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlTraceLetBeBinding
  OmlTraceLetBeBinding (p1,p2,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

end OmlTraceLetBeBinding
\end{vdm_al}

\begin{vdm_al}
class OmlTraceLetBinding is subclass of IOmlTraceLetBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceLetBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceLetBinding(self);

  public OmlTraceLetBinding:
    (seq of IOmlValueShape) ==> OmlTraceLetBinding
  OmlTraceLetBinding (p1) == 
    ( setDefinitionList(p1) );

  public OmlTraceLetBinding:
    (seq of IOmlValueShape) *
    nat *
    nat ==> OmlTraceLetBinding
  OmlTraceLetBinding (p1,line,column) == 
    ( setDefinitionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

end OmlTraceLetBinding
\end{vdm_al}

\begin{vdm_al}
class OmlTraceMethodApply is subclass of IOmlTraceMethodApply
operations
  public identity: () ==> seq of char
  identity () == return "TraceMethodApply";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceMethodApply(self);

  public OmlTraceMethodApply:
    (seq of char) *
    (seq of char) *
    (seq of IOmlExpression) ==> OmlTraceMethodApply
  OmlTraceMethodApply (p1,p2,p3) == 
    ( setVariableName(p1);
      setMethodName(p2);
      setArgs(p3) );

  public OmlTraceMethodApply:
    (seq of char) *
    (seq of char) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlTraceMethodApply
  OmlTraceMethodApply (p1,p2,p3,line,column) == 
    ( setVariableName(p1);
      setMethodName(p2);
      setArgs(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "variable_name" in
        if fname in set dom data
        then setVariableName(data(fname));
      let fname = "method_name" in
        if fname in set dom data
        then setMethodName(data(fname));
      let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname)) );

instance variables
  private ivVariableName : seq of char := []

operations
  public getVariableName: () ==> seq of char
  getVariableName() == return ivVariableName;

  public setVariableName: seq of char ==> ()
  setVariableName(parg) == ivVariableName := parg;

instance variables
  private ivMethodName : seq of char := []

operations
  public getMethodName: () ==> seq of char
  getMethodName() == return ivMethodName;

  public setMethodName: seq of char ==> ()
  setMethodName(parg) == ivMethodName := parg;

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

end OmlTraceMethodApply
\end{vdm_al}

\begin{vdm_al}
class OmlTraceOneOrMore is subclass of IOmlTraceOneOrMore
operations
  public identity: () ==> seq of char
  identity () == return "TraceOneOrMore";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceOneOrMore(self);

  public OmlTraceOneOrMore:
    () ==> OmlTraceOneOrMore
  OmlTraceOneOrMore () == 
    skip;

  public OmlTraceOneOrMore:
    nat *
    nat ==> OmlTraceOneOrMore
  OmlTraceOneOrMore (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceOneOrMore
\end{vdm_al}

\begin{vdm_al}
class OmlTraceRange is subclass of IOmlTraceRange
operations
  public identity: () ==> seq of char
  identity () == return "TraceRange";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceRange(self);

  public OmlTraceRange:
    (IOmlNumericLiteral) *
    [IOmlNumericLiteral] ==> OmlTraceRange
  OmlTraceRange (p1,p2) == 
    ( setLower(p1);
      setUpper(p2) );

  public OmlTraceRange:
    (IOmlNumericLiteral) *
    [IOmlNumericLiteral] *
    nat *
    nat ==> OmlTraceRange
  OmlTraceRange (p1,p2,line,column) == 
    ( setLower(p1);
      setUpper(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivLower : [IOmlNumericLiteral] := nil

operations
  public getLower: () ==> IOmlNumericLiteral
  getLower() == return ivLower;

  public setLower: IOmlNumericLiteral ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlNumericLiteral] := nil

operations
  public getUpper: () ==> IOmlNumericLiteral
  getUpper() == return ivUpper
    pre hasUpper();

  public hasUpper: () ==> bool
  hasUpper () == return ivUpper <> nil;

  public setUpper: [ IOmlNumericLiteral ] ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlTraceRange
\end{vdm_al}

\begin{vdm_al}
class OmlTraceRepeatPattern is subclass of IOmlTraceRepeatPattern
operations
  public identity: () ==> seq of char
  identity () == return "TraceRepeatPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceRepeatPattern(self);

end OmlTraceRepeatPattern
\end{vdm_al}
\begin{vdm_al}
class OmlTraceSequenceDefinition is subclass of IOmlTraceSequenceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceSequenceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceSequenceDefinition(self);

  public OmlTraceSequenceDefinition:
    (seq of IOmlTraceDefinition) ==> OmlTraceSequenceDefinition
  OmlTraceSequenceDefinition (p1) == 
    ( setDefs(p1) );

  public OmlTraceSequenceDefinition:
    (seq of IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceSequenceDefinition
  OmlTraceSequenceDefinition (p1,line,column) == 
    ( setDefs(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivDefs : seq of IOmlTraceDefinition := []

operations
  public getDefs: () ==> seq of IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: seq of IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

  public addDefs: IOmlNode ==> ()
  addDefs (parg) == ivDefs := ivDefs ^ [parg];

end OmlTraceSequenceDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceZeroOrMore is subclass of IOmlTraceZeroOrMore
operations
  public identity: () ==> seq of char
  identity () == return "TraceZeroOrMore";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceZeroOrMore(self);

  public OmlTraceZeroOrMore:
    () ==> OmlTraceZeroOrMore
  OmlTraceZeroOrMore () == 
    skip;

  public OmlTraceZeroOrMore:
    nat *
    nat ==> OmlTraceZeroOrMore
  OmlTraceZeroOrMore (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceZeroOrMore
\end{vdm_al}

\begin{vdm_al}
class OmlTraceZeroOrOne is subclass of IOmlTraceZeroOrOne
operations
  public identity: () ==> seq of char
  identity () == return "TraceZeroOrOne";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceZeroOrOne(self);

  public OmlTraceZeroOrOne:
    () ==> OmlTraceZeroOrOne
  OmlTraceZeroOrOne () == 
    skip;

  public OmlTraceZeroOrOne:
    nat *
    nat ==> OmlTraceZeroOrOne
  OmlTraceZeroOrOne (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceZeroOrOne
\end{vdm_al}

\begin{vdm_al}
class OmlTrapDefinition is subclass of IOmlTrapDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TrapDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTrapDefinition(self);

  public OmlTrapDefinition:
    (IOmlPatternBind) *
    (IOmlStatement) ==> OmlTrapDefinition
  OmlTrapDefinition (p1,p2) == 
    ( setPatternBind(p1);
      setStatement(p2) );

  public OmlTrapDefinition:
    (IOmlPatternBind) *
    (IOmlStatement) *
    nat *
    nat ==> OmlTrapDefinition
  OmlTrapDefinition (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlTrapDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTrapStatement is subclass of IOmlTrapStatement
operations
  public identity: () ==> seq of char
  identity () == return "TrapStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTrapStatement(self);

  public OmlTrapStatement:
    (IOmlPatternBind) *
    (IOmlStatement) *
    (IOmlStatement) ==> OmlTrapStatement
  OmlTrapStatement (p1,p2,p3) == 
    ( setPatternBind(p1);
      setWithPart(p2);
      setInPart(p3) );

  public OmlTrapStatement:
    (IOmlPatternBind) *
    (IOmlStatement) *
    (IOmlStatement) *
    nat *
    nat ==> OmlTrapStatement
  OmlTrapStatement (p1,p2,p3,line,column) == 
    ( setPatternBind(p1);
      setWithPart(p2);
      setInPart(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "with_part" in
        if fname in set dom data
        then setWithPart(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivWithPart : [IOmlStatement] := nil

operations
  public getWithPart: () ==> IOmlStatement
  getWithPart() == return ivWithPart;

  public setWithPart: IOmlStatement ==> ()
  setWithPart(parg) == ivWithPart := parg;

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlTrapStatement
\end{vdm_al}

\begin{vdm_al}
class OmlTupleConstructor is subclass of IOmlTupleConstructor
operations
  public identity: () ==> seq of char
  identity () == return "TupleConstructor";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTupleConstructor(self);

  public OmlTupleConstructor:
    (seq of IOmlExpression) ==> OmlTupleConstructor
  OmlTupleConstructor (p1) == 
    ( setExpressionList(p1) );

  public OmlTupleConstructor:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlTupleConstructor
  OmlTupleConstructor (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlTupleConstructor
\end{vdm_al}

\begin{vdm_al}
class OmlTuplePattern is subclass of IOmlTuplePattern
operations
  public identity: () ==> seq of char
  identity () == return "TuplePattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTuplePattern(self);

  public OmlTuplePattern:
    (seq of IOmlPattern) ==> OmlTuplePattern
  OmlTuplePattern (p1) == 
    ( setPatternList(p1) );

  public OmlTuplePattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlTuplePattern
  OmlTuplePattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlTuplePattern
\end{vdm_al}

\begin{vdm_al}
class OmlType is subclass of IOmlType
operations
  public identity: () ==> seq of char
  identity () == return "Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitType(self);

end OmlType
\end{vdm_al}
\begin{vdm_al}
class OmlTypeBind is subclass of IOmlTypeBind
operations
  public identity: () ==> seq of char
  identity () == return "TypeBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeBind(self);

  public OmlTypeBind:
    (seq of IOmlPattern) *
    (IOmlType) ==> OmlTypeBind
  OmlTypeBind (p1,p2) == 
    ( setPattern(p1);
      setType(p2) );

  public OmlTypeBind:
    (seq of IOmlPattern) *
    (IOmlType) *
    nat *
    nat ==> OmlTypeBind
  OmlTypeBind (p1,p2,line,column) == 
    ( setPattern(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivPattern : seq of IOmlPattern := []

operations
  public getPattern: () ==> seq of IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: seq of IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

  public addPattern: IOmlNode ==> ()
  addPattern (parg) == ivPattern := ivPattern ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlTypeBind
\end{vdm_al}

\begin{vdm_al}
class OmlTypeDefinition is subclass of IOmlTypeDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TypeDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeDefinition(self);

  public OmlTypeDefinition:
    (IOmlAccessDefinition) *
    (IOmlTypeShape) ==> OmlTypeDefinition
  OmlTypeDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlTypeDefinition:
    (IOmlAccessDefinition) *
    (IOmlTypeShape) *
    nat *
    nat ==> OmlTypeDefinition
  OmlTypeDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlTypeShape] := nil

operations
  public getShape: () ==> IOmlTypeShape
  getShape() == return ivShape;

  public setShape: IOmlTypeShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlTypeDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTypeDefinitions is subclass of IOmlTypeDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "TypeDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeDefinitions(self);

  public OmlTypeDefinitions:
    (seq of IOmlTypeDefinition) ==> OmlTypeDefinitions
  OmlTypeDefinitions (p1) == 
    ( setTypeList(p1) );

  public OmlTypeDefinitions:
    (seq of IOmlTypeDefinition) *
    nat *
    nat ==> OmlTypeDefinitions
  OmlTypeDefinitions (p1,line,column) == 
    ( setTypeList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type_list" in
        if fname in set dom data
        then setTypeList(data(fname)) );

instance variables
  private ivTypeList : seq of IOmlTypeDefinition := []

operations
  public getTypeList: () ==> seq of IOmlTypeDefinition
  getTypeList() == return ivTypeList;

  public setTypeList: seq of IOmlTypeDefinition ==> ()
  setTypeList(parg) == ivTypeList := parg;

  public addTypeList: IOmlNode ==> ()
  addTypeList (parg) == ivTypeList := ivTypeList ^ [parg];

end OmlTypeDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTypeName is subclass of IOmlTypeName
operations
  public identity: () ==> seq of char
  identity () == return "TypeName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeName(self);

  public OmlTypeName:
    (IOmlName) ==> OmlTypeName
  OmlTypeName (p1) == 
    ( setName(p1) );

  public OmlTypeName:
    (IOmlName) *
    nat *
    nat ==> OmlTypeName
  OmlTypeName (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlTypeName
\end{vdm_al}

\begin{vdm_al}
class OmlTypeShape is subclass of IOmlTypeShape
operations
  public identity: () ==> seq of char
  identity () == return "TypeShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeShape(self);

end OmlTypeShape
\end{vdm_al}
\begin{vdm_al}
class OmlTypeVariable is subclass of IOmlTypeVariable
operations
  public identity: () ==> seq of char
  identity () == return "TypeVariable";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeVariable(self);

  public OmlTypeVariable:
    (seq of char) ==> OmlTypeVariable
  OmlTypeVariable (p1) == 
    ( setIdentifier(p1) );

  public OmlTypeVariable:
    (seq of char) *
    nat *
    nat ==> OmlTypeVariable
  OmlTypeVariable (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlTypeVariable
\end{vdm_al}

\begin{vdm_al}
class OmlTypelessExplicitFunction is subclass of IOmlTypelessExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "TypelessExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypelessExplicitFunction(self);

  public OmlTypelessExplicitFunction:
    (seq of char) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlTypelessExplicitFunction
  OmlTypelessExplicitFunction (p1,p2,p3,p4) == 
    ( setIdentifier(p1);
      setParameterList(p2);
      setBody(p3);
      setTrailer(p4) );

  public OmlTypelessExplicitFunction:
    (seq of char) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlTypelessExplicitFunction
  OmlTypelessExplicitFunction (p1,p2,p3,p4,line,column) == 
    ( setIdentifier(p1);
      setParameterList(p2);
      setBody(p3);
      setTrailer(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivParameterList : seq of IOmlParameter := []

operations
  public getParameterList: () ==> seq of IOmlParameter
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlParameter ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlTypelessExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlUnaryExpression is subclass of IOmlUnaryExpression
operations
  public identity: () ==> seq of char
  identity () == return "UnaryExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnaryExpression(self);

  public OmlUnaryExpression:
    (IOmlUnaryOperator) *
    (IOmlExpression) ==> OmlUnaryExpression
  OmlUnaryExpression (p1,p2) == 
    ( setOperator(p1);
      setExpression(p2) );

  public OmlUnaryExpression:
    (IOmlUnaryOperator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlUnaryExpression
  OmlUnaryExpression (p1,p2,line,column) == 
    ( setOperator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operator" in
        if fname in set dom data
        then setOperator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivOperator : [IOmlUnaryOperator] := nil

operations
  public getOperator: () ==> IOmlUnaryOperator
  getOperator() == return ivOperator;

  public setOperator: IOmlUnaryOperator ==> ()
  setOperator(parg) == ivOperator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlUnaryExpression
\end{vdm_al}

\begin{vdm_al}
class OmlUnaryOperator is subclass of IOmlUnaryOperator
operations
  public identity: () ==> seq of char
  identity () == return "UnaryOperator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnaryOperator(self);

  public OmlUnaryOperator: nat ==> OmlUnaryOperator
  OmlUnaryOperator (pv) == setValue(pv);

  public OmlUnaryOperator: nat * nat * nat ==> OmlUnaryOperator
  OmlUnaryOperator (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlUnaryOperatorQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlUnaryOperatorQuotes`getQuoteName(val)
    pre val <> nil;

end OmlUnaryOperator
\end{vdm_al}
\begin{vdm_al}
class OmlUnaryOperatorQuotes
instance variables
  static public IQABS : nat := 0;
  static public IQINVERSE : nat := 1;
  static public IQHD : nat := 2;
  static public IQELEMS : nat := 3;
  static public IQINDS : nat := 4;
  static public IQTL : nat := 5;
  static public IQCARD : nat := 6;
  static public IQDUNION : nat := 7;
  static public IQPOWER : nat := 8;
  static public IQLEN : nat := 9;
  static public IQPLUS : nat := 10;
  static public IQDOM : nat := 11;
  static public IQDMERGE : nat := 12;
  static public IQDINTER : nat := 13;
  static public IQNOT : nat := 14;
  static public IQMINUS : nat := 15;
  static public IQRNG : nat := 16;
  static public IQFLOOR : nat := 17;
  static public IQDCONC : nat := 18;

  static private qmap : map nat to seq of char :=
    { IQABS |-> "<ABS>",
      IQINVERSE |-> "<INVERSE>",
      IQHD |-> "<HD>",
      IQELEMS |-> "<ELEMS>",
      IQINDS |-> "<INDS>",
      IQTL |-> "<TL>",
      IQCARD |-> "<CARD>",
      IQDUNION |-> "<DUNION>",
      IQPOWER |-> "<POWER>",
      IQLEN |-> "<LEN>",
      IQPLUS |-> "<PLUS>",
      IQDOM |-> "<DOM>",
      IQDMERGE |-> "<DMERGE>",
      IQDINTER |-> "<DINTER>",
      IQNOT |-> "<NOT>",
      IQMINUS |-> "<MINUS>",
      IQRNG |-> "<RNG>",
      IQFLOOR |-> "<FLOOR>",
      IQDCONC |-> "<DCONC>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlUnaryOperatorQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlUndefinedExpression is subclass of IOmlUndefinedExpression
operations
  public identity: () ==> seq of char
  identity () == return "UndefinedExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUndefinedExpression(self);

  public OmlUndefinedExpression:
    () ==> OmlUndefinedExpression
  OmlUndefinedExpression () == 
    skip;

  public OmlUndefinedExpression:
    nat *
    nat ==> OmlUndefinedExpression
  OmlUndefinedExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlUndefinedExpression
\end{vdm_al}

\begin{vdm_al}
class OmlUnionType is subclass of IOmlUnionType
operations
  public identity: () ==> seq of char
  identity () == return "UnionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnionType(self);

  public OmlUnionType:
    (IOmlType) *
    (IOmlType) ==> OmlUnionType
  OmlUnionType (p1,p2) == 
    ( setLhsType(p1);
      setRhsType(p2) );

  public OmlUnionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlUnionType
  OmlUnionType (p1,p2,line,column) == 
    ( setLhsType(p1);
      setRhsType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_type" in
        if fname in set dom data
        then setLhsType(data(fname));
      let fname = "rhs_type" in
        if fname in set dom data
        then setRhsType(data(fname)) );

instance variables
  private ivLhsType : [IOmlType] := nil

operations
  public getLhsType: () ==> IOmlType
  getLhsType() == return ivLhsType;

  public setLhsType: IOmlType ==> ()
  setLhsType(parg) == ivLhsType := parg;

instance variables
  private ivRhsType : [IOmlType] := nil

operations
  public getRhsType: () ==> IOmlType
  getRhsType() == return ivRhsType;

  public setRhsType: IOmlType ==> ()
  setRhsType(parg) == ivRhsType := parg;

end OmlUnionType
\end{vdm_al}

\begin{vdm_al}
class OmlValueDefinition is subclass of IOmlValueDefinition
operations
  public identity: () ==> seq of char
  identity () == return "ValueDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueDefinition(self);

  public OmlValueDefinition:
    (IOmlAccessDefinition) *
    (IOmlValueShape) ==> OmlValueDefinition
  OmlValueDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlValueDefinition:
    (IOmlAccessDefinition) *
    (IOmlValueShape) *
    nat *
    nat ==> OmlValueDefinition
  OmlValueDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlValueShape] := nil

operations
  public getShape: () ==> IOmlValueShape
  getShape() == return ivShape;

  public setShape: IOmlValueShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlValueDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlValueDefinitions is subclass of IOmlValueDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "ValueDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueDefinitions(self);

  public OmlValueDefinitions:
    (seq of IOmlValueDefinition) ==> OmlValueDefinitions
  OmlValueDefinitions (p1) == 
    ( setValueList(p1) );

  public OmlValueDefinitions:
    (seq of IOmlValueDefinition) *
    nat *
    nat ==> OmlValueDefinitions
  OmlValueDefinitions (p1,line,column) == 
    ( setValueList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "value_list" in
        if fname in set dom data
        then setValueList(data(fname)) );

instance variables
  private ivValueList : seq of IOmlValueDefinition := []

operations
  public getValueList: () ==> seq of IOmlValueDefinition
  getValueList() == return ivValueList;

  public setValueList: seq of IOmlValueDefinition ==> ()
  setValueList(parg) == ivValueList := parg;

  public addValueList: IOmlNode ==> ()
  addValueList (parg) == ivValueList := ivValueList ^ [parg];

end OmlValueDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlValueShape is subclass of IOmlValueShape
operations
  public identity: () ==> seq of char
  identity () == return "ValueShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueShape(self);

  public OmlValueShape:
    (IOmlPattern) *
    [IOmlType] *
    (IOmlExpression) ==> OmlValueShape
  OmlValueShape (p1,p2,p3) == 
    ( setPattern(p1);
      setType(p2);
      setExpression(p3) );

  public OmlValueShape:
    (IOmlPattern) *
    [IOmlType] *
    (IOmlExpression) *
    nat *
    nat ==> OmlValueShape
  OmlValueShape (p1,p2,p3,line,column) == 
    ( setPattern(p1);
      setType(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType
    pre hasType();

  public hasType: () ==> bool
  hasType () == return ivType <> nil;

  public setType: [ IOmlType ] ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlValueShape
\end{vdm_al}

\begin{vdm_al}
class OmlVarInformation is subclass of IOmlVarInformation
operations
  public identity: () ==> seq of char
  identity () == return "VarInformation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitVarInformation(self);

  public OmlVarInformation:
    (IOmlMode) *
    (seq of IOmlName) *
    [IOmlType] ==> OmlVarInformation
  OmlVarInformation (p1,p2,p3) == 
    ( setMode(p1);
      setNameList(p2);
      setType(p3) );

  public OmlVarInformation:
    (IOmlMode) *
    (seq of IOmlName) *
    [IOmlType] *
    nat *
    nat ==> OmlVarInformation
  OmlVarInformation (p1,p2,p3,line,column) == 
    ( setMode(p1);
      setNameList(p2);
      setType(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "mode" in
        if fname in set dom data
        then setMode(data(fname));
      let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivMode : [IOmlMode] := nil

operations
  public getMode: () ==> IOmlMode
  getMode() == return ivMode;

  public setMode: IOmlMode ==> ()
  setMode(parg) == ivMode := parg;

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType
    pre hasType();

  public hasType: () ==> bool
  hasType () == return ivType <> nil;

  public setType: [ IOmlType ] ==> ()
  setType(parg) == ivType := parg;

end OmlVarInformation
\end{vdm_al}

\begin{vdm_al}
class OmlWaitingExpression is subclass of IOmlWaitingExpression
operations
  public identity: () ==> seq of char
  identity () == return "WaitingExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitWaitingExpression(self);

  public OmlWaitingExpression:
    (seq of IOmlName) ==> OmlWaitingExpression
  OmlWaitingExpression (p1) == 
    ( setNameList(p1) );

  public OmlWaitingExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlWaitingExpression
  OmlWaitingExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlWaitingExpression
\end{vdm_al}

\begin{vdm_al}
class OmlWhileLoop is subclass of IOmlWhileLoop
operations
  public identity: () ==> seq of char
  identity () == return "WhileLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitWhileLoop(self);

  public OmlWhileLoop:
    (IOmlExpression) *
    (IOmlStatement) ==> OmlWhileLoop
  OmlWhileLoop (p1,p2) == 
    ( setExpression(p1);
      setStatement(p2) );

  public OmlWhileLoop:
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlWhileLoop
  OmlWhileLoop (p1,p2,line,column) == 
    ( setExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlWhileLoop
\end{vdm_al}
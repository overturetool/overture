{"modelthy":"theory DEFAULT\n  imports utp_vdm\nbegin\n\ndefinition \"Period \u003d \\\u003cparallel\u003e@token \\\u003cparallel\u003e\"\ndeclare Period_def [eval,evalp]\n\ndefinition \"ExpertId \u003d \\\u003cparallel\u003e@token \\\u003cparallel\u003e\"\ndeclare ExpertId_def [eval,evalp]\n\ndefinition \"Qualification \u003d \\\u003cparallel\u003e\u003cBio\u003e| \u003cChem\u003e| \u003cElec\u003e| \u003cMech\u003e \\\u003cparallel\u003e\"\ndeclare Qualification_def [eval,evalp]\n\n\ntypedef Expert_Tag \u003d \"{True}\" by auto\ninstantiation Expert_Tag :: tag\nbegin\ndefinition \"tagName_Expert_Tag (x::Expert_Tag) \u003d \u0027\u0027Expert\u0027\u0027\"\ninstance\nby (intro_classes, metis (full_types) Abs_Expert_Tag_cases singleton_iff)\nend\n\nabbreviation\"maxty_Expert \\\u003cequiv\u003e RecMaximalType \\\u003cparallel\u003e@token*@set of @Qualification\n\\\u003cparallel\u003e TYPE(Expert_Tag)\"\nabbreviation\"expertid_fld \\\u003cequiv\u003e MkField maxty_Expert#[1]\\\u003cparallel\u003e@token\\\u003cparallel\u003e\"\nabbreviation\"expertid \\\u003cequiv\u003e SelectRec expertid_fld\"\nabbreviation\"eQuali_fld \\\u003cequiv\u003e MkField maxty_Expert#[2]\\\u003cparallel\u003e@set of @Qualification\n\\\u003cparallel\u003e\"\nabbreviation\"eQuali \\\u003cequiv\u003e SelectRec eQuali_fld\"\n\nvdmefun inv_Expert\n  inp ex :: \"maxty_Expert\"\n  out \"bool\"\n  is \"(^ex^.eQuali \u003c\u003e {})\" \n\ndefinition \"Expert \\\u003cequiv\u003e\\\u003cparallel\u003e@maxty_Expert inv ex \u003d\u003d inv_Expert(\u0026ex)\\\u003cparallel\u003e\"\ndeclare Expert_def [eval,evalp]\n\ndefinition \"mk_Expert \\\u003cequiv\u003eMkRec Expert\"\ndeclare mk_Expert_def [eval,evalp]\n\n\ntypedef Alarm_Tag \u003d \"{True}\" by auto\ninstantiation Alarm_Tag :: tag\nbegin\ndefinition \"tagName_Alarm_Tag (x::Alarm_Tag) \u003d \u0027\u0027Alarm\u0027\u0027\"\ninstance\nby (intro_classes, metis (full_types) Abs_Alarm_Tag_cases singleton_iff)\nend\n\nabbreviation\"maxty_Alarm \\\u003cequiv\u003e RecMaximalType \\\u003cparallel\u003e@Qualification\n*@seq of @char\\\u003cparallel\u003e TYPE(Alarm_Tag)\"\nabbreviation\"aQuali_fld \\\u003cequiv\u003e MkField maxty_Alarm#[1]\\\u003cparallel\u003e@Qualification\n\\\u003cparallel\u003e\"\nabbreviation\"aQuali \\\u003cequiv\u003e SelectRec aQuali_fld\"\nabbreviation\"alarmtext_fld \\\u003cequiv\u003e MkField maxty_Alarm#[2]\\\u003cparallel\u003e@seq of @char\\\u003cparallel\u003e\"\nabbreviation\"alarmtext \\\u003cequiv\u003e SelectRec alarmtext_fld\"\n\n\n\ndefinition \"Alarm \\\u003cequiv\u003e\\\u003cparallel\u003e@maxty_Alarm \\\u003cparallel\u003e\"\ndeclare Alarm_def [eval,evalp]\n\ndefinition \"mk_Alarm \\\u003cequiv\u003eMkRec Alarm\"\ndeclare mk_Alarm_def [eval,evalp]\n\nvdmefun inv_Schedule\n  inp sch :: \"@map @token to @set of maxty_Expert\"\n  out \"bool\"\n  is \"(forall exs in @set rng (^sch^) \u0026 ((^exs^ \u003c\u003e {}) and (forall ex1, ex2 in @set ^exs^ \u0026 (not ((^ex1^ \u003c\u003e ^ex2^)) or (^ex1^.expertid \u003c\u003e ^ex2^.expertid)))))\" \n\ndefinition \"Schedule \u003d \\\u003cparallel\u003e@map @token to @set of maxty_Expert inv sch \u003d\u003d inv_Schedule(\u0026sch)\\\u003cparallel\u003e\"\ndeclare Schedule_def [eval,evalp]\n\n\ntypedef Plant_Tag \u003d \"{True}\" by auto\ninstantiation Plant_Tag :: tag\nbegin\ndefinition \"tagName_Plant_Tag (x::Plant_Tag) \u003d \u0027\u0027Plant\u0027\u0027\"\ninstance\nby (intro_classes, metis (full_types) Abs_Plant_Tag_cases singleton_iff)\nend\n\nabbreviation\"maxty_Plant \\\u003cequiv\u003e RecMaximalType \\\u003cparallel\u003e@map @token to @set of maxty_Expert*@set of maxty_Alarm\\\u003cparallel\u003e TYPE(Plant_Tag)\"\nabbreviation\"schedule_fld \\\u003cequiv\u003e MkField maxty_Plant#[1]\\\u003cparallel\u003e@map @token to @set of maxty_Expert\\\u003cparallel\u003e\"\nabbreviation\"schedule \\\u003cequiv\u003e SelectRec schedule_fld\"\nabbreviation\"alarms_fld \\\u003cequiv\u003e MkField maxty_Plant#[2]\\\u003cparallel\u003e@set of maxty_Alarm\\\u003cparallel\u003e\"\nabbreviation\"alarms \\\u003cequiv\u003e SelectRec alarms_fld\"\n\nvdmefun inv_Plant\n  inp p :: \"maxty_Plant\"\n  out \"bool\"\n  is \"(forall a in @set ^p^.alarms \u0026 (forall peri in @set dom (^p^.schedule) \u0026 true))\" \n\ndefinition \"Plant \\\u003cequiv\u003e\\\u003cparallel\u003e@maxty_Plant inv p \u003d\u003d inv_Plant(\u0026p)\\\u003cparallel\u003e\"\ndeclare Plant_def [eval,evalp]\n\ndefinition \"mk_Plant \\\u003cequiv\u003eMkRec Plant\"\ndeclare mk_Plant_def [eval,evalp]\n\nvdmefun NumberOfExperts\n  inp peri :: \"@token\" and plant :: \"maxty_Plant\"\n  out \"@nat\"\n  pre \"(^peri^ in @set dom (^plant^.schedule))\"\n  is \"card (^plant^.schedule[^peri^])\" \n\nvdmefun ExpertIsOnDuty\n  inp ex :: \"maxty_Expert\" and p :: \"maxty_Plant\"\n  out \"@set of @token\"\n  is \"{^peri^ | peri in @set dom (^p^.schedule)  \u0026 (^ex^ in @set ^p^.schedule[^peri^])}\" \n\nvdmifun ExpertToPage\n  inp a :: \"maxty_Alarm\" and peri :: \"@token\" and plant :: \"maxty_Plant\"\n  out r :: \"maxty_Expert\"\n  pre \"((^peri^ in @set dom (^plant^.schedule)) and (^a^ in @set ^plant^.alarms))\"\n  post \"((^r^ in @set ^plant^.schedule[^peri^]) and (^a^.aQuali in @set ^r^.eQuali))\"\n\n\nvdmefun QualificationOK\n  inp exs :: \"@set of maxty_Expert\" and reqquali :: \"@Qualification\n\"\n  out \"bool\"\n  is \"(exists ex in @set ^exs^ \u0026 (^reqquali^ in @set ^ex^.eQuali))\" \n\nend","posthy":"theory DEFAULT_POs\nimports DEFAULT\nbegin\n\n(* Expert: type invariant satisfiable obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 8:3\n(exists ex:Expert \u0026 ((ex.eQuali) \u003c\u003e {})) *)\nlemma POExpert1: \"+|(exists ex : maxty_Expert \u0026 (^ex^.eQuali \u003c\u003e {}))|+\" by vdm_auto_tac\n\n(* Schedule: type invariant satisfiable obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 15:3\n(exists sch:Schedule \u0026 (forall exs in set (rng sch) \u0026 ((exs \u003c\u003e {}) and (forall ex1, ex2 in set exs \u0026 ((ex1 \u003c\u003e ex2) \u003d\u003e ((ex1.expertid) \u003c\u003e (ex2.expertid))))))) *)\nlemma POSchedule2: \"+|(exists sch : @map @token to @set of maxty_Expert \u0026 (forall exs in @set rng (^sch^) \u0026 ((^exs^ \u003c\u003e {}) and (forall ex1, ex2 in @set ^exs^ \u0026 (not ((^ex1^ \u003c\u003e ^ex2^)) or (^ex1^.expertid \u003c\u003e ^ex2^.expertid))))))|+\" by vdm_auto_tac\n\n(* Plant: type invariant satisfiable obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 23:3\n(exists p:Plant \u0026 (forall a in set (p.alarms) \u0026 (forall peri in set (dom (p.schedule)) \u0026 true))) *)\nlemma POPlant3: \"+|(exists p : maxty_Plant \u0026 (forall a in @set ^p^.alarms \u0026 (forall peri in @set dom (^p^.schedule) \u0026 true)))|+\" by vdm_auto_tac\n\n(* NumberOfExperts: legal map application obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 33:10\n(forall peri:Period, plant:Plant \u0026 ((peri in set (dom (plant.schedule))) \u003d\u003e (peri in set (dom (plant.schedule))))) *)\nlemma PONumberOfExperts4: \"+|(forall peri : @token, plant : maxty_Plant \u0026 (not ((^peri^ in @set dom (^plant^.schedule))) or (^peri^ in @set dom (^plant^.schedule))))|+\" by vdm_auto_tac\n\n(* ExpertIsOnDuty: legal map application obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 38:51\n(forall ex:Expert, p:Plant \u0026 (forall peri in set (dom (p.schedule)) \u0026 (peri in set (dom (p.schedule))))) *)\nlemma POExpertIsOnDuty5: \"+|(forall ex : maxty_Expert, p : maxty_Plant \u0026 (forall peri in @set dom (^p^.schedule) \u0026 (^peri^ in @set dom (^p^.schedule))))|+\" by vdm_auto_tac\n\n(* ExpertToPage: legal map application obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 43:17\n(forall a:Alarm, peri:Period, plant:Plant \u0026 (((peri in set (dom (plant.schedule))) and (a in set (plant.alarms))) \u003d\u003e (exists r:Expert \u0026 (peri in set (dom (plant.schedule)))))) *)\nlemma POExpertToPage6: \"+|(forall a : maxty_Alarm, peri : @token, plant : maxty_Plant \u0026 (not (((^peri^ in @set dom (^plant^.schedule)) and (^a^ in @set ^plant^.alarms))) or (exists r : maxty_Expert \u0026 (^peri^ in @set dom (^plant^.schedule)))))|+\" by vdm_auto_tac\n\n(* ExpertToPage: function postcondition satisfiable obligation @ in \u0027DEFAULT\u0027 (alarm.vdmsl) at line 40:3\n(forall a:Alarm, peri:Period, plant:Plant \u0026 (pre_ExpertToPage(a, peri, plant) \u003d\u003e (exists r:Expert \u0026 post_ExpertToPage(a, peri, plant, r)))) *)\nlemma POExpertToPage7: \"+|(forall a : maxty_Alarm, peri : @token, plant : maxty_Plant \u0026 (not (pre_ExpertToPage(^a^, ^peri^, ^plant^)) or (exists r : maxty_Expert \u0026 post_ExpertToPage(^a^, ^peri^, ^plant^, ^r^))))|+\" by vdm_auto_tac\n\nend","negative":false}